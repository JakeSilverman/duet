// c::tag-#anon#ST[S32'init'||S32'locked'|]
// 
struct anon$0;

// c::tag-#anon#ST[S32'supports_temp'||S32'boot_status'||U64'io_addr'||SYM#c::tag-#anon#ST[S32'init'||S32'locked'|]#'io_lock'||*{SYM#c::tag-pci_dev#}'pdev'|]
// 
struct anon$1;

// c::tag-#anon#ST[U32'written'||U32'count'|]
// 
struct anon$2;

// c::tag-__pthread_attr_t_struct
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 49
struct __pthread_attr_t_struct;

// c::tag-__pthread_mutex_t_struct
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 25
struct __pthread_mutex_t_struct;

// c::tag-__pthread_mutexattr_t_struct
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 30
struct __pthread_mutexattr_t_struct;

// c::tag-__pthread_t_struct
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 44
struct __pthread_t_struct;

// c::tag-__wait_queue_head
// file /usr/local/ddv/models/con2/include/linux/wait.h line 16
struct __wait_queue_head;

// c::tag-address_space
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space;

// c::tag-address_space$link10
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link10;

// c::tag-address_space$link23
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link23;

// c::tag-address_space$link3
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link3;

// c::tag-address_space$link4
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link4;

// c::tag-address_space$link5
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link5;

// c::tag-address_space$link7
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link7;

// c::tag-address_space$link9
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link9;

// c::tag-backing_dev_info
// file /usr/local/ddv/models/con2/include/linux/backing-dev.h line 11
struct backing_dev_info;

// c::tag-bio
// file /usr/local/ddv/models/con2/include/linux/bio.h line 17
struct bio;

// c::tag-bio$link15
// file /usr/local/ddv/models/con2/include/linux/bio.h line 17
struct bio$link15;

// c::tag-bio$link8
// file /usr/local/ddv/models/con2/include/linux/bio.h line 17
struct bio$link8;

// c::tag-bio_vec
// file /usr/local/ddv/models/con2/include/linux/bio.h line 6
struct bio_vec;

// c::tag-block_device
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device;

// c::tag-block_device$link0
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link0;

// c::tag-block_device$link1
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link1;

// c::tag-block_device$link10
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link10;

// c::tag-block_device$link2
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link2;

// c::tag-block_device$link22
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link22;

// c::tag-block_device$link5
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link5;

// c::tag-block_device$link9
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link9;

// c::tag-block_device_operations
// file /usr/local/ddv/models/con2/include/linux/fs.h line 168
struct block_device_operations;

// c::tag-block_device_operations$link1
// file /usr/local/ddv/models/con2/include/linux/fs.h line 168
struct block_device_operations$link1;

// c::tag-block_device_operations$link12
// file /usr/local/ddv/models/con2/include/linux/fs.h line 168
struct block_device_operations$link12;

// c::tag-cdev
// file /usr/local/ddv/models/con2/include/linux/cdev.h line 4
struct cdev;

// c::tag-cdev$link0
// file /usr/local/ddv/models/con2/include/linux/cdev.h line 4
struct cdev$link0;

// c::tag-cdev$link1
// file /usr/local/ddv/models/con2/include/linux/cdev.h line 4
struct cdev$link1;

// c::tag-cdev$link20
// file /usr/local/ddv/models/con2/include/linux/cdev.h line 4
struct cdev$link20;

// c::tag-cdev$link7
// file /usr/local/ddv/models/con2/include/linux/cdev.h line 4
struct cdev$link7;

// c::tag-ddv_cdev
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 13
struct ddv_cdev;

// c::tag-ddv_cdev$link14
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 13
struct ddv_cdev$link14;

// c::tag-ddv_cdev$link21
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 13
struct ddv_cdev$link21;

// c::tag-ddv_cdev$link7
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 13
struct ddv_cdev$link7;

// c::tag-ddv_genhd
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 15
struct ddv_genhd;

// c::tag-ddv_genhd$link18
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 15
struct ddv_genhd$link18;

// c::tag-ddv_genhd$link20
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 15
struct ddv_genhd$link20;

// c::tag-ddv_pci_driver
// file /usr/local/ddv/models/con2/include/ddverify/pci.h line 6
struct ddv_pci_driver;

// c::tag-ddv_pci_driver$link3
// file /usr/local/ddv/models/con2/include/ddverify/pci.h line 6
struct ddv_pci_driver$link3;

// c::tag-ddv_tasklet
// file /usr/local/ddv/models/con2/include/ddverify/tasklet.h line 10
struct ddv_tasklet;

// c::tag-ddv_timer
// file /usr/local/ddv/models/con2/include/ddverify/timer.h line 10
struct ddv_timer;

// c::tag-ddv_tty_driver
// file /usr/local/ddv/models/con2/include/ddverify/tty.h line 7
struct ddv_tty_driver;

// c::tag-dentry
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry;

// c::tag-dentry$link10
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link10;

// c::tag-dentry$link11
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link11;

// c::tag-dentry$link14
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link14;

// c::tag-dentry$link25
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link25;

// c::tag-dentry$link5
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link5;

// c::tag-dentry$link7
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link7;

// c::tag-dentry$link8
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link8;

// c::tag-device
// file /usr/local/ddv/models/con2/include/linux/device.h line 25
struct device;

// c::tag-device$link0
// file /usr/local/ddv/models/con2/include/linux/device.h line 25
struct device$link0;

// c::tag-device$link12
// file /usr/local/ddv/models/con2/include/linux/device.h line 25
struct device$link12;

// c::tag-device$link13
// file /usr/local/ddv/models/con2/include/linux/device.h line 25
struct device$link13;

// c::tag-device$link2
// file /usr/local/ddv/models/con2/include/linux/device.h line 25
struct device$link2;

// c::tag-file
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file;

// c::tag-file$link10
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link10;

// c::tag-file$link15
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link15;

// c::tag-file$link26
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link26;

// c::tag-file$link6
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link6;

// c::tag-file$link7
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link7;

// c::tag-file$link8
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link8;

// c::tag-file$link9
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link9;

// c::tag-file_lock
// file /usr/local/ddv/models/con2/include/linux/fs.h line 130
struct file_lock;

// c::tag-file_operations
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations;

// c::tag-file_operations$link11
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link11;

// c::tag-file_operations$link12
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link12;

// c::tag-file_operations$link19
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link19;

// c::tag-file_operations$link4
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link4;

// c::tag-file_operations$link5
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link5;

// c::tag-file_operations$link6
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link6;

// c::tag-file_operations$link9
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link9;

// c::tag-gendisk
// file /usr/local/ddv/models/con2/include/linux/fs.h line 107
struct gendisk;

// c::tag-gendisk$link0
// file /usr/local/ddv/models/con2/include/linux/genhd.h line 17
struct gendisk$link0;

// c::tag-gendisk$link4
// file /usr/local/ddv/models/con2/include/linux/genhd.h line 17
struct gendisk$link4;

// c::tag-hd_geometry
// file /usr/local/ddv/models/con2/include/linux/fs.h line 82
struct hd_geometry;

// c::tag-inode
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode;

// c::tag-inode$link1
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link1;

// c::tag-inode$link2
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link2;

// c::tag-inode$link21
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link21;

// c::tag-inode$link3
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link3;

// c::tag-inode$link4
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link4;

// c::tag-inode$link6
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link6;

// c::tag-inode$link8
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link8;

// c::tag-iovec
// file /usr/local/ddv/models/con2/include/linux/fs.h line 83
struct iovec;

// c::tag-list_head
// file /usr/local/ddv/models/con2/include/linux/list.h line 9
struct list_head;

// c::tag-list_head$link16
// file /usr/local/ddv/models/con2/include/linux/list.h line 9
struct list_head$link16;

// c::tag-list_head$link18
// file /usr/local/ddv/models/con2/include/linux/list.h line 9
struct list_head$link18;

// c::tag-miscdevice
// file /usr/local/ddv/models/con2/include/linux/miscdevice.h line 34
struct miscdevice;

// c::tag-miscdevice$link22
// file /usr/local/ddv/models/con2/include/linux/miscdevice.h line 34
struct miscdevice$link22;

// c::tag-module
// file /usr/local/ddv/models/con2/include/linux/fs.h line 135
struct module;

// c::tag-mutex
// file /usr/local/ddv/models/con2/include/linux/mutex.h line 20
struct mutex;

// c::tag-notifier_block
// file /usr/local/ddv/models/con2/include/linux/notifier.h line 15
struct notifier_block;

// c::tag-page
// file /usr/local/ddv/models/con2/include/linux/gfp.h line 67
struct page;

// c::tag-pci_bus
// file /usr/local/ddv/models/con2/include/linux/pci.h line 62
struct pci_bus;

// c::tag-pci_dev
// file /usr/local/ddv/models/con2/include/linux/pci.h line 43
struct pci_dev;

// c::tag-pci_dev$link1
// file /usr/local/ddv/models/con2/include/linux/pci.h line 43
struct pci_dev$link1;

// c::tag-pci_dev$link13
// file /usr/local/ddv/models/con2/include/linux/pci.h line 43
struct pci_dev$link13;

// c::tag-pci_device_id
// file /usr/local/ddv/models/con2/include/linux/mod_devicetable.h line 10
struct pci_device_id;

// c::tag-pci_driver
// file /usr/local/ddv/models/con2/include/linux/pci.h line 67
struct pci_driver;

// c::tag-pci_driver$link14
// file /usr/local/ddv/models/con2/include/linux/pci.h line 67
struct pci_driver$link14;

// c::tag-pci_driver$link2
// file /usr/local/ddv/models/con2/include/linux/pci.h line 67
struct pci_driver$link2;

// c::tag-pm_message
// file /usr/local/ddv/models/con2/include/linux/pm.h line 8
struct pm_message;

// c::tag-poll_table_struct
// file /usr/local/ddv/models/con2/include/linux/fs.h line 84
struct poll_table_struct;

// c::tag-proc_dir_entry
// file /usr/local/ddv/models/con2/include/linux/proc_fs.h line 7
struct proc_dir_entry;

// c::tag-pt_regs
// file /usr/local/ddv/models/con2/include/asm/ptrace.h line 4
struct pt_regs;

// c::tag-registered_irq
// file /usr/local/ddv/models/con2/include/ddverify/interrupt.h line 9
struct registered_irq;

// c::tag-request
// file /usr/local/ddv/models/con2/include/linux/blkdev.h line 90
struct request;

// c::tag-request$link17
// file /usr/local/ddv/models/con2/include/linux/blkdev.h line 90
struct request$link17;

// c::tag-request$link19
// file /usr/local/ddv/models/con2/include/linux/blkdev.h line 90
struct request$link19;

// c::tag-request_queue
// file /usr/local/ddv/models/con2/include/linux/blkdev.h line 54
struct request_queue;

// c::tag-request_queue$link14
// file /usr/local/ddv/models/con2/include/linux/blkdev.h line 54
struct request_queue$link14;

// c::tag-request_queue$link3
// file /usr/local/ddv/models/con2/include/linux/blkdev.h line 54
struct request_queue$link3;

// c::tag-resource
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 18
struct resource;

// c::tag-semaphore
// file /usr/local/ddv/models/con2/include/asm/semaphore.h line 4
struct semaphore;

// c::tag-tasklet_struct
// file /usr/local/ddv/models/con2/include/linux/interrupt.h line 34
struct tasklet_struct;

// c::tag-termios
// file /usr/local/ddv/models/con2/include/asm/termbits.h line 11
struct termios;

// c::tag-timer_list
// file /usr/local/ddv/models/con2/include/linux/timer.h line 4
struct timer_list;

// c::tag-tty_driver
// file /usr/local/ddv/models/con2/include/linux/tty_driver.h line 43
struct tty_driver;

// c::tag-tty_operations
// file /usr/local/ddv/models/con2/include/linux/tty_driver.h line 12
struct tty_operations;

// c::tag-tty_struct
// file /usr/local/ddv/models/con2/include/linux/tty.h line 113
struct tty_struct;

// c::tag-vm_area_struct
// file /usr/local/ddv/models/con2/include/linux/fs.h line 85
struct vm_area_struct;

// c::tag-watchdog_info
// file /usr/local/ddv/models/con2/include/linux/watchdog.h line 9
struct watchdog_info;

// c::tag-work_struct
// file /usr/local/ddv/models/con2/include/linux/workqueue.h line 12
struct work_struct;


#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif

// c::__get_free_page
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 13
unsigned long int __get_free_page(unsigned int gfp_mask);
// c::__get_free_pages
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 5
unsigned long int __get_free_pages(unsigned int gfp_mask, unsigned int order);
// c::__get_user
// file /usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c line 5
signed int __get_user(signed int size, void *ptr);
// c::__put_user
// file /usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c line 21
signed int __put_user(signed int size, void *ptr);
// c::_ddv_module_exit$object
// 
void _ddv_module_exit$object(void);
// c::_ddv_module_init$object
// 
signed int _ddv_module_init$object(void);
// c::_ddv_tmp_exit$object
// 
void _ddv_tmp_exit$object(void);
// c::_ddv_tmp_init$object
// 
signed int _ddv_tmp_init$object(void);
// c::add_disk
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 38
void add_disk(struct gendisk$link4 *disk);
// c::add_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 15
void add_timer(struct timer_list *timer);
// c::add_timer_on
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 24
void add_timer_on(struct timer_list *timer, signed int cpu);
// c::alloc_chrdev_region
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 9
signed int alloc_chrdev_region(unsigned int *dev, unsigned int baseminor, unsigned int count, const char *name);
// c::alloc_disk
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 22
struct gendisk$link4 * alloc_disk(signed int minors);
// c::alloc_page
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 46
struct page * alloc_page(unsigned int gfp_mask);
// c::alloc_pages
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 38
struct page * alloc_pages(unsigned int gfp_mask, unsigned int order);
// c::alloc_tty_driver
// file /usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c line 4
struct tty_driver * alloc_tty_driver(signed int lines);
// c::assert_context_process
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process();
// c::assert_context_process$link10
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link10();
// c::assert_context_process$link14
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link14();
// c::assert_context_process$link15
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link15();
// c::assert_context_process$link17
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link17();
// c::assert_context_process$link24
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link24();
// c::blk_alloc_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 34
struct request_queue$link14 * blk_alloc_queue(unsigned int gfp_mask);
// c::blk_cleanup_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 69
void blk_cleanup_queue(struct request_queue$link14 *q);
// c::blk_init_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 16
struct request_queue$link14 * blk_init_queue(void (*rfn)(struct request_queue$link14 *), struct anon$0 *lock);
// c::blk_init_queue::rfn$object
// 
void rfn$object(struct request_queue$link14 *);
// c::blk_queue_hardsect_size
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 64
void blk_queue_hardsect_size(struct request_queue$link14 *q, unsigned short int size);
// c::blk_queue_make_request
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 51
void blk_queue_make_request(struct request_queue$link14 *q, signed int (*mfn)(struct request_queue$link14 *, struct bio$link15 *));
// c::blk_queue_make_request::mfn$object
// 
signed int mfn$object(struct request_queue$link14 *, struct bio$link15 *);
// c::call_cdev_functions
// file /usr/local/ddv/models/con2/src/ddverify/cdev.c line 5
void call_cdev_functions();
// c::call_ddv
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 95
signed int call_ddv();
// c::call_interrupt_handler
// file /usr/local/ddv/models/con2/include/ddverify/interrupt.h line 16
void call_interrupt_handler();
// c::call_pci_functions
// file /usr/local/ddv/models/con2/include/ddverify/pci.h line 19
void call_pci_functions();
// c::call_shared_workqueue_functions
// file /usr/local/ddv/models/con2/include/ddverify/workqueue.h line 10
void call_shared_workqueue_functions();
// c::call_tasklet_functions
// file /usr/local/ddv/models/con2/include/ddverify/tasklet.h line 17
void call_tasklet_functions();
// c::call_timer_functions
// file /usr/local/ddv/models/con2/include/ddverify/timer.h line 16
void call_timer_functions();
// c::cdev_add
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 72
signed int cdev_add(struct cdev$link0 *p, unsigned int dev, unsigned int count);
// c::cdev_alloc
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 60
struct cdev$link0 * cdev_alloc(void);
// c::cdev_del
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 97
void cdev_del(struct cdev$link0 *p);
// c::cdev_init
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 67
void cdev_init(struct cdev$link0 *cdev, struct file_operations$link4 *fops);
// c::clear_bit
// file /usr/local/ddv/models/con2/include/asm/bitops.h line 10
void clear_bit(signed int, volatile unsigned long int *);
// c::copy_from_user
// file /usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c line 45
unsigned long int copy_from_user(void *to, void *from, unsigned long int n);
// c::copy_to_user
// file /usr/local/ddv/models/con2/include/asm/uaccess.h line 51
unsigned long int copy_to_user(void *to, const void *from, unsigned long int n);
// c::ddv
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 75
void ddv();
// c::ddv_2
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 31
static void * ddv_2(void *arg);
// c::del_gendisk
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 49
void del_gendisk(struct gendisk$link4 *gp);
// c::del_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 30
signed int del_timer(struct timer_list *timer);
// c::down
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 33
void down(struct semaphore *sem);
// c::down_interruptible
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 58
signed int down_interruptible(struct semaphore *sem);
// c::down_trylock
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 88
signed int down_trylock(struct semaphore *sem);
// c::end_request
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 56
void end_request(struct request$link19 *req, signed int uptodate);
// c::free_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c line 17
void free_irq(unsigned int irq, void *dev_id);
// c::get_fixed_request_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 7
struct request_queue$link14 * get_fixed_request_queue();
// c::get_user
// file /usr/local/ddv/models/con2/include/asm/uaccess.h line 43
signed int get_user(signed int size, void *ptr);
// c::get_zeroed_page
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 21
unsigned long int get_zeroed_page(unsigned int gfp_mask);
// c::inb
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 32
unsigned char inb(unsigned int port);
// c::inb_p
// file /usr/local/ddv/models/con2/include/asm/io.h line 23
unsigned char inb_p(unsigned int port);
// c::init_MUTEX
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 15
void init_MUTEX(struct semaphore *sem);
// c::init_MUTEX_LOCKED
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 24
void init_MUTEX_LOCKED(struct semaphore *sem);
// c::init_kernel
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 15
void init_kernel();
// c::init_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 4
void init_timer(struct timer_list *timer);
// c::init_waitqueue_head
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 3
void init_waitqueue_head(struct __wait_queue_head *q);
// c::inl
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 60
unsigned int inl(unsigned int port);
// c::inl_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 102
unsigned int inl_p(unsigned int port);
// c::interruptible_sleep_on
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 40
void interruptible_sleep_on(struct __wait_queue_head *q);
// c::inw
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 46
unsigned short int inw(unsigned int port);
// c::inw_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 88
unsigned short int inw_p(unsigned int port);
// c::kfree
// file /usr/local/ddv/models/con2/include/linux/slab.h line 8
void kfree(const void *);
// c::kmalloc
// file /usr/local/ddv/models/con2/src/linux/mm/slab.c line 6
void * kmalloc(unsigned int size, unsigned int flags);
// c::kzalloc
// file /usr/local/ddv/models/con2/src/linux/mm/slab.c line 15
void * kzalloc(unsigned int size, unsigned int flags);
// c::malloc
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 9
void * malloc(unsigned int);
// c::misc_deregister
// file /usr/local/ddv/models/con2/include/linux/miscdevice.h line 41
signed int misc_deregister(struct miscdevice *);
// c::misc_register
// file /usr/local/ddv/models/con2/include/linux/miscdevice.h line 40
signed int misc_register(struct miscdevice$link22 *misc);
// c::mod_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 35
signed int mod_timer(struct timer_list *timer, unsigned long int expires);
// c::mutex_init
// file /usr/local/ddv/models/con2/src/linux/kernel/mutex.c line 4
void mutex_init(struct mutex *lock);
// c::mutex_lock
// file /usr/local/ddv/models/con2/src/linux/kernel/mutex.c line 16
void mutex_lock(struct mutex *lock);
// c::mutex_unlock
// file /usr/local/ddv/models/con2/src/linux/kernel/mutex.c line 41
void mutex_unlock(struct mutex *lock);
// c::no_llseek
// file /usr/local/ddv/models/con2/include/linux/fs.h line 223
signed long long int no_llseek(struct file$link9 *, signed long long int, signed int);
// c::nondet_char
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 20
char nondet_char();
// c::nondet_int
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 16
signed int nondet_int();
// c::nondet_loff_t
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 23
signed long long int nondet_loff_t();
// c::nondet_long
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 18
signed long int nondet_long();
// c::nondet_pthread_t
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 57
struct __pthread_t_struct nondet_pthread_t();
// c::nondet_size_t
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 24
unsigned int nondet_size_t();
// c::nondet_uchar
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 21
unsigned char nondet_uchar();
// c::nondet_uint
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 17
unsigned int nondet_uint();
// c::nondet_ulong
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 19
unsigned long int nondet_ulong();
// c::nondet_unsigned
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 22
unsigned int nondet_unsigned();
// c::nondet_ushort
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 15
unsigned short int nondet_ushort();
// c::nonseekable_open
// file /usr/local/ddv/models/con2/include/linux/fs.h line 233
signed int nonseekable_open(struct inode$link4 *, struct file$link9 *);
// c::outb
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 40
void outb(unsigned char byte, unsigned int port);
// c::outb_p
// file /usr/local/ddv/models/con2/include/asm/io.h line 24
void outb_p(unsigned char byte, unsigned int port);
// c::outl
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 68
void outl(unsigned int doubleword, unsigned int port);
// c::outl_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 110
void outl_p(unsigned int doubleword, unsigned int port);
// c::outw
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 54
void outw(unsigned short int word, unsigned int port);
// c::outw_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 96
void outw_p(unsigned short int word, unsigned int port);
// c::panic
// file pcwd_pci.c line 327 function pcipcwd_get_status
signed int panic(void);
// c::pci_disable_device
// file /usr/local/ddv/models/con2/include/linux/pci.h line 147
void pci_disable_device(struct pci_dev$link13 *);
// c::pci_enable_device
// file /usr/local/ddv/models/con2/include/linux/pci.h line 145
signed int pci_enable_device(struct pci_dev$link1 *dev);
// c::pci_get_class
// file /usr/local/ddv/models/con2/src/linux/pci.c line 19
struct pci_dev$link1 * pci_get_class(unsigned int class, struct pci_dev$link1 *from);
// c::pci_register_driver
// file /usr/local/ddv/models/con2/include/linux/pci.h line 141
signed int pci_register_driver(struct pci_driver$link2 *driver);
// c::pci_release_region
// file /usr/local/ddv/models/con2/src/linux/pci.c line 56
void pci_release_region(struct pci_dev$link1 *pdev, signed int bar);
// c::pci_release_regions
// file /usr/local/ddv/models/con2/include/linux/pci.h line 154
void pci_release_regions(struct pci_dev$link1 *pdev);
// c::pci_request_region
// file /usr/local/ddv/models/con2/src/linux/pci.c line 68
signed int pci_request_region(struct pci_dev$link1 *pdev, signed int bar, const char *res_name);
// c::pci_request_regions
// file /usr/local/ddv/models/con2/include/linux/pci.h line 152
signed int pci_request_regions(struct pci_dev$link1 *pdev, const char *res_name);
// c::pci_unregister_driver
// file /usr/local/ddv/models/con2/include/linux/pci.h line 143
void pci_unregister_driver(struct pci_driver$link2 *driver);
// c::pcipcwd_card_exit
// file pcwd_pci.c line 761
static void pcipcwd_card_exit(struct pci_dev$link13 *pdev);
// c::pcipcwd_card_init
// file pcwd_pci.c line 664
signed int pcipcwd_card_init(struct pci_dev$link13 *pdev, const struct pci_device_id *ent);
// c::pcipcwd_check_temperature_support
// file pcwd_pci.c line 190
static void pcipcwd_check_temperature_support(void);
// c::pcipcwd_cleanup_module
// file pcwd_pci.c line 798
static void pcipcwd_cleanup_module(void);
// c::pcipcwd_clear_status
// file pcwd_pci.c line 337
static signed int pcipcwd_clear_status(void);
// c::pcipcwd_get_option_switches
// file pcwd_pci.c line 196
static signed int pcipcwd_get_option_switches(void);
// c::pcipcwd_get_status
// file pcwd_pci.c line 316
static signed int pcipcwd_get_status(signed int *status);
// c::pcipcwd_get_temperature
// file pcwd_pci.c line 370
static signed int pcipcwd_get_temperature(signed int *temperature);
// c::pcipcwd_get_timeleft
// file pcwd_pci.c line 392
static signed int pcipcwd_get_timeleft(signed int *time_left);
// c::pcipcwd_init_module
// file pcwd_pci.c line 791
static signed int pcipcwd_init_module(void);
// c::pcipcwd_ioctl
// file pcwd_pci.c line 442
static signed int pcipcwd_ioctl(struct inode$link4 *inode, struct file$link9 *file, unsigned int cmd, unsigned long int arg);
// c::pcipcwd_keepalive
// file pcwd_pci.c line 286
static signed int pcipcwd_keepalive(void);
// c::pcipcwd_notify_sys
// file pcwd_pci.c line 613
static signed int pcipcwd_notify_sys(struct notifier_block *this, unsigned long int code, void *unused);
// c::pcipcwd_open
// file pcwd_pci.c line 547
static signed int pcipcwd_open(struct inode$link4 *inode, struct file$link9 *file);
// c::pcipcwd_release
// file pcwd_pci.c line 562
static signed int pcipcwd_release(struct inode$link4 *inode, struct file$link9 *file);
// c::pcipcwd_set_heartbeat
// file pcwd_pci.c line 297
static signed int pcipcwd_set_heartbeat(signed int t);
// c::pcipcwd_show_card_info
// file pcwd_pci.c line 204
static void pcipcwd_show_card_info(void);
// c::pcipcwd_start
// file pcwd_pci.c line 239
static signed int pcipcwd_start(void);
// c::pcipcwd_stop
// file pcwd_pci.c line 261
static signed int pcipcwd_stop(void);
// c::pcipcwd_temp_open
// file pcwd_pci.c line 596
static signed int pcipcwd_temp_open(struct inode$link4 *inode, struct file$link9 *file);
// c::pcipcwd_temp_read
// file pcwd_pci.c line 582
static signed int pcipcwd_temp_read(struct file$link9 *file, char *data, unsigned int len, signed long long int *ppos);
// c::pcipcwd_temp_release
// file pcwd_pci.c line 604
static signed int pcipcwd_temp_release(struct inode$link4 *inode, struct file$link9 *file);
// c::pcipcwd_write
// file pcwd_pci.c line 414
static signed int pcipcwd_write(struct file$link9 *file, const char *data, unsigned int len, signed long long int *ppos);
// c::printk
// file /usr/local/ddv/models/con2/include/linux/kernel.h line 34
signed int printk(const char *, ...);
// c::pthread_create
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 59
signed int pthread_create(struct __pthread_t_struct *__threadp, const struct __pthread_attr_t_struct *__attr, void * (*__start_routine)(void *), void *__arg);
// c::pthread_create::__start_routine$link0$object
// 
void * __start_routine$link0$object(void *);
// c::pthread_create::__start_routine$link1$object
// 
void * __start_routine$link1$object(void *);
// c::pthread_create::__start_routine$link10$object
// 
void * __start_routine$link10$object(void *);
// c::pthread_create::__start_routine$link11$object
// 
void * __start_routine$link11$object(void *);
// c::pthread_create::__start_routine$link12$object
// 
void * __start_routine$link12$object(void *);
// c::pthread_create::__start_routine$link13$object
// 
void * __start_routine$link13$object(void *);
// c::pthread_create::__start_routine$link14$object
// 
void * __start_routine$link14$object(void *);
// c::pthread_create::__start_routine$link15$object
// 
void * __start_routine$link15$object(void *);
// c::pthread_create::__start_routine$link16$object
// 
void * __start_routine$link16$object(void *);
// c::pthread_create::__start_routine$link17$object
// 
void * __start_routine$link17$object(void *);
// c::pthread_create::__start_routine$link18$object
// 
void * __start_routine$link18$object(void *);
// c::pthread_create::__start_routine$link19$object
// 
void * __start_routine$link19$object(void *);
// c::pthread_create::__start_routine$link20$object
// 
void * __start_routine$link20$object(void *);
// c::pthread_create::__start_routine$link21$object
// 
void * __start_routine$link21$object(void *);
// c::pthread_create::__start_routine$link22$object
// 
void * __start_routine$link22$object(void *);
// c::pthread_create::__start_routine$link23$object
// 
void * __start_routine$link23$object(void *);
// c::pthread_create::__start_routine$link24$object
// 
void * __start_routine$link24$object(void *);
// c::pthread_create::__start_routine$link25$object
// 
void * __start_routine$link25$object(void *);
// c::pthread_create::__start_routine$link28$object
// 
void * __start_routine$link28$object(void *);
// c::pthread_create::__start_routine$link3$object
// 
void * __start_routine$link3$object(void *);
// c::pthread_create::__start_routine$link6$object
// 
void * __start_routine$link6$object(void *);
// c::pthread_create::__start_routine$link7$object
// 
void * __start_routine$link7$object(void *);
// c::pthread_create::__start_routine$link8$object
// 
void * __start_routine$link8$object(void *);
// c::pthread_create::__start_routine$link9$object
// 
void * __start_routine$link9$object(void *);
// c::pthread_create::__start_routine$object
// 
void * __start_routine$object(void *);
// c::pthread_mutex_destroy
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 194
signed int pthread_mutex_destroy(struct __pthread_mutex_t_struct *__mutex);
// c::pthread_mutex_init
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 186
signed int pthread_mutex_init(struct __pthread_mutex_t_struct *__mutex, const struct __pthread_mutexattr_t_struct *__mutex_attr);
// c::pthread_mutex_lock
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 203
signed int pthread_mutex_lock(struct __pthread_mutex_t_struct *__mutex);
// c::pthread_mutex_unlock
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 213
signed int pthread_mutex_unlock(struct __pthread_mutex_t_struct *__mutex);
// c::put_user
// file /usr/local/ddv/models/con2/include/asm/uaccess.h line 48
signed int put_user(signed int size, void *ptr);
// c::register_blkdev
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 6
signed int register_blkdev(unsigned int major, const char *name);
// c::register_chrdev
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 33
signed int register_chrdev(unsigned int major, const char *name, struct file_operations$link4 *fops);
// c::register_chrdev_region
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 23
signed int register_chrdev_region(unsigned int from, unsigned int count, const char *name);
// c::register_reboot_notifier
// file /usr/local/ddv/models/con2/include/linux/reboot.h line 40
signed int register_reboot_notifier(struct notifier_block *);
// c::release_mem_region
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 98
void release_mem_region(unsigned long int, unsigned long int);
// c::release_region
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 92
void release_region(unsigned long int start, unsigned long int len);
// c::request_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c line 4
signed int request_irq(unsigned int irq, signed int (*handler)(signed int, void *, struct pt_regs *), unsigned long int irqflags, const char *devname, void *dev_id);
// c::request_irq::handler$object
// 
signed int handler$object(signed int, void *, struct pt_regs *);
// c::request_mem_region
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 96
struct resource * request_mem_region(unsigned long int, unsigned long int, const char *);
// c::request_region
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 90
struct resource * request_region(unsigned long int start, unsigned long int len, const char *name);
// c::schedule
// file /usr/local/ddv/models/con2/src/linux/kernel/sched.c line 8
void schedule(void);
// c::schedule_timeout
// file /usr/local/ddv/models/con2/src/linux/kernel/sched.c line 13
signed long int schedule_timeout(signed long int timeout);
// c::schedule_work
// file /usr/local/ddv/models/con2/src/linux/kernel/workqueue.c line 5
signed int schedule_work(struct work_struct *work);
// c::sema_init
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 6
void sema_init(struct semaphore *sem, signed int val);
// c::send_command
// file pcwd_pci.c line 135
static signed int send_command(signed int cmd, signed int *msb, signed int *lsb);
// c::sleep_on
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 32
void sleep_on(struct __wait_queue_head *q);
// c::spin_lock
// file /usr/local/ddv/models/con2/include/linux/spinlock.h line 10
void spin_lock(struct anon$0 *lock);
// c::spin_lock_bh
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 82
void spin_lock_bh(struct anon$0 *lock);
// c::spin_lock_init
// file /usr/local/ddv/models/con2/include/linux/spinlock.h line 9
void spin_lock_init(struct anon$0 *lock);
// c::spin_lock_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 58
void spin_lock_irq(struct anon$0 *lock);
// c::spin_lock_irqsave
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 34
void spin_lock_irqsave(struct anon$0 *lock, unsigned long int flags);
// c::spin_unlock
// file /usr/local/ddv/models/con2/include/linux/spinlock.h line 15
void spin_unlock(struct anon$0 *lock);
// c::spin_unlock_bh
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 139
void spin_unlock_bh(struct anon$0 *lock);
// c::spin_unlock_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 128
void spin_unlock_irq(struct anon$0 *lock);
// c::spin_unlock_irqrestore
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 117
void spin_unlock_irqrestore(struct anon$0 *lock, unsigned long int flags);
// c::sprintf
// file /usr/local/ddv/models/con2/include/linux/kernel.h line 35
signed int sprintf(char *, const char *, ...);
// c::tasklet_init
// file /usr/local/ddv/models/con2/src/linux/kernel/softirq.c line 32
void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long int), unsigned long int data);
// c::tasklet_init::func$object
// 
void func$object(unsigned long int);
// c::tasklet_schedule
// file /usr/local/ddv/models/con2/src/linux/kernel/softirq.c line 4
void tasklet_schedule(struct tasklet_struct *t);
// c::test_and_set_bit
// file /usr/local/ddv/models/con2/include/asm/bitops.h line 6
signed int test_and_set_bit(signed int, unsigned long int *);
// c::tty_set_operations
// file /usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c line 14
void tty_set_operations(struct tty_driver *driver, const struct tty_operations *op);
// c::udelay
// file /usr/local/ddv/models/con2/include/asm/delay.h line 4
void udelay(signed int);
// c::unregister_blkdev
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 17
signed int unregister_blkdev(unsigned int major, const char *name);
// c::unregister_chrdev
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 55
signed int unregister_chrdev(unsigned int major, const char *name);
// c::unregister_reboot_notifier
// file /usr/local/ddv/models/con2/include/linux/reboot.h line 41
signed int unregister_reboot_notifier(struct notifier_block *);
// c::up
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 106
void up(struct semaphore *sem);
// c::vmalloc
// file /usr/local/ddv/models/con2/src/linux/mm/vmalloc.c line 6
void * vmalloc(unsigned long int size);
// c::wake_up
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 8
void wake_up(struct __wait_queue_head *q);
// c::wake_up_all
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 16
void wake_up_all(struct __wait_queue_head *q);
// c::wake_up_interruptible
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 24
void wake_up_interruptible(struct __wait_queue_head *q);

struct anon$0
{
  // init
  signed int init;
  // locked
  signed int locked;
};

struct anon$1
{
  // supports_temp
  signed int supports_temp;
  // boot_status
  signed int boot_status;
  // io_addr
  unsigned long int io_addr;
  // io_lock
  struct anon$0 io_lock;
  // pdev
  struct pci_dev$link13 *pdev;
};

struct anon$2
{
  // written
  unsigned int written;
  // count
  unsigned int count;
};

struct __pthread_attr_t_struct
{
  // dummy
  signed int dummy;
};

struct __pthread_mutex_t_struct
{
  // locked
  _Bool locked;
};

struct __pthread_mutexattr_t_struct
{
  // dummy
  signed int dummy;
};

struct __pthread_t_struct
{
  // id
  signed int id;
};

struct __wait_queue_head
{
  // number_process_waiting
  signed int number_process_waiting;
  // wakeup
  signed int wakeup;
  // init
  signed int init;
};

struct address_space
{
  // host
  struct inode *host;
};

struct address_space$link10
{
  // host
  struct inode$link8 *host;
};

struct address_space$link23
{
  // host
  struct inode$link21 *host;
};

struct address_space$link3
{
  // host
  struct inode$link1 *host;
};

struct address_space$link4
{
  // host
  struct inode$link2 *host;
};

struct address_space$link5
{
  // host
  struct inode$link3 *host;
};

struct address_space$link7
{
  // host
  struct inode$link4 *host;
};

struct address_space$link9
{
  // host
  struct inode$link6 *host;
};

struct backing_dev_info
{
  // ra_pages
  unsigned long int ra_pages;
  // state
  unsigned long int state;
  // capabilities
  unsigned int capabilities;
};

struct bio
{
  // bi_sector
  unsigned long int bi_sector;
  // bi_next
  struct bio *bi_next;
  // bi_bdev
  struct block_device$link10 *bi_bdev;
  // bi_flags
  unsigned long int bi_flags;
  // bi_rw
  unsigned long int bi_rw;
  // bi_vcnt
  unsigned short int bi_vcnt;
  // bi_idx
  unsigned short int bi_idx;
  // bi_phys_segments
  unsigned short int bi_phys_segments;
  // bi_size
  unsigned int bi_size;
  // bi_io_vec
  struct bio_vec *bi_io_vec;
  // bi_end_io
  signed int (*bi_end_io)(struct bio *, unsigned int, signed int);
  // bi_private
  void *bi_private;
};

struct bio$link15
{
  // bi_sector
  unsigned long int bi_sector;
  // bi_next
  struct bio$link15 *bi_next;
  // bi_bdev
  struct block_device$link1 *bi_bdev;
  // bi_flags
  unsigned long int bi_flags;
  // bi_rw
  unsigned long int bi_rw;
  // bi_vcnt
  unsigned short int bi_vcnt;
  // bi_idx
  unsigned short int bi_idx;
  // bi_phys_segments
  unsigned short int bi_phys_segments;
  // bi_size
  unsigned int bi_size;
  // bi_io_vec
  struct bio_vec *bi_io_vec;
  // bi_end_io
  signed int (*bi_end_io)(struct bio$link15 *, unsigned int, signed int);
  // bi_private
  void *bi_private;
};

struct bio$link8
{
  // bi_sector
  unsigned long int bi_sector;
  // bi_next
  struct bio$link8 *bi_next;
  // bi_bdev
  struct block_device$link5 *bi_bdev;
  // bi_flags
  unsigned long int bi_flags;
  // bi_rw
  unsigned long int bi_rw;
  // bi_vcnt
  unsigned short int bi_vcnt;
  // bi_idx
  unsigned short int bi_idx;
  // bi_phys_segments
  unsigned short int bi_phys_segments;
  // bi_size
  unsigned int bi_size;
  // bi_io_vec
  struct bio_vec *bi_io_vec;
  // bi_end_io
  signed int (*bi_end_io)(struct bio$link8 *, unsigned int, signed int);
  // bi_private
  void *bi_private;
};

struct bio_vec
{
  // bv_page
  struct page *bv_page;
  // bv_len
  unsigned int bv_len;
  // bv_offset
  unsigned int bv_offset;
};

struct block_device
{
  // bd_inode
  struct inode *bd_inode;
  // bd_disk
  struct gendisk *bd_disk;
  // bd_contains
  struct block_device *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link0
{
  // bd_inode
  struct inode$link4 *bd_inode;
  // bd_disk
  struct gendisk *bd_disk;
  // bd_contains
  struct block_device$link0 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link1
{
  // bd_inode
  struct inode$link3 *bd_inode;
  // bd_disk
  struct gendisk$link0 *bd_disk;
  // bd_contains
  struct block_device$link1 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link10
{
  // bd_inode
  struct inode$link2 *bd_inode;
  // bd_disk
  struct gendisk *bd_disk;
  // bd_contains
  struct block_device$link10 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link2
{
  // bd_inode
  struct inode$link1 *bd_inode;
  // bd_disk
  struct gendisk *bd_disk;
  // bd_contains
  struct block_device$link2 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link22
{
  // bd_inode
  struct inode$link21 *bd_inode;
  // bd_disk
  struct gendisk *bd_disk;
  // bd_contains
  struct block_device$link22 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link5
{
  // bd_inode
  struct inode$link6 *bd_inode;
  // bd_disk
  struct gendisk$link4 *bd_disk;
  // bd_contains
  struct block_device$link5 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link9
{
  // bd_inode
  struct inode$link8 *bd_inode;
  // bd_disk
  struct gendisk *bd_disk;
  // bd_contains
  struct block_device$link9 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device_operations
{
  // open
  signed int (*open)(struct inode$link2 *, struct file$link8 *);
  // release
  signed int (*release)(struct inode$link2 *, struct file$link8 *);
  // ioctl
  signed int (*ioctl)(struct inode$link2 *, struct file$link8 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link8 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link8 *, unsigned int, unsigned long int);
  // direct_access
  signed int (*direct_access)(struct block_device$link10 *, unsigned long int, unsigned long int *);
  // media_changed
  signed int (*media_changed)(struct gendisk *);
  // revalidate_disk
  signed int (*revalidate_disk)(struct gendisk *);
  // getgeo
  signed int (*getgeo)(struct block_device$link10 *, struct hd_geometry *);
  // owner
  struct module *owner;
};

struct block_device_operations$link1
{
  // open
  signed int (*open)(struct inode$link6 *, struct file$link10 *);
  // release
  signed int (*release)(struct inode$link6 *, struct file$link10 *);
  // ioctl
  signed int (*ioctl)(struct inode$link6 *, struct file$link10 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link10 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link10 *, unsigned int, unsigned long int);
  // direct_access
  signed int (*direct_access)(struct block_device$link5 *, unsigned long int, unsigned long int *);
  // media_changed
  signed int (*media_changed)(struct gendisk$link4 *);
  // revalidate_disk
  signed int (*revalidate_disk)(struct gendisk$link4 *);
  // getgeo
  signed int (*getgeo)(struct block_device$link5 *, struct hd_geometry *);
  // owner
  struct module *owner;
};

struct block_device_operations$link12
{
  // open
  signed int (*open)(struct inode$link3 *, struct file$link7 *);
  // release
  signed int (*release)(struct inode$link3 *, struct file$link7 *);
  // ioctl
  signed int (*ioctl)(struct inode$link3 *, struct file$link7 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link7 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link7 *, unsigned int, unsigned long int);
  // direct_access
  signed int (*direct_access)(struct block_device$link1 *, unsigned long int, unsigned long int *);
  // media_changed
  signed int (*media_changed)(struct gendisk$link0 *);
  // revalidate_disk
  signed int (*revalidate_disk)(struct gendisk$link0 *);
  // getgeo
  signed int (*getgeo)(struct block_device$link1 *, struct hd_geometry *);
  // owner
  struct module *owner;
};

struct cdev
{
  // owner
  struct module *owner;
  // ops
  struct file_operations *ops;
  // dev
  unsigned int dev;
  // count
  unsigned int count;
};

struct cdev$link0
{
  // owner
  struct module *owner;
  // ops
  struct file_operations$link4 *ops;
  // dev
  unsigned int dev;
  // count
  unsigned int count;
};

struct cdev$link1
{
  // owner
  struct module *owner;
  // ops
  struct file_operations$link5 *ops;
  // dev
  unsigned int dev;
  // count
  unsigned int count;
};

struct cdev$link20
{
  // owner
  struct module *owner;
  // ops
  struct file_operations$link19 *ops;
  // dev
  unsigned int dev;
  // count
  unsigned int count;
};

struct cdev$link7
{
  // owner
  struct module *owner;
  // ops
  struct file_operations$link6 *ops;
  // dev
  unsigned int dev;
  // count
  unsigned int count;
};

struct file
{
  // f_dentry
  struct dentry *f_dentry;
  // f_op
  struct file_operations *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space *f_mapping;
};

struct inode
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev *i_cdev;
};

struct ddv_cdev
{
  // cdevp
  struct cdev *cdevp;
  // filp
  struct file filp;
  // inode
  struct inode inode;
  // open
  signed int open;
};

struct file$link8
{
  // f_dentry
  struct dentry$link7 *f_dentry;
  // f_op
  struct file_operations$link5 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link4 *f_mapping;
};

struct inode$link2
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link10 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev$link1 *i_cdev;
};

struct ddv_cdev$link14
{
  // cdevp
  struct cdev$link1 *cdevp;
  // filp
  struct file$link8 filp;
  // inode
  struct inode$link2 inode;
  // open
  signed int open;
};

struct file$link15
{
  // f_dentry
  struct dentry$link14 *f_dentry;
  // f_op
  struct file_operations$link6 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link10 *f_mapping;
};

struct inode$link8
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link9 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev$link7 *i_cdev;
};

struct ddv_cdev$link21
{
  // cdevp
  struct cdev$link7 *cdevp;
  // filp
  struct file$link15 filp;
  // inode
  struct inode$link8 inode;
  // open
  signed int open;
};

struct file$link6
{
  // f_dentry
  struct dentry$link5 *f_dentry;
  // f_op
  struct file_operations$link4 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link3 *f_mapping;
};

struct inode$link1
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link2 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev$link0 *i_cdev;
};

struct ddv_cdev$link7
{
  // cdevp
  struct cdev$link0 *cdevp;
  // filp
  struct file$link6 filp;
  // inode
  struct inode$link1 inode;
  // open
  signed int open;
};

struct list_head
{
  // next
  struct list_head *next;
  // prev
  struct list_head *prev;
};

struct request
{
  // queuelist
  struct list_head queuelist;
  // donelist
  struct list_head donelist;
  // q
  struct request_queue *q;
  // flags
  unsigned long int flags;
  // cmd_flags
  unsigned int cmd_flags;
  // cmd_type
  int cmd_type;
  // bio
  struct bio *bio;
  // completion_data
  void *completion_data;
  // rq_disk
  struct gendisk *rq_disk;
  // sector
  unsigned long int sector;
  // nr_sectors
  unsigned long int nr_sectors;
  // current_nr_sectors
  unsigned int current_nr_sectors;
  // buffer
  char *buffer;
  // errors
  signed int errors;
  // nr_phys_segments
  unsigned short int nr_phys_segments;
  // cmd
  unsigned char cmd[16l];
};

struct ddv_genhd
{
  // gd
  struct gendisk *gd;
  // inode
  struct inode$link2 inode;
  // file
  struct file$link8 file;
  // current_request
  struct request current_request;
  // requests_open
  signed int requests_open;
};

struct inode$link6
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link5 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev *i_cdev;
};

struct file$link10
{
  // f_dentry
  struct dentry$link11 *f_dentry;
  // f_op
  struct file_operations$link12 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link9 *f_mapping;
};

struct list_head$link16
{
  // next
  struct list_head$link16 *next;
  // prev
  struct list_head$link16 *prev;
};

struct request$link17
{
  // queuelist
  struct list_head$link16 queuelist;
  // donelist
  struct list_head$link16 donelist;
  // q
  struct request_queue$link3 *q;
  // flags
  unsigned long int flags;
  // cmd_flags
  unsigned int cmd_flags;
  // cmd_type
  int cmd_type;
  // bio
  struct bio$link8 *bio;
  // completion_data
  void *completion_data;
  // rq_disk
  struct gendisk$link4 *rq_disk;
  // sector
  unsigned long int sector;
  // nr_sectors
  unsigned long int nr_sectors;
  // current_nr_sectors
  unsigned int current_nr_sectors;
  // buffer
  char *buffer;
  // errors
  signed int errors;
  // nr_phys_segments
  unsigned short int nr_phys_segments;
  // cmd
  unsigned char cmd[16l];
};

struct ddv_genhd$link18
{
  // gd
  struct gendisk$link4 *gd;
  // inode
  struct inode$link6 inode;
  // file
  struct file$link10 file;
  // current_request
  struct request$link17 current_request;
  // requests_open
  signed int requests_open;
};

struct inode$link3
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link1 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev *i_cdev;
};

struct file$link7
{
  // f_dentry
  struct dentry$link8 *f_dentry;
  // f_op
  struct file_operations$link9 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link5 *f_mapping;
};

struct list_head$link18
{
  // next
  struct list_head$link18 *next;
  // prev
  struct list_head$link18 *prev;
};

struct request$link19
{
  // queuelist
  struct list_head$link18 queuelist;
  // donelist
  struct list_head$link18 donelist;
  // q
  struct request_queue$link14 *q;
  // flags
  unsigned long int flags;
  // cmd_flags
  unsigned int cmd_flags;
  // cmd_type
  int cmd_type;
  // bio
  struct bio$link15 *bio;
  // completion_data
  void *completion_data;
  // rq_disk
  struct gendisk$link0 *rq_disk;
  // sector
  unsigned long int sector;
  // nr_sectors
  unsigned long int nr_sectors;
  // current_nr_sectors
  unsigned int current_nr_sectors;
  // buffer
  char *buffer;
  // errors
  signed int errors;
  // nr_phys_segments
  unsigned short int nr_phys_segments;
  // cmd
  unsigned char cmd[16l];
};

struct ddv_genhd$link20
{
  // gd
  struct gendisk$link0 *gd;
  // inode
  struct inode$link3 inode;
  // file
  struct file$link7 file;
  // current_request
  struct request$link19 current_request;
  // requests_open
  signed int requests_open;
};

struct device
{
  // driver_data
  void *driver_data;
  // release
  void (*release)(struct device *dev);
};

struct resource
{
  // name
  const char *name;
  // start
  unsigned long int start;
  // end
  unsigned long int end;
  // flags
  unsigned long int flags;
};

struct pci_dev
{
  // bus
  struct pci_bus *bus;
  // devfn
  unsigned int devfn;
  // vendor
  unsigned short int vendor;
  // device
  unsigned short int device;
  // dma_mask
  unsigned long long int dma_mask;
  // dev
  struct device dev;
  // irq
  unsigned int irq;
  // resource
  struct resource resource[12l];
};

struct ddv_pci_driver
{
  // pci_driver
  struct pci_driver *pci_driver;
  // pci_dev
  struct pci_dev pci_dev;
  // no_pci_device_id
  unsigned int no_pci_device_id;
  // dev_initialized
  signed int dev_initialized;
};

struct device$link0
{
  // driver_data
  void *driver_data;
  // release
  void (*release)(struct device$link0 *dev);
};

struct pci_dev$link1
{
  // bus
  struct pci_bus *bus;
  // devfn
  unsigned int devfn;
  // vendor
  unsigned short int vendor;
  // device
  unsigned short int device;
  // dma_mask
  unsigned long long int dma_mask;
  // dev
  struct device$link0 dev;
  // irq
  unsigned int irq;
  // resource
  struct resource resource[12l];
};

struct ddv_pci_driver$link3
{
  // pci_driver
  struct pci_driver$link2 *pci_driver;
  // pci_dev
  struct pci_dev$link1 pci_dev;
  // no_pci_device_id
  unsigned int no_pci_device_id;
  // dev_initialized
  signed int dev_initialized;
};

struct ddv_tasklet
{
  // tasklet
  struct tasklet_struct *tasklet;
  // is_running
  unsigned short int is_running;
};

struct ddv_timer
{
  // timer
  struct timer_list *timer;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[19l];
};

struct tty_driver
{
  // magic
  signed int magic;
  // cdev
  struct cdev$link20 cdev;
  // owner
  struct module *owner;
  // driver_name
  const char *driver_name;
  // name
  const char *name;
  // name_base
  signed int name_base;
  // major
  signed int major;
  // minor_start
  signed int minor_start;
  // minor_num
  signed int minor_num;
  // num
  signed int num;
  // type
  signed short int type;
  // subtype
  signed short int subtype;
  // init_termios
  struct termios init_termios;
  // flags
  signed int flags;
  // refcount
  signed int refcount;
  // proc_entry
  struct proc_dir_entry *proc_entry;
  // open
  signed int (*open)(struct tty_struct *tty, struct file$link26 *filp);
  // close
  void (*close)(struct tty_struct *tty, struct file$link26 *filp);
  // write
  signed int (*write)(struct tty_struct *tty, const unsigned char *buf, signed int count);
  // put_char
  void (*put_char)(struct tty_struct *tty, unsigned char ch);
  // flush_chars
  void (*flush_chars)(struct tty_struct *tty);
  // write_room
  signed int (*write_room)(struct tty_struct *tty);
  // chars_in_buffer
  signed int (*chars_in_buffer)(struct tty_struct *tty);
  // ioctl
  signed int (*ioctl)(struct tty_struct *tty, struct file$link26 *file, unsigned int cmd, unsigned long int arg);
  // set_termios
  void (*set_termios)(struct tty_struct *tty, struct termios *old);
  // throttle
  void (*throttle)(struct tty_struct *tty);
  // unthrottle
  void (*unthrottle)(struct tty_struct *tty);
  // stop
  void (*stop)(struct tty_struct *tty);
  // start
  void (*start)(struct tty_struct *tty);
  // hangup
  void (*hangup)(struct tty_struct *tty);
  // break_ctl
  void (*break_ctl)(struct tty_struct *tty, signed int state);
  // flush_buffer
  void (*flush_buffer)(struct tty_struct *tty);
  // set_ldisc
  void (*set_ldisc)(struct tty_struct *tty);
  // wait_until_sent
  void (*wait_until_sent)(struct tty_struct *tty, signed int timeout);
  // send_xchar
  void (*send_xchar)(struct tty_struct *tty, char ch);
  // read_proc
  signed int (*read_proc)(char *page, char **start, signed long int off, signed int count, signed int *eof, void *data);
  // write_proc
  signed int (*write_proc)(struct file$link26 *file, const char *buffer, unsigned long int count, void *data);
  // tiocmget
  signed int (*tiocmget)(struct tty_struct *tty, struct file$link26 *file);
  // tiocmset
  signed int (*tiocmset)(struct tty_struct *tty, struct file$link26 *file, unsigned int set, unsigned int clear);
};

struct ddv_tty_driver
{
  // driver
  struct tty_driver driver;
  // allocated
  unsigned short int allocated;
  // registered
  unsigned short int registered;
};

struct dentry
{
  // d_inode
  struct inode *d_inode;
};

struct dentry$link10
{
  // d_inode
  struct inode$link4 *d_inode;
};

struct dentry$link11
{
  // d_inode
  struct inode$link6 *d_inode;
};

struct dentry$link14
{
  // d_inode
  struct inode$link8 *d_inode;
};

struct dentry$link25
{
  // d_inode
  struct inode$link21 *d_inode;
};

struct dentry$link5
{
  // d_inode
  struct inode$link1 *d_inode;
};

struct dentry$link7
{
  // d_inode
  struct inode$link2 *d_inode;
};

struct dentry$link8
{
  // d_inode
  struct inode$link3 *d_inode;
};

struct device$link12
{
  // driver_data
  void *driver_data;
  // release
  void (*release)(struct device$link12 *dev);
};

struct device$link13
{
  // driver_data
  void *driver_data;
  // release
  void (*release)(struct device$link13 *dev);
};

struct device$link2
{
  // driver_data
  void *driver_data;
  // release
  void (*release)(struct device$link2 *dev);
};

struct file$link26
{
  // f_dentry
  struct dentry$link25 *f_dentry;
  // f_op
  struct file_operations$link19 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link23 *f_mapping;
};

struct file$link9
{
  // f_dentry
  struct dentry$link10 *f_dentry;
  // f_op
  struct file_operations$link11 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link7 *f_mapping;
};

struct file_lock
{
  // something
  signed int something;
};

struct file_operations
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file *, signed long long int, signed int);
  // read
  signed int (*read)(struct file *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode *, struct file *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode *, struct file *);
  // flush
  signed int (*flush)(struct file *);
  // release
  signed int (*release)(struct inode *, struct file *);
  // fsync
  signed int (*fsync)(struct file *, struct dentry *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file *, signed int);
  // lock
  signed int (*lock)(struct file *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file *, signed long long int *, unsigned int, signed int (*)(struct anon$2 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode *);
};

struct file_operations$link11
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link9 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link9 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link9 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link9 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link9 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link4 *, struct file$link9 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link9 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link9 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link9 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link4 *, struct file$link9 *);
  // flush
  signed int (*flush)(struct file$link9 *);
  // release
  signed int (*release)(struct inode$link4 *, struct file$link9 *);
  // fsync
  signed int (*fsync)(struct file$link9 *, struct dentry$link10 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link9 *, signed int);
  // lock
  signed int (*lock)(struct file$link9 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link9 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link9 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link9 *, signed long long int *, unsigned int, signed int (*)(struct anon$2 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link9 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link9 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link9 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link9 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link4 *);
};

struct file_operations$link12
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link10 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link10 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link10 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link10 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link10 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link6 *, struct file$link10 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link10 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link10 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link10 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link6 *, struct file$link10 *);
  // flush
  signed int (*flush)(struct file$link10 *);
  // release
  signed int (*release)(struct inode$link6 *, struct file$link10 *);
  // fsync
  signed int (*fsync)(struct file$link10 *, struct dentry$link11 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link10 *, signed int);
  // lock
  signed int (*lock)(struct file$link10 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link10 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link10 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link10 *, signed long long int *, unsigned int, signed int (*)(struct anon$2 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link10 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link10 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link10 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link10 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link6 *);
};

struct file_operations$link19
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link26 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link26 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link26 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link26 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link26 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link21 *, struct file$link26 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link26 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link26 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link26 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link21 *, struct file$link26 *);
  // flush
  signed int (*flush)(struct file$link26 *);
  // release
  signed int (*release)(struct inode$link21 *, struct file$link26 *);
  // fsync
  signed int (*fsync)(struct file$link26 *, struct dentry$link25 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link26 *, signed int);
  // lock
  signed int (*lock)(struct file$link26 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link26 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link26 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link26 *, signed long long int *, unsigned int, signed int (*)(struct anon$2 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link26 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link26 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link26 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link26 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link21 *);
};

struct file_operations$link4
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link6 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link6 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link6 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link6 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link6 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link1 *, struct file$link6 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link6 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link6 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link6 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link1 *, struct file$link6 *);
  // flush
  signed int (*flush)(struct file$link6 *);
  // release
  signed int (*release)(struct inode$link1 *, struct file$link6 *);
  // fsync
  signed int (*fsync)(struct file$link6 *, struct dentry$link5 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link6 *, signed int);
  // lock
  signed int (*lock)(struct file$link6 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link6 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link6 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link6 *, signed long long int *, unsigned int, signed int (*)(struct anon$2 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link6 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link6 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link6 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link6 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link1 *);
};

struct file_operations$link5
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link8 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link8 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link8 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link8 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link8 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link2 *, struct file$link8 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link8 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link8 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link8 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link2 *, struct file$link8 *);
  // flush
  signed int (*flush)(struct file$link8 *);
  // release
  signed int (*release)(struct inode$link2 *, struct file$link8 *);
  // fsync
  signed int (*fsync)(struct file$link8 *, struct dentry$link7 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link8 *, signed int);
  // lock
  signed int (*lock)(struct file$link8 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link8 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link8 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link8 *, signed long long int *, unsigned int, signed int (*)(struct anon$2 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link8 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link8 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link8 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link8 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link2 *);
};

struct file_operations$link6
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link15 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link15 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link15 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link15 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link15 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link8 *, struct file$link15 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link15 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link15 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link15 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link8 *, struct file$link15 *);
  // flush
  signed int (*flush)(struct file$link15 *);
  // release
  signed int (*release)(struct inode$link8 *, struct file$link15 *);
  // fsync
  signed int (*fsync)(struct file$link15 *, struct dentry$link14 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link15 *, signed int);
  // lock
  signed int (*lock)(struct file$link15 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link15 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link15 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link15 *, signed long long int *, unsigned int, signed int (*)(struct anon$2 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link15 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link15 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link15 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link15 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link8 *);
};

struct file_operations$link9
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link7 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link7 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link7 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link7 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link7 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link3 *, struct file$link7 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link7 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link7 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link7 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link3 *, struct file$link7 *);
  // flush
  signed int (*flush)(struct file$link7 *);
  // release
  signed int (*release)(struct inode$link3 *, struct file$link7 *);
  // fsync
  signed int (*fsync)(struct file$link7 *, struct dentry$link8 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link7 *, signed int);
  // lock
  signed int (*lock)(struct file$link7 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link7 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link7 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link7 *, signed long long int *, unsigned int, signed int (*)(struct anon$2 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link7 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link7 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link7 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link7 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link3 *);
};

struct gendisk
{
  // major
  signed int major;
  // first_minor
  signed int first_minor;
  // minors
  signed int minors;
  // disk_name
  char disk_name[32l];
  // fops
  struct block_device_operations *fops;
  // queue
  struct request_queue *queue;
  // private_data
  void *private_data;
  // flags
  signed int flags;
  // driverfs_dev
  struct device *driverfs_dev;
  // devfs_name
  char devfs_name[64l];
};

struct gendisk$link0
{
  // major
  signed int major;
  // first_minor
  signed int first_minor;
  // minors
  signed int minors;
  // disk_name
  char disk_name[32l];
  // fops
  struct block_device_operations$link12 *fops;
  // queue
  struct request_queue$link14 *queue;
  // private_data
  void *private_data;
  // flags
  signed int flags;
  // driverfs_dev
  struct device$link13 *driverfs_dev;
  // devfs_name
  char devfs_name[64l];
};

struct gendisk$link4
{
  // major
  signed int major;
  // first_minor
  signed int first_minor;
  // minors
  signed int minors;
  // disk_name
  char disk_name[32l];
  // fops
  struct block_device_operations$link1 *fops;
  // queue
  struct request_queue$link3 *queue;
  // private_data
  void *private_data;
  // flags
  signed int flags;
  // driverfs_dev
  struct device$link2 *driverfs_dev;
  // devfs_name
  char devfs_name[64l];
};

struct inode$link21
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link22 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev$link20 *i_cdev;
};

struct inode$link4
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link0 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev *i_cdev;
};

struct miscdevice
{
  // minor
  signed int minor;
  // name
  const char *name;
  // fops
  struct file_operations$link11 *fops;
};

struct miscdevice$link22
{
  // minor
  signed int minor;
  // name
  const char *name;
  // fops
  struct file_operations$link6 *fops;
};

struct module
{
  // something
  signed int something;
};

struct mutex
{
  // locked
  signed int locked;
  // init
  signed int init;
};

struct notifier_block
{
  // notifier_call
  signed int (*notifier_call)(struct notifier_block *self, unsigned long int, void *);
  // next
  struct notifier_block *next;
  // priority
  signed int priority;
};

struct page
{
  // something
  signed int something;
};

struct pci_bus
{
  // number
  unsigned char number;
};

struct pci_dev$link13
{
  // bus
  struct pci_bus *bus;
  // devfn
  unsigned int devfn;
  // vendor
  unsigned short int vendor;
  // device
  unsigned short int device;
  // dma_mask
  unsigned long long int dma_mask;
  // dev
  struct device$link12 dev;
  // irq
  unsigned int irq;
  // resource
  struct resource resource[12l];
};

struct pci_device_id
{
  // vendor
  unsigned int vendor;
  // device
  unsigned int device;
  // subvendor
  unsigned int subvendor;
  // subdevice
  unsigned int subdevice;
  // class
  unsigned int class;
  // class_mask
  unsigned int class_mask;
  // driver_data
  unsigned long int driver_data;
};

struct pci_driver
{
  // name
  char *name;
  // id_table
  const struct pci_device_id *id_table;
  // probe
  signed int (*probe)(struct pci_dev *dev, const struct pci_device_id *id);
  // remove
  void (*remove)(struct pci_dev *dev);
  // suspend
  signed int (*suspend)(struct pci_dev *dev, struct pm_message state);
  // resume
  signed int (*resume)(struct pci_dev *dev);
  // enable_wake
  signed int (*enable_wake)(struct pci_dev *dev, signed int state, signed int enable);
  // shutdown
  void (*shutdown)(struct pci_dev *dev);
};

struct pci_driver$link14
{
  // name
  char *name;
  // id_table
  const struct pci_device_id *id_table;
  // probe
  signed int (*probe)(struct pci_dev$link13 *dev, const struct pci_device_id *id);
  // remove
  void (*remove)(struct pci_dev$link13 *dev);
  // suspend
  signed int (*suspend)(struct pci_dev$link13 *dev, struct pm_message state);
  // resume
  signed int (*resume)(struct pci_dev$link13 *dev);
  // enable_wake
  signed int (*enable_wake)(struct pci_dev$link13 *dev, signed int state, signed int enable);
  // shutdown
  void (*shutdown)(struct pci_dev$link13 *dev);
};

struct pci_driver$link2
{
  // name
  char *name;
  // id_table
  const struct pci_device_id *id_table;
  // probe
  signed int (*probe)(struct pci_dev$link1 *dev, const struct pci_device_id *id);
  // remove
  void (*remove)(struct pci_dev$link1 *dev);
  // suspend
  signed int (*suspend)(struct pci_dev$link1 *dev, struct pm_message state);
  // resume
  signed int (*resume)(struct pci_dev$link1 *dev);
  // enable_wake
  signed int (*enable_wake)(struct pci_dev$link1 *dev, signed int state, signed int enable);
  // shutdown
  void (*shutdown)(struct pci_dev$link1 *dev);
};

struct pm_message
{
  // event
  signed int event;
};

struct proc_dir_entry
{
  // something
  signed int something;
};

struct pt_regs
{
  // something
  signed int something;
};

struct registered_irq
{
  // handler
  signed int (*handler)(signed int, void *, struct pt_regs *);
  // dev_id
  void *dev_id;
};

struct request_queue
{
  // request_fn
  void (*request_fn)(struct request_queue *);
  // make_request_fn
  signed int (*make_request_fn)(struct request_queue *, struct bio *);
  // unplug_fn
  void (*unplug_fn)(struct request_queue *);
  // backing_dev_info
  struct backing_dev_info backing_dev_info;
  // queuedata
  void *queuedata;
  // queue_flags
  unsigned long int queue_flags;
  // queue_lock
  struct anon$0 *queue_lock;
  // hardsect_size
  unsigned short int hardsect_size;
  // __ddv_genhd_no
  signed int __ddv_genhd_no;
  // __ddv_queue_alive
  signed int __ddv_queue_alive;
};

struct request_queue$link14
{
  // request_fn
  void (*request_fn)(struct request_queue$link14 *);
  // make_request_fn
  signed int (*make_request_fn)(struct request_queue$link14 *, struct bio$link15 *);
  // unplug_fn
  void (*unplug_fn)(struct request_queue$link14 *);
  // backing_dev_info
  struct backing_dev_info backing_dev_info;
  // queuedata
  void *queuedata;
  // queue_flags
  unsigned long int queue_flags;
  // queue_lock
  struct anon$0 *queue_lock;
  // hardsect_size
  unsigned short int hardsect_size;
  // __ddv_genhd_no
  signed int __ddv_genhd_no;
  // __ddv_queue_alive
  signed int __ddv_queue_alive;
};

struct request_queue$link3
{
  // request_fn
  void (*request_fn)(struct request_queue$link3 *);
  // make_request_fn
  signed int (*make_request_fn)(struct request_queue$link3 *, struct bio$link8 *);
  // unplug_fn
  void (*unplug_fn)(struct request_queue$link3 *);
  // backing_dev_info
  struct backing_dev_info backing_dev_info;
  // queuedata
  void *queuedata;
  // queue_flags
  unsigned long int queue_flags;
  // queue_lock
  struct anon$0 *queue_lock;
  // hardsect_size
  unsigned short int hardsect_size;
  // __ddv_genhd_no
  signed int __ddv_genhd_no;
  // __ddv_queue_alive
  signed int __ddv_queue_alive;
};

struct semaphore
{
  // init
  signed int init;
  // locked
  signed int locked;
};

struct tasklet_struct
{
  // count
  signed int count;
  // func
  void (*func)(unsigned long int);
  // data
  unsigned long int data;
  // init
  signed int init;
};

struct timer_list
{
  // expires
  unsigned long int expires;
  // function
  void (*function)(unsigned long int);
  // data
  unsigned long int data;
  // __ddv_active
  signed short int __ddv_active;
  // __ddv_init
  signed short int __ddv_init;
};

struct tty_operations
{
  // open
  signed int (*open)(struct tty_struct *tty, struct file$link26 *filp);
  // close
  void (*close)(struct tty_struct *tty, struct file$link26 *filp);
  // write
  signed int (*write)(struct tty_struct *tty, const unsigned char *buf, signed int count);
  // put_char
  void (*put_char)(struct tty_struct *tty, unsigned char ch);
  // flush_chars
  void (*flush_chars)(struct tty_struct *tty);
  // write_room
  signed int (*write_room)(struct tty_struct *tty);
  // chars_in_buffer
  signed int (*chars_in_buffer)(struct tty_struct *tty);
  // ioctl
  signed int (*ioctl)(struct tty_struct *tty, struct file$link26 *file, unsigned int cmd, unsigned long int arg);
  // set_termios
  void (*set_termios)(struct tty_struct *tty, struct termios *old);
  // throttle
  void (*throttle)(struct tty_struct *tty);
  // unthrottle
  void (*unthrottle)(struct tty_struct *tty);
  // stop
  void (*stop)(struct tty_struct *tty);
  // start
  void (*start)(struct tty_struct *tty);
  // hangup
  void (*hangup)(struct tty_struct *tty);
  // break_ctl
  void (*break_ctl)(struct tty_struct *tty, signed int state);
  // flush_buffer
  void (*flush_buffer)(struct tty_struct *tty);
  // set_ldisc
  void (*set_ldisc)(struct tty_struct *tty);
  // wait_until_sent
  void (*wait_until_sent)(struct tty_struct *tty, signed int timeout);
  // send_xchar
  void (*send_xchar)(struct tty_struct *tty, char ch);
  // read_proc
  signed int (*read_proc)(char *page, char **start, signed long int off, signed int count, signed int *eof, void *data);
  // write_proc
  signed int (*write_proc)(struct file$link26 *file, const char *buffer, unsigned long int count, void *data);
  // tiocmget
  signed int (*tiocmget)(struct tty_struct *tty, struct file$link26 *file);
  // tiocmset
  signed int (*tiocmset)(struct tty_struct *tty, struct file$link26 *file, unsigned int set, unsigned int clear);
};

struct tty_struct
{
  // magic
  signed int magic;
  // driver
  struct tty_driver *driver;
  // index
  signed int index;
  // termios
  struct termios *termios;
  // termios_locked
  struct termios *termios_locked;
  // name
  char name[64l];
  // flags
  unsigned long int flags;
  // count
  signed int count;
  // stopped
  unsigned char stopped;
  // hw_stopped
  unsigned char hw_stopped;
  // flow_stopped
  unsigned char flow_stopped;
  // packet
  unsigned char packet;
  // receive_room
  unsigned int receive_room;
  // write_wait
  struct __wait_queue_head write_wait;
  // read_wait
  struct __wait_queue_head read_wait;
  // disc_data
  void *disc_data;
  // driver_data
  void *driver_data;
  // closing
  unsigned char closing;
};

struct watchdog_info
{
  // options
  unsigned int options;
  // firmware_version
  unsigned int firmware_version;
  // identity
  unsigned char identity[32l];
};

struct work_struct
{
  // pending
  unsigned long int pending;
  // func
  void (*func)(void *);
  // data
  void *data;
  // init
  signed int init;
};


// c::__invalid_size_argument_for_IOC
// file /usr/local/ddv/models/con2/include/asm-generic/ioctl.h line 51
unsigned int __invalid_size_argument_for_IOC;
// c::_ddv_module_author
// file pcwd_pci.c line 806
char _ddv_module_author[33l];
// c::_ddv_module_author
// file pcwd_pci.c line 806
char _ddv_module_author[33l] = { 87, 105, 109, 32, 86, 97, 110, 32, 83, 101, 98, 114, 111, 101, 99, 107, 32, 60, 119, 105, 109, 64, 105, 103, 117, 97, 110, 97, 46, 98, 101, 62, 0 };
// c::_ddv_module_description
// file pcwd_pci.c line 807
char _ddv_module_description[33l];
// c::_ddv_module_description
// file pcwd_pci.c line 807
char _ddv_module_description[33l] = { 66, 101, 114, 107, 115, 104, 105, 114, 101, 32, 80, 67, 73, 45, 80, 67, 32, 87, 97, 116, 99, 104, 100, 111, 103, 32, 100, 114, 105, 118, 101, 114, 0 };
// c::_ddv_module_exit
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 43
void (*_ddv_module_exit)(void);
// c::_ddv_module_init
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 42
signed int (*_ddv_module_init)(void);
// c::_ddv_module_license
// file pcwd_pci.c line 808
char _ddv_module_license[4l];
// c::_ddv_module_license
// file pcwd_pci.c line 808
char _ddv_module_license[4l] = { 71, 80, 76, 0 };
// c::_ddv_module_param_debug
// file pcwd_pci.c line 120
char _ddv_module_param_debug[53l];
// c::_ddv_module_param_debug
// file pcwd_pci.c line 120
char _ddv_module_param_debug[53l] = { 68, 101, 98, 117, 103, 32, 108, 101, 118, 101, 108, 58, 32, 48, 61, 81, 117, 105, 101, 116, 44, 32, 49, 61, 86, 101, 114, 98, 111, 115, 101, 44, 32, 50, 61, 68, 101, 98, 117, 103, 32, 40, 100, 101, 102, 97, 117, 108, 116, 61, 48, 41, 0 };
// c::_ddv_module_param_heartbeat
// file pcwd_pci.c line 125
char _ddv_module_param_heartbeat[79l];
// c::_ddv_module_param_heartbeat
// file pcwd_pci.c line 125
char _ddv_module_param_heartbeat[79l] = { 87, 97, 116, 99, 104, 100, 111, 103, 32, 104, 101, 97, 114, 116, 98, 101, 97, 116, 32, 105, 110, 32, 115, 101, 99, 111, 110, 100, 115, 46, 32, 40, 48, 60, 104, 101, 97, 114, 116, 98, 101, 97, 116, 60, 54, 53, 53, 51, 54, 44, 32, 100, 101, 102, 97, 117, 108, 116, 61, 87, 65, 84, 67, 72, 68, 79, 71, 95, 72, 69, 65, 82, 84, 66, 69, 65, 84, 41, 0 };
// c::_ddv_module_param_nowayout
// file pcwd_pci.c line 129
char _ddv_module_param_nowayout[75l];
// c::_ddv_module_param_nowayout
// file pcwd_pci.c line 129
char _ddv_module_param_nowayout[75l] = { 87, 97, 116, 99, 104, 100, 111, 103, 32, 99, 97, 110, 110, 111, 116, 32, 98, 101, 32, 115, 116, 111, 112, 112, 101, 100, 32, 111, 110, 99, 101, 32, 115, 116, 97, 114, 116, 101, 100, 32, 40, 100, 101, 102, 97, 117, 108, 116, 61, 67, 79, 78, 70, 73, 71, 95, 87, 65, 84, 67, 72, 68, 79, 71, 95, 78, 79, 87, 65, 89, 79, 85, 84, 41, 0 };
// c::_ddv_tmp_exit
// file pcwd_pci.c line 804
void (*_ddv_tmp_exit)(void);
// c::_ddv_tmp_exit
// file pcwd_pci.c line 804
void (*_ddv_tmp_exit)(void) = pcipcwd_cleanup_module;
// c::_ddv_tmp_init
// file pcwd_pci.c line 803
signed int (*_ddv_tmp_init)(void);
// c::_ddv_tmp_init
// file pcwd_pci.c line 803
signed int (*_ddv_tmp_init)(void) = pcipcwd_init_module;
// c::cards_found
// file pcwd_pci.c line 100
static signed int cards_found;
// c::cdev_registered
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 22
struct ddv_cdev cdev_registered[10l];
// c::current_execution_context
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 11
signed int current_execution_context;
// c::ddv_ioport_request_len
// file /usr/local/ddv/models/con2/include/ddverify/ioport.h line 11
signed int ddv_ioport_request_len;
// c::ddv_ioport_request_start
// file /usr/local/ddv/models/con2/include/ddverify/ioport.h line 10
signed int ddv_ioport_request_start;
// c::debug
// file pcwd_pci.c line 118
static signed int debug;
// c::debug
// file pcwd_pci.c line 118
static signed int debug = 0;
// c::expect_release
// file pcwd_pci.c line 105
static char expect_release;
// c::fixed_cdev
// file /usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h line 12
struct cdev fixed_cdev[10l];
// c::fixed_cdev_used
// file /usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h line 13
signed int fixed_cdev_used;
// c::fixed_cdev_used
// file /usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h line 13
signed int fixed_cdev_used = 0;
// c::fixed_gendisk
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 24
struct gendisk fixed_gendisk[10l];
// c::fixed_request_queue
// file /usr/local/ddv/models/con2/include/ddverify/blkdev.h line 6
struct request_queue$link14 fixed_request_queue[10l];
// c::genhd_registered
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 25
struct ddv_genhd genhd_registered[10l];
// c::global_tty_driver
// file /usr/local/ddv/models/con2/include/ddverify/tty.h line 13
struct ddv_tty_driver global_tty_driver;
// c::heartbeat
// file pcwd_pci.c line 123
static signed int heartbeat;
// c::heartbeat
// file pcwd_pci.c line 123
static signed int heartbeat = 2;
// c::is_active
// file pcwd_pci.c line 104
static unsigned long int is_active;
// c::jiffies
// file /usr/local/ddv/models/con2/include/linux/jiffies.h line 7
unsigned long int jiffies;
// c::kernel_lock
// file /usr/local/ddv/models/con2/include/linux/smp_lock.h line 7
struct anon$0 kernel_lock;
// c::nowayout
// file pcwd_pci.c line 127
static signed int nowayout;
// c::nowayout
// file pcwd_pci.c line 127
static signed int nowayout = 0;
// c::number_cdev_registered
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 11
signed short int number_cdev_registered;
// c::number_cdev_registered
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 11
signed short int number_cdev_registered = (signed short int)0;
// c::number_fixed_genhd_used
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 13
signed short int number_fixed_genhd_used;
// c::number_fixed_genhd_used
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 13
signed short int number_fixed_genhd_used = (signed short int)0;
// c::number_genhd_registered
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 12
signed short int number_genhd_registered;
// c::number_genhd_registered
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 12
signed short int number_genhd_registered = (signed short int)0;
// c::number_request_queue_used
// file /usr/local/ddv/models/con2/include/ddverify/blkdev.h line 8
signed int number_request_queue_used;
// c::number_request_queue_used
// file /usr/local/ddv/models/con2/include/ddverify/blkdev.h line 8
signed int number_request_queue_used = 0;
// c::number_tasklet_registered
// file /usr/local/ddv/models/con2/include/ddverify/tasklet.h line 8
signed short int number_tasklet_registered;
// c::number_tasklet_registered
// file /usr/local/ddv/models/con2/include/ddverify/tasklet.h line 8
signed short int number_tasklet_registered = (signed short int)0;
// c::number_timer_registered
// file /usr/local/ddv/models/con2/include/ddverify/timer.h line 8
signed short int number_timer_registered;
// c::number_timer_registered
// file /usr/local/ddv/models/con2/include/ddverify/timer.h line 8
signed short int number_timer_registered = (signed short int)0;
// c::pcipcwd_driver
// file pcwd_pci.c line 784
static struct pci_driver$link14 pcipcwd_driver;
// c::pcipcwd_pci_tbl
// file pcwd_pci.c line 777
static struct pci_device_id pcipcwd_pci_tbl[2l];
// c::pcipcwd_pci_tbl
// file pcwd_pci.c line 777
static struct pci_device_id pcipcwd_pci_tbl[2l] = { { .vendor=(unsigned int)4579, .device=(unsigned int)20528, .subvendor=(unsigned int)~0,
    .subdevice=(unsigned int)~0, .class=0u,
    .class_mask=0u, .driver_data=0ul }, 
    { .vendor=(unsigned int)0, .device=0u, .subvendor=0u, .subdevice=0u,
    .class=0u, .class_mask=0u, .driver_data=0ul } };
// c::pcipcwd_driver
// file pcwd_pci.c line 784
static struct pci_driver$link14 pcipcwd_driver = { .name="pcwd_pci", .id_table=pcipcwd_pci_tbl, .probe=pcipcwd_card_init,
    .remove=pcipcwd_card_exit, .suspend=((signed int (*)(struct pci_dev$link13 *dev, struct pm_message state))NULL),
    .resume=((signed int (*)(struct pci_dev$link13 *dev))NULL),
    .enable_wake=((signed int (*)(struct pci_dev$link13 *dev, signed int state, signed int enable))NULL),
    .shutdown=((void (*)(struct pci_dev$link13 *dev))NULL) };
// c::pcipcwd_fops
// file pcwd_pci.c line 627
static struct file_operations$link11 pcipcwd_fops;
// c::pcipcwd_fops
// file pcwd_pci.c line 627
static struct file_operations$link11 pcipcwd_fops = { .owner=((struct module *)NULL), .llseek=no_llseek, .read=((signed int (*)(struct file$link9 *, char *, unsigned int, signed long long int *))NULL),
    .write=pcipcwd_write,
    .readdir=((signed int (*)(struct file$link9 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int)))NULL), .poll=((unsigned int (*)(struct file$link9 *, struct poll_table_struct *))NULL),
    .ioctl=pcipcwd_ioctl,
    .unlocked_ioctl=((signed long int (*)(struct file$link9 *, unsigned int, unsigned long int))NULL), .compat_ioctl=((signed long int (*)(struct file$link9 *, unsigned int, unsigned long int))NULL),
    .mmap=((signed int (*)(struct file$link9 *, struct vm_area_struct *))NULL),
    .open=pcipcwd_open,
    .flush=((signed int (*)(struct file$link9 *))NULL), .release=pcipcwd_release,
    .fsync=((signed int (*)(struct file$link9 *, struct dentry$link10 *, signed int datasync))NULL), .fasync=((signed int (*)(signed int, struct file$link9 *, signed int))NULL),
    .lock=((signed int (*)(struct file$link9 *, signed int, struct file_lock *))NULL),
    .readv=((signed int (*)(struct file$link9 *, const struct iovec *, unsigned long int, signed long long int *))NULL),
    .writev=((signed int (*)(struct file$link9 *, const struct iovec *, unsigned long int, signed long long int *))NULL),
    .sendfile=((signed int (*)(struct file$link9 *, signed long long int *, unsigned int, signed int (*)(struct anon$2 *, struct page *, unsigned long int, unsigned long int), void *))NULL),
    .sendpage=((signed int (*)(struct file$link9 *, struct page *, signed int, unsigned int, signed long long int *, signed int))NULL),
    .get_unmapped_area=((unsigned long int (*)(struct file$link9 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int))NULL),
    .check_flags=((signed int (*)(signed int))NULL),
    .dir_notify=((signed int (*)(struct file$link9 *filp, unsigned long int arg))NULL),
    .flock=((signed int (*)(struct file$link9 *, signed int, struct file_lock *))NULL),
    .open_exec=((signed int (*)(struct inode$link4 *))NULL) };
// c::pcipcwd_miscdev
// file pcwd_pci.c line 636
static struct miscdevice pcipcwd_miscdev;
// c::pcipcwd_miscdev
// file pcwd_pci.c line 636
static struct miscdevice pcipcwd_miscdev = { .minor=130, .name="watchdog", .fops=&pcipcwd_fops };
// c::pcipcwd_notifier
// file pcwd_pci.c line 656
static struct notifier_block pcipcwd_notifier;
// c::pcipcwd_notifier
// file pcwd_pci.c line 656
static struct notifier_block pcipcwd_notifier = { .notifier_call=pcipcwd_notify_sys, .next=((struct notifier_block *)NULL), .priority=0 };
// c::pcipcwd_private
// file pcwd_pci.c line 112
static struct anon$1 pcipcwd_private;
// c::pcipcwd_temp_fops
// file pcwd_pci.c line 642
static struct file_operations$link11 pcipcwd_temp_fops;
// c::pcipcwd_temp_fops
// file pcwd_pci.c line 642
static struct file_operations$link11 pcipcwd_temp_fops = { .owner=((struct module *)NULL), .llseek=no_llseek, .read=pcipcwd_temp_read,
    .write=((signed int (*)(struct file$link9 *, const char *, unsigned int, signed long long int *))NULL), .readdir=((signed int (*)(struct file$link9 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int)))NULL),
    .poll=((unsigned int (*)(struct file$link9 *, struct poll_table_struct *))NULL),
    .ioctl=((signed int (*)(struct inode$link4 *, struct file$link9 *, unsigned int, unsigned long int))NULL),
    .unlocked_ioctl=((signed long int (*)(struct file$link9 *, unsigned int, unsigned long int))NULL),
    .compat_ioctl=((signed long int (*)(struct file$link9 *, unsigned int, unsigned long int))NULL),
    .mmap=((signed int (*)(struct file$link9 *, struct vm_area_struct *))NULL),
    .open=pcipcwd_temp_open,
    .flush=((signed int (*)(struct file$link9 *))NULL), .release=pcipcwd_temp_release,
    .fsync=((signed int (*)(struct file$link9 *, struct dentry$link10 *, signed int datasync))NULL), .fasync=((signed int (*)(signed int, struct file$link9 *, signed int))NULL),
    .lock=((signed int (*)(struct file$link9 *, signed int, struct file_lock *))NULL),
    .readv=((signed int (*)(struct file$link9 *, const struct iovec *, unsigned long int, signed long long int *))NULL),
    .writev=((signed int (*)(struct file$link9 *, const struct iovec *, unsigned long int, signed long long int *))NULL),
    .sendfile=((signed int (*)(struct file$link9 *, signed long long int *, unsigned int, signed int (*)(struct anon$2 *, struct page *, unsigned long int, unsigned long int), void *))NULL),
    .sendpage=((signed int (*)(struct file$link9 *, struct page *, signed int, unsigned int, signed long long int *, signed int))NULL),
    .get_unmapped_area=((unsigned long int (*)(struct file$link9 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int))NULL),
    .check_flags=((signed int (*)(signed int))NULL),
    .dir_notify=((signed int (*)(struct file$link9 *filp, unsigned long int arg))NULL),
    .flock=((signed int (*)(struct file$link9 *, signed int, struct file_lock *))NULL),
    .open_exec=((signed int (*)(struct inode$link4 *))NULL) };
// c::pcipcwd_temp_miscdev
// file pcwd_pci.c line 650
static struct miscdevice pcipcwd_temp_miscdev;
// c::pcipcwd_temp_miscdev
// file pcwd_pci.c line 650
static struct miscdevice pcipcwd_temp_miscdev = { .minor=131, .name="temperature", .fops=&pcipcwd_temp_fops };
// c::proc_root_driver
// file /usr/local/ddv/models/con2/include/linux/proc_fs.h line 11
struct proc_dir_entry *proc_root_driver;
// c::registered_irq
// file /usr/local/ddv/models/con2/include/ddverify/interrupt.h line 14
struct registered_irq registered_irq[16l];
// c::registered_pci_driver
// file /usr/local/ddv/models/con2/include/ddverify/pci.h line 14
struct ddv_pci_driver registered_pci_driver;
// c::shared_workqueue
// file /usr/local/ddv/models/con2/include/ddverify/workqueue.h line 8
struct work_struct *shared_workqueue[10l];
// c::tasklet_registered
// file /usr/local/ddv/models/con2/include/ddverify/tasklet.h line 15
struct ddv_tasklet tasklet_registered[10l];
// c::temp_panic
// file pcwd_pci.c line 103
static signed int temp_panic;
// c::timer_registered
// file /usr/local/ddv/models/con2/include/ddverify/timer.h line 14
struct ddv_timer timer_registered[5l];

// c::__get_free_page
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 13
unsigned long int __get_free_page(unsigned int gfp_mask)
{

__CPROVER_HIDE:
  ;
  if(!((16u & gfp_mask) == 0u))
    assert_context_process$link10();

  return nondet_ulong();
}

// c::__get_free_pages
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 5
unsigned long int __get_free_pages(unsigned int gfp_mask, unsigned int order)
{

__CPROVER_HIDE:
  ;
  if(!((16u & gfp_mask) == 0u))
    assert_context_process$link10();

  return nondet_ulong();
}

// c::__get_user
// file /usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c line 5
signed int __get_user(signed int size, void *ptr)
{

__CPROVER_HIDE:
  ;
  assert_context_process$link24();
  signed int return_value_nondet_int$1 = nondet_int();
  return return_value_nondet_int$1;
}

// c::__put_user
// file /usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c line 21
signed int __put_user(signed int size, void *ptr)
{

__CPROVER_HIDE:
  ;
  assert_context_process$link24();
  signed int return_value_nondet_int$1 = nondet_int();
  return return_value_nondet_int$1;
}

// c::add_disk
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 38
void add_disk(struct gendisk$link4 *disk)
{
  if((signed int)number_genhd_registered < 10)
  {
    /* array `genhd_registered' lower bound */
    assert(0 + (signed long int)number_genhd_registered * 248 >= 0);
    /* array `genhd_registered' upper bound */
    assert((signed long int)number_genhd_registered < 10l);
    genhd_registered[(signed long int)number_genhd_registered].gd = disk;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned int)32ul /*[[struct block_device]]*/);
    /* array `genhd_registered' lower bound */
    assert(0 + (signed long int)number_genhd_registered * 248 >= 0);
    /* array `genhd_registered' upper bound */
    assert((signed long int)number_genhd_registered < 10l);
    genhd_registered[(signed long int)number_genhd_registered].inode.i_bdev = (struct block_device$link5 *)return_value_malloc$1;
    genhd_registered[(signed long int)number_genhd_registered].inode.i_bdev->bd_disk = disk;
    number_genhd_registered = number_genhd_registered + 1;
  }

}

// c::add_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 15
void add_timer(struct timer_list *timer)
{
  timer->__ddv_active = (signed short int)1;
}

// c::add_timer_on
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 24
void add_timer_on(struct timer_list *timer, signed int cpu)
{
  add_timer(timer);
}

// c::alloc_chrdev_region
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 9
signed int alloc_chrdev_region(unsigned int *dev, unsigned int baseminor, unsigned int count, const char *name)
{
  signed int major;
  signed int return_value = nondet_int();
  __CPROVER_assume(return_value == 0 || return_value == -1);
  if(return_value == 0)
  {
    unsigned int return_value_nondet_uint$1 = nondet_size_t();
    major = (signed int)return_value_nondet_uint$1;
    *dev = (unsigned int)(major << 20) | baseminor;
  }

  return return_value;
}

// c::alloc_disk
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 22
struct gendisk$link4 * alloc_disk(signed int minors)
{
  struct gendisk$link4 *gd;
  if((signed int)number_fixed_genhd_used < 10)
  {
    gd = &fixed_gendisk[(signed long int)number_fixed_genhd_used];
    gd->minors = minors;
    number_fixed_genhd_used = number_fixed_genhd_used + 1;
    return gd;
  }

  else
    return (struct gendisk$link4 *)NULL;
}

// c::alloc_page
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 46
struct page * alloc_page(unsigned int gfp_mask)
{

__CPROVER_HIDE:
  ;
  if(!((16u & gfp_mask) == 0u))
    assert_context_process$link10();

  return nondet_0();
}

// c::alloc_pages
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 38
struct page * alloc_pages(unsigned int gfp_mask, unsigned int order)
{

__CPROVER_HIDE:
  ;
  if(!((16u & gfp_mask) == 0u))
    assert_context_process$link10();

  return nondet_0();
}

// c::alloc_tty_driver
// file /usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c line 4
struct tty_driver * alloc_tty_driver(signed int lines)
{
  if(global_tty_driver.allocated == 0)
  {
    global_tty_driver.driver.magic = 21506;
    global_tty_driver.driver.num = lines;
  }

  else
    return (struct tty_driver *)NULL;
  return nondet_1();
}

// c::assert_context_process
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process()
{
  return nondet_int();
}

// c::assert_context_process$link10
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link10()
{
  return nondet_int();
}

// c::assert_context_process$link14
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link14()
{
  return nondet_int();
}

// c::assert_context_process$link15
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link15()
{
  return nondet_int();
}

// c::assert_context_process$link17
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link17()
{
  return nondet_int();
}

// c::assert_context_process$link24
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link24()
{
  return nondet_int();
}

// c::blk_alloc_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 34
struct request_queue$link14 * blk_alloc_queue(unsigned int gfp_mask)
{
  struct request_queue$link14 *queue;
  signed int return_value_nondet_int$1 = nondet_int();
  if(!(return_value_nondet_int$1 == 0))
  {
    queue=get_fixed_request_queue();
    queue->request_fn = (void (*)(struct request_queue$link14 *))NULL;
    queue->make_request_fn = (signed int (*)(struct request_queue$link14 *, struct bio$link15 *))NULL;
    queue->__ddv_queue_alive = 1;
    return queue;
  }

  else
    return (struct request_queue$link14 *)NULL;
}

// c::blk_cleanup_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 69
void blk_cleanup_queue(struct request_queue$link14 *q)
{
  q->__ddv_queue_alive = 0;
}

// c::blk_init_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 16
struct request_queue$link14 * blk_init_queue(void (*rfn)(struct request_queue$link14 *), struct anon$0 *lock)
{
  struct request_queue$link14 *queue;
  signed int return_value_nondet_int$1 = nondet_int();
  if(!(return_value_nondet_int$1 == 0))
  {
    queue=get_fixed_request_queue();
    queue->queue_lock = lock;
    queue->request_fn = rfn;
    queue->make_request_fn = (signed int (*)(struct request_queue$link14 *, struct bio$link15 *))NULL;
    queue->__ddv_queue_alive = 1;
    return queue;
  }

  else
    return (struct request_queue$link14 *)NULL;
}

// c::blk_queue_hardsect_size
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 64
void blk_queue_hardsect_size(struct request_queue$link14 *q, unsigned short int size)
{
  q->hardsect_size = size;
}

// c::blk_queue_make_request
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 51
void blk_queue_make_request(struct request_queue$link14 *q, signed int (*mfn)(struct request_queue$link14 *, struct bio$link15 *))
{
  q->make_request_fn = mfn;
}

// c::call_cdev_functions
// file /usr/local/ddv/models/con2/src/ddverify/cdev.c line 5
void call_cdev_functions()
{
  signed int cdev_no;
  signed int function_no;
  signed int result;
  signed long long int loff_t_value;
  signed int int_value;
  unsigned int uint_value;
  unsigned long int ulong_value;
  char char_value;
  unsigned int size_t_value;
  if((signed int)number_cdev_registered == 0)
    return;

  unsigned short int return_value_nondet_ushort$1 = nondet_ushort();
  cdev_no = (signed int)return_value_nondet_ushort$1;
  __CPROVER_assume(0 <= cdev_no && cdev_no < (signed int)number_cdev_registered);
  unsigned short int return_value_nondet_ushort$2 = nondet_ushort();
  switch((signed int)return_value_nondet_ushort$2)
  {

    case 0:
      {
        /* array `cdev_registered' lower bound */
        assert(0 + (signed long int)cdev_no * 112 >= 0);
        /* array `cdev_registered' upper bound */
        assert((signed long int)cdev_no < 10l);
        if(!(cdev_registered[(signed long int)cdev_no].cdevp->ops->llseek == ((signed long long int (*)(struct file *, signed long long int, signed int))NULL)))
        {
          loff_t_value = nondet_loff_t();
          int_value = nondet_int();
          cdev_registered[(signed long int)cdev_no].cdevp->ops->llseek(&cdev_registered[(signed long int)cdev_no].filp, loff_t_value, int_value);
        }

        goto __CPROVER_DUMP_L35;
      }
    case 1:
      {
        /* array `cdev_registered' lower bound */
        assert(0 + (signed long int)cdev_no * 112 >= 0);
        /* array `cdev_registered' upper bound */
        assert((signed long int)cdev_no < 10l);
        if(!(cdev_registered[(signed long int)cdev_no].cdevp->ops->read == ((signed int (*)(struct file *, char *, unsigned int, signed long long int *))NULL)))
        {
          char_value = nondet_char();
          size_t_value = nondet_size_t();
          cdev_registered[(signed long int)cdev_no].cdevp->ops->read(&cdev_registered[(signed long int)cdev_no].filp, &char_value, size_t_value, &loff_t_value);
        }

        goto __CPROVER_DUMP_L35;
      }
    case 2:
      goto __CPROVER_DUMP_L35;
    case 3:
      {
        /* array `cdev_registered' lower bound */
        assert(0 + (signed long int)cdev_no * 112 >= 0);
        /* array `cdev_registered' upper bound */
        assert((signed long int)cdev_no < 10l);
        if(!(cdev_registered[(signed long int)cdev_no].cdevp->ops->write == ((signed int (*)(struct file *, const char *, unsigned int, signed long long int *))NULL)))
        {
          char_value = nondet_char();
          size_t_value = nondet_size_t();
          cdev_registered[(signed long int)cdev_no].cdevp->ops->write(&cdev_registered[(signed long int)cdev_no].filp, &char_value, size_t_value, &loff_t_value);
        }

        goto __CPROVER_DUMP_L35;
      }
    case 4:
      goto __CPROVER_DUMP_L35;
    case 5:
      goto __CPROVER_DUMP_L35;
    case 6:
      goto __CPROVER_DUMP_L35;
    case 7:
      {
        /* array `cdev_registered' lower bound */
        assert(0 + (signed long int)cdev_no * 112 >= 0);
        /* array `cdev_registered' upper bound */
        assert((signed long int)cdev_no < 10l);
        if(!(cdev_registered[(signed long int)cdev_no].cdevp->ops->ioctl == ((signed int (*)(struct inode *, struct file *, unsigned int, unsigned long int))NULL)))
        {
          uint_value = nondet_size_t();
          ulong_value = nondet_ulong();
          cdev_registered[(signed long int)cdev_no].cdevp->ops->ioctl(&cdev_registered[(signed long int)cdev_no].inode, &cdev_registered[(signed long int)cdev_no].filp, uint_value, ulong_value);
        }

        goto __CPROVER_DUMP_L35;
      }
    case 8:
      goto __CPROVER_DUMP_L35;
    case 9:
      goto __CPROVER_DUMP_L35;
    case 10:
      goto __CPROVER_DUMP_L35;
    case 11:
      {
        /* array `cdev_registered' lower bound */
        assert(0 + (signed long int)cdev_no * 112 >= 0);
        /* array `cdev_registered' upper bound */
        assert((signed long int)cdev_no < 10l);
        if(!(cdev_registered[(signed long int)cdev_no].cdevp->ops->open == ((signed int (*)(struct inode *, struct file *))NULL)))
        {
          if(cdev_registered[(signed long int)cdev_no].open == 0)
          {
            result=cdev_registered[(signed long int)cdev_no].cdevp->ops->open(&cdev_registered[(signed long int)cdev_no].inode, &cdev_registered[(signed long int)cdev_no].filp);
            if(result == 0)
            {
              /* array `cdev_registered' lower bound */
              assert(0 + (signed long int)cdev_no * 112 >= 0);
              /* array `cdev_registered' upper bound */
              assert((signed long int)cdev_no < 10l);
              cdev_registered[(signed long int)cdev_no].open = 1;
            }

          }

        }

        goto __CPROVER_DUMP_L35;
      }
    case 12:
      goto __CPROVER_DUMP_L35;
    case 13:
      {
        /* array `cdev_registered' lower bound */
        assert(0 + (signed long int)cdev_no * 112 >= 0);
        /* array `cdev_registered' upper bound */
        assert((signed long int)cdev_no < 10l);
        if(!(cdev_registered[(signed long int)cdev_no].cdevp->ops->release == ((signed int (*)(struct inode *, struct file *))NULL)))
        {
          if(!(cdev_registered[(signed long int)cdev_no].open == 0))
          {
            result=cdev_registered[(signed long int)cdev_no].cdevp->ops->release(&cdev_registered[(signed long int)cdev_no].inode, &cdev_registered[(signed long int)cdev_no].filp);
            if(result == 0)
            {
              /* array `cdev_registered' lower bound */
              assert(0 + (signed long int)cdev_no * 112 >= 0);
              /* array `cdev_registered' upper bound */
              assert((signed long int)cdev_no < 10l);
              cdev_registered[(signed long int)cdev_no].open = 0;
            }

          }

        }

        goto __CPROVER_DUMP_L35;
      }
    case 14:
      goto __CPROVER_DUMP_L35;
    case 15:
      goto __CPROVER_DUMP_L35;
    case 16:
      goto __CPROVER_DUMP_L35;
    case 17:
      goto __CPROVER_DUMP_L35;
    case 18:
      goto __CPROVER_DUMP_L35;
    case 19:
      goto __CPROVER_DUMP_L35;
    case 20:
      goto __CPROVER_DUMP_L35;
    case 21:
      goto __CPROVER_DUMP_L35;
    case 22:
      goto __CPROVER_DUMP_L35;
    case 23:
      goto __CPROVER_DUMP_L35;
    case 24:
      goto __CPROVER_DUMP_L35;
    case 25:
      goto __CPROVER_DUMP_L35;
    case 26:
      ;
    default:

      __CPROVER_DUMP_L35:
        ;
  }
}

// c::call_ddv
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 95
signed int call_ddv()
{
  signed int err;
  current_execution_context = 1;
  init_kernel();
  err=_ddv_module_init();
  if(!(err == 0))
    return -1;

  ddv();
  current_execution_context = 1;
  _ddv_module_exit();
  return 0;
}

// c::call_interrupt_handler
// file /usr/local/ddv/models/con2/include/ddverify/interrupt.h line 16
void call_interrupt_handler()
{
  unsigned short int i;
  struct pt_regs regs;
  signed int return_value_nondet_int$1 = nondet_int();
  i = (unsigned short int)return_value_nondet_int$1;
  __CPROVER_assume((signed int)i < 16);
  /* array `registered_irq' upper bound */
  assert((signed long int)i < 16l);
  if(!(registered_irq[(signed long int)i].handler == ((signed int (*)(signed int, void *, struct pt_regs *))NULL)))
    registered_irq[(signed long int)i].handler((signed int)i, registered_irq[(signed long int)i].dev_id, &regs);

}

// c::call_shared_workqueue_functions
// file /usr/local/ddv/models/con2/include/ddverify/workqueue.h line 10
void call_shared_workqueue_functions()
{
  unsigned short int i = nondet_ushort();
  __CPROVER_assume((signed int)i < 10);
  /* array `shared_workqueue' upper bound */
  assert((signed long int)i < 10l);
  if(!(shared_workqueue[(signed long int)i] == ((struct work_struct *)NULL)))
  {
    shared_workqueue[(signed long int)i]->func(shared_workqueue[(signed long int)i]->data);
    /* array `shared_workqueue' upper bound */
    assert((signed long int)i < 10l);
    shared_workqueue[(signed long int)i] = (struct work_struct *)NULL;
  }

}

// c::call_tasklet_functions
// file /usr/local/ddv/models/con2/include/ddverify/tasklet.h line 17
void call_tasklet_functions()
{
  unsigned int i;
  __CPROVER_assume(i < (unsigned int)10);
  /* array `tasklet_registered' upper bound */
  assert((signed long int)i < 10l);
  if(!(tasklet_registered[(signed long int)i].tasklet == ((struct tasklet_struct *)NULL)))
  {
    if(tasklet_registered[(signed long int)i].tasklet->count == 0)
    {
      tasklet_registered[(signed long int)i].is_running = (unsigned short int)1;
      tasklet_registered[(signed long int)i].tasklet->func(tasklet_registered[(signed long int)i].tasklet->data);
      /* array `tasklet_registered' upper bound */
      assert((signed long int)i < 10l);
      tasklet_registered[(signed long int)i].is_running = (unsigned short int)0;
      tasklet_registered[(signed long int)i].tasklet = (struct tasklet_struct *)NULL;
    }

  }

}

// c::cdev_add
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 72
signed int cdev_add(struct cdev$link0 *p, unsigned int dev, unsigned int count)
{
  p->dev = dev;
  p->count = count;
  signed int return_value = nondet_int();
  __CPROVER_assume(return_value == 0 || return_value == -1);
  if(return_value == 0)
  {
    if((signed int)number_cdev_registered < 10)
    {
      /* array `cdev_registered' lower bound */
      assert(0 + (signed long int)number_cdev_registered * 112 >= 0);
      /* array `cdev_registered' upper bound */
      assert((signed long int)number_cdev_registered < 10l);
      cdev_registered[(signed long int)number_cdev_registered].cdevp = p;
      cdev_registered[(signed long int)number_cdev_registered].inode.i_rdev = dev;
      cdev_registered[(signed long int)number_cdev_registered].inode.i_cdev = p;
      cdev_registered[(signed long int)number_cdev_registered].open = 0;
      number_cdev_registered = number_cdev_registered + 1;
    }

    else
      return -1;
  }

  return return_value;
}

// c::cdev_alloc
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 60
struct cdev$link0 * cdev_alloc(void)
{
  signed int tmp_post$1;
  if(fixed_cdev_used < 10)
  {
    tmp_post$1 = fixed_cdev_used;
    fixed_cdev_used = fixed_cdev_used + 1;
    return &fixed_cdev[(signed long int)tmp_post$1];
  }

  return nondet_2();
}

// c::cdev_del
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 97
void cdev_del(struct cdev$link0 *p)
{
  signed int i = 0;
  while(!(i >= (signed int)number_cdev_registered))
  {
    /* array `cdev_registered' lower bound */
    assert(0 + (signed long int)i * 112 >= 0);
    /* array `cdev_registered' upper bound */
    assert((signed long int)i < 10l);
    if(cdev_registered[(signed long int)i].cdevp == p)
    {
      cdev_registered[(signed long int)i].cdevp = ((struct cdev$link0 *)NULL);
      return;
    }

    i = i + 1;
  }
}

// c::cdev_init
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 67
void cdev_init(struct cdev$link0 *cdev, struct file_operations$link4 *fops)
{
  cdev->ops = fops;
}

// c::copy_from_user
// file /usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c line 45
unsigned long int copy_from_user(void *to, void *from, unsigned long int n)
{

__CPROVER_HIDE:
  ;
  assert_context_process$link24();
  unsigned long int return_value_nondet_ulong$1 = nondet_ulong();
  return return_value_nondet_ulong$1;
}

// c::copy_to_user
// file /usr/local/ddv/models/con2/include/asm/uaccess.h line 51
unsigned long int copy_to_user(void *to, const void *from, unsigned long int n)
{

__CPROVER_HIDE:
  ;
  assert_context_process$link24();
  unsigned long int return_value_nondet_ulong$1 = nondet_ulong();
  return return_value_nondet_ulong$1;
}

// c::ddv
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 75
void ddv()
{
  unsigned short int random;
  struct __pthread_t_struct thread;
  pthread_create(&thread, (const struct __pthread_attr_t_struct *)NULL, ddv_2, NULL);
  signed int return_value_nondet_int$1;
  do
  {
    current_execution_context = 1;
    call_cdev_functions();
    return_value_nondet_int$1 = nondet_int();
  }
  while(return_value_nondet_int$1 != 0);
}

// c::ddv_2
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 31
static void * ddv_2(void *arg)
{
  unsigned short int random;
  do
  {
    random = nondet_ushort();
    switch((signed int)random)
    {

      case 1:
        {
          current_execution_context = 2;
          call_timer_functions();
          current_execution_context = 1;
          goto __CPROVER_DUMP_L7;
        }
      case 2:
        {
          current_execution_context = 2;
          call_interrupt_handler();
          current_execution_context = 1;
          goto __CPROVER_DUMP_L7;
        }
      case 3:
        {
          current_execution_context = 1;
          call_shared_workqueue_functions();
          current_execution_context = 1;
          goto __CPROVER_DUMP_L7;
        }
      case 4:
        {
          current_execution_context = 2;
          call_tasklet_functions();
          current_execution_context = 1;
          goto __CPROVER_DUMP_L7;
        }
      case 5:
        {
          current_execution_context = 1;
          call_pci_functions();
          current_execution_context = 1;
        }
      default:
        ;
    }

  __CPROVER_DUMP_L7:
    ;
  }
  while(random != 0);
  return nondet_3();
}

// c::del_gendisk
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 49
void del_gendisk(struct gendisk$link4 *gp)
{
  signed int i = 0;
  while(!(i >= (signed int)number_genhd_registered))
  {
    /* array `genhd_registered' lower bound */
    assert(0 + (signed long int)i * 248 >= 0);
    /* array `genhd_registered' upper bound */
    assert((signed long int)i < 10l);
    if(genhd_registered[(signed long int)i].gd == gp)
      genhd_registered[(signed long int)i].gd = (struct gendisk$link4 *)NULL;

    i = i + 1;
  }
}

// c::del_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 30
signed int del_timer(struct timer_list *timer)
{
  timer->__ddv_active = (signed short int)0;
  return nondet_int();
}

// c::down
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 33
void down(struct semaphore *sem)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(sem->locked == 0)
    {
      sem->locked = 1;
      __CPROVER_atomic_end();
      return;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
}

// c::down_interruptible
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 58
signed int down_interruptible(struct semaphore *sem)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(sem->locked == 0)
    {
      sem->locked = 1;
      __CPROVER_atomic_end();
      return 0;
    }

    signed int return_value_nondet_int$1 = nondet_int();
    if(!(return_value_nondet_int$1 == 0))
    {
      __CPROVER_atomic_end();
      return -1;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
  return nondet_int();
}

// c::down_trylock
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 88
signed int down_trylock(struct semaphore *sem)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  if(sem->locked == 0)
  {
    sem->locked = 1;
    __CPROVER_atomic_end();
    return -1;
  }

  __CPROVER_atomic_end();
  return 0;
}

// c::end_request
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 56
void end_request(struct request$link19 *req, signed int uptodate)
{
  signed int genhd_no = req->rq_disk->queue->__ddv_genhd_no;
  /* array `genhd_registered' lower bound */
  assert(0 + (signed long int)genhd_no * 248 >= 0);
  /* array `genhd_registered' upper bound */
  assert((signed long int)genhd_no < 10l);
  genhd_registered[(signed long int)genhd_no].requests_open = 0;
}

// c::free_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c line 17
void free_irq(unsigned int irq, void *dev_id)
{
  /* array `registered_irq' upper bound */
  assert((signed long int)irq < 16l);
  registered_irq[(signed long int)irq].handler = (signed int (*)(signed int, void *, struct pt_regs *))NULL;
  registered_irq[(signed long int)irq].dev_id = NULL;
}

// c::get_fixed_request_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 7
struct request_queue$link14 * get_fixed_request_queue()
{
  signed int tmp_post$1;
  if(number_request_queue_used < 10)
  {
    tmp_post$1 = number_request_queue_used;
    number_request_queue_used = number_request_queue_used + 1;
    return &fixed_request_queue[(signed long int)tmp_post$1];
  }

  else
    return (struct request_queue$link14 *)NULL;
}

// c::get_user
// file /usr/local/ddv/models/con2/include/asm/uaccess.h line 43
signed int get_user(signed int size, void *ptr)
{

__CPROVER_HIDE:
  ;
  assert_context_process$link24();
  signed int return_value_nondet_int$1 = nondet_int();
  return return_value_nondet_int$1;
}

// c::get_zeroed_page
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 21
unsigned long int get_zeroed_page(unsigned int gfp_mask)
{

__CPROVER_HIDE:
  ;
  if(!((16u & gfp_mask) == 0u))
    assert_context_process$link10();

  return nondet_ulong();
}

// c::inb
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 32
unsigned char inb(unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
  unsigned char return_value_nondet_uchar$1 = nondet_uchar();
  return return_value_nondet_uchar$1;
}

// c::inb_p
// file /usr/local/ddv/models/con2/include/asm/io.h line 23
unsigned char inb_p(unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
  unsigned char return_value_nondet_uchar$1 = nondet_uchar();
  return return_value_nondet_uchar$1;
}

// c::init_MUTEX
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 15
void init_MUTEX(struct semaphore *sem)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  sem->init = 1;
  sem->locked = 0;
  __CPROVER_atomic_end();
}

// c::init_MUTEX_LOCKED
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 24
void init_MUTEX_LOCKED(struct semaphore *sem)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  sem->init = 1;
  sem->locked = 1;
  __CPROVER_atomic_end();
}

// c::init_kernel
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 15
void init_kernel()
{
  signed int i;
  spin_lock_init(&kernel_lock);
  i = 0;
  while(i < 10)
  {
    /* array `shared_workqueue' lower bound */
    assert(0 + (signed long int)i * 8 >= 0);
    /* array `shared_workqueue' upper bound */
    assert((signed long int)i < 10l);
    shared_workqueue[(signed long int)i] = (struct work_struct *)NULL;
    i = i + 1;
  }
  i = 0;
  while(i < 10)
  {
    /* array `tasklet_registered' lower bound */
    assert(0 + (signed long int)i * 16 >= 0);
    /* array `tasklet_registered' upper bound */
    assert((signed long int)i < 10l);
    tasklet_registered[(signed long int)i].tasklet = (struct tasklet_struct *)NULL;
    tasklet_registered[(signed long int)i].is_running = (unsigned short int)0;
    i = i + 1;
  }
}

// c::init_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 4
void init_timer(struct timer_list *timer)
{
  if((signed int)number_timer_registered < 5)
  {
    timer->__ddv_active = (signed short int)0;
    timer->__ddv_init = (signed short int)1;
    /* array `timer_registered' lower bound */
    assert(0 + (signed long int)number_timer_registered * 8 >= 0);
    /* array `timer_registered' upper bound */
    assert((signed long int)number_timer_registered < 5l);
    timer_registered[(signed long int)number_timer_registered].timer = timer;
    number_timer_registered = number_timer_registered + 1;
  }

}

// c::init_waitqueue_head
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 3
void init_waitqueue_head(struct __wait_queue_head *q)
{
  q->init = 1;
}

// c::inl
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 60
unsigned int inl(unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
  unsigned int return_value_nondet_unsigned$1 = nondet_size_t();
  return return_value_nondet_unsigned$1;
}

// c::inl_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 102
unsigned int inl_p(unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
  unsigned int return_value_nondet_unsigned$1 = nondet_size_t();
  return return_value_nondet_unsigned$1;
}

// c::interruptible_sleep_on
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 40
void interruptible_sleep_on(struct __wait_queue_head *q)
{
  ;
}

// c::inw
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 46
unsigned short int inw(unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
  unsigned short int return_value_nondet_ushort$1 = nondet_ushort();
  return return_value_nondet_ushort$1;
}

// c::inw_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 88
unsigned short int inw_p(unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
  unsigned short int return_value_nondet_ushort$1 = nondet_ushort();
  return return_value_nondet_ushort$1;
}

// c::kmalloc
// file /usr/local/ddv/models/con2/src/linux/mm/slab.c line 6
void * kmalloc(unsigned int size, unsigned int flags)
{
  if(!((16u & flags) == 0u))
    assert_context_process$link17();

  void *return_value_malloc$1;
  return_value_malloc$1=malloc(size);
  return return_value_malloc$1;
}

// c::kzalloc
// file /usr/local/ddv/models/con2/src/linux/mm/slab.c line 15
void * kzalloc(unsigned int size, unsigned int flags)
{
  if(!((16u & flags) == 0u))
    assert_context_process$link17();

  void *return_value_malloc$1;
  return_value_malloc$1=malloc(size);
  return return_value_malloc$1;
}

// c::main
// file __main.c line 4
signed int main()
{
  _ddv_module_init = pcipcwd_init_module;
  _ddv_module_exit = pcipcwd_cleanup_module;
  call_ddv();
  return 0;
}

// c::misc_register
// file /usr/local/ddv/models/con2/include/linux/miscdevice.h line 40
signed int misc_register(struct miscdevice$link22 *misc)
{
  signed int i;
  unsigned int dev;
  if(fixed_cdev_used < 10)
  {
    i = fixed_cdev_used;
    fixed_cdev_used = fixed_cdev_used + 1;
    /* array `fixed_cdev' lower bound */
    assert(0 + (signed long int)i * 24 >= 0);
    /* array `fixed_cdev' upper bound */
    assert((signed long int)i < 10l);
    fixed_cdev[(signed long int)i].owner = ((struct module *)NULL);
    fixed_cdev[(signed long int)i].ops = misc->fops;
    dev = (unsigned int)(10 << 20 | misc->minor);
    signed int return_value_cdev_add$1;
    return_value_cdev_add$1=cdev_add(&fixed_cdev[(signed long int)i], dev, (unsigned int)0);
    return return_value_cdev_add$1;
  }

  else
    return -1;
}

// c::mod_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 35
signed int mod_timer(struct timer_list *timer, unsigned long int expires)
{
  timer->expires = expires;
  timer->__ddv_active = (signed short int)1;
  return nondet_int();
}

// c::mutex_init
// file /usr/local/ddv/models/con2/src/linux/kernel/mutex.c line 4
void mutex_init(struct mutex *lock)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  lock->locked = 0;
  lock->init = 1;
  __CPROVER_atomic_end();
}

// c::mutex_lock
// file /usr/local/ddv/models/con2/src/linux/kernel/mutex.c line 16
void mutex_lock(struct mutex *lock)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(lock->locked == 0)
    {
      lock->locked = 1;
      __CPROVER_atomic_end();
      return;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
}

// c::mutex_unlock
// file /usr/local/ddv/models/con2/src/linux/kernel/mutex.c line 41
void mutex_unlock(struct mutex *lock)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  assert_context_process();
  lock->locked = 0;
  __CPROVER_atomic_end();
}

// c::outb
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 40
void outb(unsigned char byte, unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
}

// c::outb_p
// file /usr/local/ddv/models/con2/include/asm/io.h line 24
void outb_p(unsigned char byte, unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
}

// c::outl
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 68
void outl(unsigned int doubleword, unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
}

// c::outl_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 110
void outl_p(unsigned int doubleword, unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
}

// c::outw
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 54
void outw(unsigned short int word, unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
}

// c::outw_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 96
void outw_p(unsigned short int word, unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
}

// c::pci_enable_device
// file /usr/local/ddv/models/con2/include/linux/pci.h line 145
signed int pci_enable_device(struct pci_dev$link1 *dev)
{
  signed int i = 0;
  while(i < 12)
  {
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)i * 32) - POINTER_OFFSET(dev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(dev) && !(POINTER_OBJECT(dev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)i * 32 + POINTER_OFFSET(dev) < (DYNAMIC_OBJECT(dev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(dev)));
    dev->resource[(signed long int)i].flags = (unsigned long int)256;
    unsigned int return_value_nondet_uint$1 = nondet_size_t();
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)i * 32) - POINTER_OFFSET(dev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(dev) && !(POINTER_OBJECT(dev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)i * 32 + POINTER_OFFSET(dev) < (DYNAMIC_OBJECT(dev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(dev)));
    dev->resource[(signed long int)i].start = (unsigned long int)return_value_nondet_uint$1;
    unsigned short int return_value_nondet_ushort$2 = nondet_ushort();
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)i * 32) - POINTER_OFFSET(dev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(dev) && !(POINTER_OBJECT(dev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)i * 32 + POINTER_OFFSET(dev) < (DYNAMIC_OBJECT(dev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(dev)));
    dev->resource[(signed long int)i].end = dev->resource[(signed long int)i].start + (unsigned long int)return_value_nondet_ushort$2;
    i = i + 1;
  }
  return nondet_int();
}

// c::pci_get_class
// file /usr/local/ddv/models/con2/src/linux/pci.c line 19
struct pci_dev$link1 * pci_get_class(unsigned int class, struct pci_dev$link1 *from)
{
  if(from == ((struct pci_dev$link1 *)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned int)432ul /*[[struct pci_dev]]*/);
    from = (struct pci_dev$link1 *)return_value_malloc$1;
  }

  signed int return_value_nondet_int$2 = nondet_int();
  if(!(return_value_nondet_int$2 == 0))
  {
    from->vendor = nondet_ushort();
    from->device = nondet_ushort();
    from->irq = nondet_size_t();
    __CPROVER_assume(from->irq < (unsigned int)16);
    return from;
  }

  else
    return (struct pci_dev$link1 *)NULL;
}

// c::pci_register_driver
// file /usr/local/ddv/models/con2/include/linux/pci.h line 141
signed int pci_register_driver(struct pci_driver$link2 *driver)
{
  signed int return_value_nondet_int$1 = nondet_int();
  if(!(return_value_nondet_int$1 == 0))
  {
    registered_pci_driver.pci_driver = driver;
    registered_pci_driver.no_pci_device_id = (unsigned int)(8ul /*[[const struct pci_device_id *]]*/ / 32ul /*[[struct pci_device_id]]*/);
    registered_pci_driver.dev_initialized = 0;
    return 0;
  }

  else
    return -1;
}

// c::pci_release_region
// file /usr/local/ddv/models/con2/src/linux/pci.c line 56
void pci_release_region(struct pci_dev$link1 *pdev, signed int bar)
{
  _Bool tmp_if_expr$1;
  /* array.resource lower bound */
  assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
  /* array.resource upper bound */
  assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
  if(pdev->resource[(signed long int)bar].start == 0ul)
    tmp_if_expr$1 = pdev->resource[(signed long int)bar].end == pdev->resource[(signed long int)bar].start ? TRUE : FALSE;

  else
    tmp_if_expr$1 = FALSE;
  unsigned long int tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (unsigned long int)0;

  else
  {
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    tmp_if_expr$2 = (pdev->resource[(signed long int)bar].end - pdev->resource[(signed long int)bar].start) + (unsigned long int)1;
  }
  if(tmp_if_expr$2 == 0ul)
    return;

  /* array.resource lower bound */
  assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
  /* array.resource upper bound */
  assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
  _Bool tmp_if_expr$3;
  unsigned long int tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  unsigned long int tmp_if_expr$6;
  if(!((256ul & pdev->resource[(signed long int)bar].flags) == 0ul))
  {
    if(pdev->resource[(signed long int)bar].start == 0ul)
      tmp_if_expr$3 = pdev->resource[(signed long int)bar].end == pdev->resource[(signed long int)bar].start ? TRUE : FALSE;

    else
      tmp_if_expr$3 = FALSE;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (unsigned long int)0;

    else
    {
      /* array.resource lower bound */
      assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
      /* array.resource upper bound */
      assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
      tmp_if_expr$4 = (pdev->resource[(signed long int)bar].end - pdev->resource[(signed long int)bar].start) + (unsigned long int)1;
    }
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    release_region(pdev->resource[(signed long int)bar].start, tmp_if_expr$4);
  }

  else
  {
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    if(!((512ul & pdev->resource[(signed long int)bar].flags) == 0ul))
    {
      if(pdev->resource[(signed long int)bar].start == 0ul)
        tmp_if_expr$5 = pdev->resource[(signed long int)bar].end == pdev->resource[(signed long int)bar].start ? TRUE : FALSE;

      else
        tmp_if_expr$5 = FALSE;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (unsigned long int)0;

      else
      {
        /* array.resource lower bound */
        assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
        /* array.resource upper bound */
        assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
        tmp_if_expr$6 = (pdev->resource[(signed long int)bar].end - pdev->resource[(signed long int)bar].start) + (unsigned long int)1;
      }
      /* array.resource lower bound */
      assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
      /* array.resource upper bound */
      assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
      release_mem_region(pdev->resource[(signed long int)bar].start, tmp_if_expr$6);
    }

  }
}

// c::pci_release_regions
// file /usr/local/ddv/models/con2/include/linux/pci.h line 154
void pci_release_regions(struct pci_dev$link1 *pdev)
{
  signed int i = 0;
  while(i < 6)
  {
    pci_release_region(pdev, i);
    i = i + 1;
  }
}

// c::pci_request_region
// file /usr/local/ddv/models/con2/src/linux/pci.c line 68
signed int pci_request_region(struct pci_dev$link1 *pdev, signed int bar, const char *res_name)
{
  _Bool tmp_if_expr$1;
  /* array.resource lower bound */
  assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
  /* array.resource upper bound */
  assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
  if(pdev->resource[(signed long int)bar].start == 0ul)
    tmp_if_expr$1 = pdev->resource[(signed long int)bar].end == pdev->resource[(signed long int)bar].start ? TRUE : FALSE;

  else
    tmp_if_expr$1 = FALSE;
  unsigned long int tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (unsigned long int)0;

  else
  {
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    tmp_if_expr$2 = (pdev->resource[(signed long int)bar].end - pdev->resource[(signed long int)bar].start) + (unsigned long int)1;
  }
  if(tmp_if_expr$2 == 0ul)
    return 0;

  /* array.resource lower bound */
  assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
  /* array.resource upper bound */
  assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
  _Bool tmp_if_expr$3;
  unsigned long int tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  unsigned long int tmp_if_expr$7;
  if(!((256ul & pdev->resource[(signed long int)bar].flags) == 0ul))
  {
    if(pdev->resource[(signed long int)bar].start == 0ul)
      tmp_if_expr$3 = pdev->resource[(signed long int)bar].end == pdev->resource[(signed long int)bar].start ? TRUE : FALSE;

    else
      tmp_if_expr$3 = FALSE;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (unsigned long int)0;

    else
    {
      /* array.resource lower bound */
      assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
      /* array.resource upper bound */
      assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
      tmp_if_expr$4 = (pdev->resource[(signed long int)bar].end - pdev->resource[(signed long int)bar].start) + (unsigned long int)1;
    }
    struct resource *return_value_request_region$5;
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    return_value_request_region$5=request_region(pdev->resource[(signed long int)bar].start, tmp_if_expr$4, res_name);
    if(return_value_request_region$5 == ((struct resource *)NULL))
      return -16;

  }

  else
  {
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    if(!((512ul & pdev->resource[(signed long int)bar].flags) == 0ul))
    {
      if(pdev->resource[(signed long int)bar].start == 0ul)
        tmp_if_expr$6 = pdev->resource[(signed long int)bar].end == pdev->resource[(signed long int)bar].start ? TRUE : FALSE;

      else
        tmp_if_expr$6 = FALSE;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (unsigned long int)0;

      else
      {
        /* array.resource lower bound */
        assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
        /* array.resource upper bound */
        assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
        tmp_if_expr$7 = (pdev->resource[(signed long int)bar].end - pdev->resource[(signed long int)bar].start) + (unsigned long int)1;
      }
      struct resource *return_value_request_mem_region$8;
      /* array.resource lower bound */
      assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
      /* array.resource upper bound */
      assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
      return_value_request_mem_region$8=request_mem_region(pdev->resource[(signed long int)bar].start, tmp_if_expr$7, res_name);
      if(return_value_request_mem_region$8 == ((struct resource *)NULL))
        return -16;

    }

  }
  return 0;
}

// c::pci_request_regions
// file /usr/local/ddv/models/con2/include/linux/pci.h line 152
signed int pci_request_regions(struct pci_dev$link1 *pdev, const char *res_name)
{
  signed int i = 0;
  signed int return_value_pci_request_region$1;
  while(i < 6)
  {
    return_value_pci_request_region$1=pci_request_region(pdev, i, res_name);
    if(return_value_pci_request_region$1 != 0)
      goto err_out;

    i = i + 1;
  }
  return 0;
  do
  {

  err_out:
    ;
    i = i - 1;
    if(!(i >= 0))
      goto __CPROVER_DUMP_L4;

    pci_release_region(pdev, i);
  }
  while(TRUE);

__CPROVER_DUMP_L4:
  ;
  return -16;
}

// c::pci_unregister_driver
// file /usr/local/ddv/models/con2/include/linux/pci.h line 143
void pci_unregister_driver(struct pci_driver$link2 *driver)
{
  registered_pci_driver.pci_driver = (struct pci_driver$link2 *)NULL;
  registered_pci_driver.no_pci_device_id = (unsigned int)0;
}

// c::pcipcwd_card_exit
// file pcwd_pci.c line 761
static void pcipcwd_card_exit(struct pci_dev$link13 *pdev)
{
  if(nowayout == 0)
    pcipcwd_stop();

  misc_deregister(&pcipcwd_miscdev);
  if(!(pcipcwd_private.supports_temp == 0))
    misc_deregister(&pcipcwd_temp_miscdev);

  unregister_reboot_notifier(&pcipcwd_notifier);
  pci_release_regions(pdev);
  pci_disable_device(pdev);
  cards_found = cards_found - 1;
}

// c::pcipcwd_card_init
// file pcwd_pci.c line 664
signed int pcipcwd_card_init(struct pci_dev$link13 *pdev, const struct pci_device_id *ent)
{
  signed int ret = -5;
  cards_found = cards_found + 1;
  if(cards_found == 1)
    printk("<6>pcwd_pci: PCI-PC Watchdog driver, v1.02 (03 Sep 2005)\n");

  if(cards_found > 1)
  {
    printk("<3>pcwd_pci: This driver only supports 1 device\n");
    return -19;
  }

  signed int return_value_pci_enable_device$1;
  return_value_pci_enable_device$1=pci_enable_device(pdev);
  if(!(return_value_pci_enable_device$1 == 0))
  {
    printk("<3>pcwd_pci: Not possible to enable PCI Device\n");
    return -19;
  }

  /* array.resource lower bound */
  assert((0 + 48 + (signed long int)0 * 32) - POINTER_OFFSET(pdev) >= 0);
  /* array.resource upper bound */
  assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)0 * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
  signed int return_value_pci_request_regions$2;
  signed int return_value_pcipcwd_set_heartbeat$3;
  if(pdev->resource[0l].start == 0ul)
  {
    printk("<3>pcwd_pci: No I/O-Address for card detected\n");
    ret = -19;
  }

  else
  {
    pcipcwd_private.pdev = pdev;
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)0 * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)0 * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    pcipcwd_private.io_addr = pdev->resource[(signed long int)0].start;
    return_value_pci_request_regions$2=pci_request_regions(pdev, "pcwd_pci");
    if(!(return_value_pci_request_regions$2 == 0))
    {
      printk("<3>pcwd_pci: I/O address 0x%04x already in use\n", (signed int)pcipcwd_private.io_addr);
      ret = -5;
    }

    else
    {
      pcipcwd_get_status(&pcipcwd_private.boot_status);
      pcipcwd_clear_status();
      pcipcwd_stop();
      pcipcwd_check_temperature_support();
      pcipcwd_show_card_info();
      return_value_pcipcwd_set_heartbeat$3=pcipcwd_set_heartbeat(heartbeat);
      if(!(return_value_pcipcwd_set_heartbeat$3 == 0))
      {
        pcipcwd_set_heartbeat(2);
        printk("<6>pcwd_pci: heartbeat value must be 0<heartbeat<65536, using %d\n", 2);
      }

      ret=register_reboot_notifier(&pcipcwd_notifier);
      if(!(ret == 0))
        printk("<3>pcwd_pci: cannot register reboot notifier (err=%d)\n", ret);

      else
      {
        if(!(pcipcwd_private.supports_temp == 0))
        {
          ret=misc_register(&pcipcwd_temp_miscdev);
          if(ret == 0)
            goto __CPROVER_DUMP_L8;

          printk("<3>pcwd_pci: cannot register miscdev on minor=%d (err=%d)\n", 131, ret);
        }

        else
        {

        __CPROVER_DUMP_L8:
          ;
          ret=misc_register(&pcipcwd_miscdev);
          if(!(ret == 0))
            printk("<3>pcwd_pci: cannot register miscdev on minor=%d (err=%d)\n", 130, ret);

          else
          {
            printk("<6>pcwd_pci: initialized. heartbeat=%d sec (nowayout=%d)\n", heartbeat, nowayout);
            return 0;
          }

        err_out_misc_deregister:
          ;
          if(!(pcipcwd_private.supports_temp == 0))
            misc_deregister(&pcipcwd_temp_miscdev);

        }

      err_out_unregister_reboot:
        ;
        unregister_reboot_notifier(&pcipcwd_notifier);
      }

    err_out_release_region:
      ;
      pci_release_regions(pdev);
    }
  }

err_out_disable_device:
  ;
  pci_disable_device(pdev);
  return ret;
}

// c::pcipcwd_check_temperature_support
// file pcwd_pci.c line 190
static void pcipcwd_check_temperature_support(void)
{
  unsigned char return_value_inb_p$1;
  return_value_inb_p$1=inb_p((unsigned int)pcipcwd_private.io_addr);
  if(!((signed int)return_value_inb_p$1 == 240))
    pcipcwd_private.supports_temp = 1;

}

// c::pcipcwd_cleanup_module
// file pcwd_pci.c line 798
static void pcipcwd_cleanup_module(void)
{
  pci_unregister_driver(&pcipcwd_driver);
}

// c::pcipcwd_clear_status
// file pcwd_pci.c line 337
static signed int pcipcwd_clear_status(void)
{
  signed int control_status;
  signed int msb;
  signed int reset_counter;
  if(debug >= 1)
    printk("<6>pcwd_pci: clearing watchdog trip status & LED\n");

  unsigned char return_value_inb_p$1;
  return_value_inb_p$1=inb_p((unsigned int)(pcipcwd_private.io_addr + (unsigned long int)1));
  control_status = (signed int)return_value_inb_p$1;
  if(debug >= 2)
  {
    printk("<7>pcwd_pci: status was: 0x%02x\n", control_status);
    printk("<7>pcwd_pci: sending: 0x%02x\n", control_status & 64 | 1);
  }

  outb_p((unsigned char)(control_status & 64 | 1), (unsigned int)(pcipcwd_private.io_addr + (unsigned long int)1));
  msb = 0;
  reset_counter = 255;
  send_command(132, &msb, &reset_counter);
  if(debug >= 2)
    printk("<7>pcwd_pci: reset count was: 0x%02x\n", reset_counter);

  return 0;
}

// c::pcipcwd_get_option_switches
// file pcwd_pci.c line 196
static signed int pcipcwd_get_option_switches(void)
{
  signed int option_switches;
  unsigned char return_value_inb_p$1;
  return_value_inb_p$1=inb_p((unsigned int)(pcipcwd_private.io_addr + (unsigned long int)3));
  option_switches = (signed int)return_value_inb_p$1;
  return option_switches;
}

// c::pcipcwd_get_status
// file pcwd_pci.c line 316
static signed int pcipcwd_get_status(signed int *status)
{
  signed int control_status;
  *status = 0;
  unsigned char return_value_inb_p$1;
  return_value_inb_p$1=inb_p((unsigned int)(pcipcwd_private.io_addr + (unsigned long int)1));
  control_status = (signed int)return_value_inb_p$1;
  if(!((1 & control_status) == 0))
    *status = *status | 32;

  if(!((4 & control_status) == 0))
  {
    *status = *status | 1;
    if(!(temp_panic == 0))
      panic((const void *)"pcwd_pci: Temperature overheat trip!\n");

  }

  if(debug >= 2)
    printk("<7>pcwd_pci: Control Status #1: 0x%02x\n", control_status);

  return 0;
}

// c::pcipcwd_get_temperature
// file pcwd_pci.c line 370
static signed int pcipcwd_get_temperature(signed int *temperature)
{
  *temperature = 0;
  if(pcipcwd_private.supports_temp == 0)
    return -19;

  unsigned char return_value_inb_p$1;
  return_value_inb_p$1=inb_p((unsigned int)pcipcwd_private.io_addr);
  *temperature = (signed int)return_value_inb_p$1;
  *temperature = (*temperature * 9) / 5 + 32;
  if(debug >= 2)
    printk("<7>pcwd_pci: temperature is: %d F\n", *temperature);

  return 0;
}

// c::pcipcwd_get_timeleft
// file pcwd_pci.c line 392
static signed int pcipcwd_get_timeleft(signed int *time_left)
{
  signed int msb;
  signed int lsb;
  send_command(24, &msb, &lsb);
  *time_left = (msb << 8) + lsb;
  if(debug >= 1)
    printk("<7>pcwd_pci: Time left before next reboot: %d\n", *time_left);

  return 0;
}

// c::pcipcwd_init_module
// file pcwd_pci.c line 791
static signed int pcipcwd_init_module(void)
{
  spin_lock_init(&pcipcwd_private.io_lock);
  signed int return_value_pci_register_driver$1;
  return_value_pci_register_driver$1=pci_register_driver(&pcipcwd_driver);
  return return_value_pci_register_driver$1;
}

// c::pcipcwd_ioctl
// file pcwd_pci.c line 442
static signed int pcipcwd_ioctl(struct inode$link4 *inode, struct file$link9 *file, unsigned int cmd, unsigned long int arg)
{
  static struct watchdog_info ident = (struct watchdog_info){ .options=(unsigned int)(1 | 32 | 32768 | 128 | 256), .firmware_version=(unsigned int)1,
    .identity={ 80, 67, 73, 45, 80, 67, 32, 87, 97, 116, 99, 104, 100, 111, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
  void *argp = (void *)arg;
  signed int *p = (signed int *)argp;
  unsigned long int return_value_copy_to_user$1;
  signed int return_value_put_user$3;
  signed int return_value_put_user$11;
  if(!(cmd == 2150127360u))
  {
    if(cmd == 2147768065u)
      goto __CPROVER_DUMP_L2;

    if(cmd == 2147768066u)
      goto __CPROVER_DUMP_L3;

    if(cmd == 2147768067u)
      goto __CPROVER_DUMP_L4;

    if(cmd == 2147768069u)
      goto __CPROVER_DUMP_L6;

    if(cmd == 2147768068u)
      goto __CPROVER_DUMP_L7;

    if(cmd == 3221509894u)
      goto __CPROVER_DUMP_L14;

    if(cmd == 2147768071u)
      goto __CPROVER_DUMP_L17;

    if(cmd == 2147768074u)
      goto __CPROVER_DUMP_L18;

  }

  else
  {
    return_value_copy_to_user$1=copy_to_user(argp, (const void *)&ident, 40ul /*[[struct watchdog_info]]*/);
    return return_value_copy_to_user$1 != 0ul ? -14 : 0;

  __CPROVER_DUMP_L2:
    ;
    signed int status;
    pcipcwd_get_status(&status);
    signed int return_value_put_user$2;
    return_value_put_user$2=put_user(status, (void *)p);
    return return_value_put_user$2;

  __CPROVER_DUMP_L3:
    ;
    return_value_put_user$3=put_user(pcipcwd_private.boot_status, (void *)p);
    return return_value_put_user$3;

  __CPROVER_DUMP_L4:
    ;
    signed int temperature;
    signed int return_value_pcipcwd_get_temperature$4;
    return_value_pcipcwd_get_temperature$4=pcipcwd_get_temperature(&temperature);
    if(!(return_value_pcipcwd_get_temperature$4 == 0))
      return -14;

    signed int return_value_put_user$5;
    return_value_put_user$5=put_user(temperature, (void *)p);
    return return_value_put_user$5;

  __CPROVER_DUMP_L6:
    ;
    pcipcwd_keepalive();
    return 0;

  __CPROVER_DUMP_L7:
    ;
    signed int new_options;
    signed int retval = -22;
    signed int return_value_get_user$6;
    return_value_get_user$6=get_user(new_options, (void *)p);
    if(!(return_value_get_user$6 == 0))
      return -14;

    if(!((1 & new_options) == 0))
    {
      signed int return_value_pcipcwd_stop$7;
      return_value_pcipcwd_stop$7=pcipcwd_stop();
      if(!(return_value_pcipcwd_stop$7 == 0))
        return -5;

      retval = 0;
    }

    if(!((2 & new_options) == 0))
    {
      signed int return_value_pcipcwd_start$8;
      return_value_pcipcwd_start$8=pcipcwd_start();
      if(!(return_value_pcipcwd_start$8 == 0))
        return -5;

      retval = 0;
    }

    if(!((4 & new_options) == 0))
    {
      temp_panic = 1;
      retval = 0;
    }

    return retval;

  __CPROVER_DUMP_L14:
    ;
    signed int new_heartbeat;
    signed int return_value_get_user$9;
    return_value_get_user$9=get_user(new_heartbeat, (void *)p);
    if(!(return_value_get_user$9 == 0))
      return -14;

    signed int return_value_pcipcwd_set_heartbeat$10;
    return_value_pcipcwd_set_heartbeat$10=pcipcwd_set_heartbeat(new_heartbeat);
    if(!(return_value_pcipcwd_set_heartbeat$10 == 0))
      return -22;

    pcipcwd_keepalive();

  __CPROVER_DUMP_L17:
    ;
    return_value_put_user$11=put_user(heartbeat, (void *)p);
    return return_value_put_user$11;

  __CPROVER_DUMP_L18:
    ;
    signed int time_left;
    signed int return_value_pcipcwd_get_timeleft$12;
    return_value_pcipcwd_get_timeleft$12=pcipcwd_get_timeleft(&time_left);
    if(!(return_value_pcipcwd_get_timeleft$12 == 0))
      return -14;

    signed int return_value_put_user$13;
    return_value_put_user$13=put_user(time_left, (void *)p);
    return return_value_put_user$13;
  }
  return -25;
}

// c::pcipcwd_keepalive
// file pcwd_pci.c line 286
static signed int pcipcwd_keepalive(void)
{
  outb_p((unsigned char)66, (unsigned int)pcipcwd_private.io_addr);
  if(debug >= 2)
    printk("<7>pcwd_pci: Watchdog keepalive signal send\n");

  return 0;
}

// c::pcipcwd_notify_sys
// file pcwd_pci.c line 613
static signed int pcipcwd_notify_sys(struct notifier_block *this, unsigned long int code, void *unused)
{
  if(!(code == 1ul))
  {
    if(code == 2ul)
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    pcipcwd_stop();
  }
  return 0;
}

// c::pcipcwd_open
// file pcwd_pci.c line 547
static signed int pcipcwd_open(struct inode$link4 *inode, struct file$link9 *file)
{
  signed int return_value_test_and_set_bit$1;
  return_value_test_and_set_bit$1=test_and_set_bit(0, &is_active);
  if(!(return_value_test_and_set_bit$1 == 0))
  {
    if(debug >= 1)
      printk("<3>pcwd_pci: Attempt to open already opened device.\n");

    return -16;
  }

  pcipcwd_start();
  pcipcwd_keepalive();
  signed int return_value_nonseekable_open$2;
  return_value_nonseekable_open$2=nonseekable_open(inode, file);
  return return_value_nonseekable_open$2;
}

// c::pcipcwd_release
// file pcwd_pci.c line 562
static signed int pcipcwd_release(struct inode$link4 *inode, struct file$link9 *file)
{
  if((signed int)expect_release == 42)
    pcipcwd_stop();

  else
  {
    printk("<2>pcwd_pci: Unexpected close, not stopping watchdog!\n");
    pcipcwd_keepalive();
  }
  expect_release = (char)0;
  clear_bit(0, &is_active);
  return 0;
}

// c::pcipcwd_set_heartbeat
// file pcwd_pci.c line 297
static signed int pcipcwd_set_heartbeat(signed int t)
{
  signed int t_msb = t / 256;
  signed int t_lsb = t % 256;
  if(!(t < 1))
  {
    if(t > 65535)
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return -22;
  }
  send_command(25, &t_msb, &t_lsb);
  heartbeat = t;
  if(debug >= 1)
    printk("<7>pcwd_pci: New heartbeat: %d\n", heartbeat);

  return 0;
}

// c::pcipcwd_show_card_info
// file pcwd_pci.c line 204
static void pcipcwd_show_card_info(void)
{
  signed int got_fw_rev;
  signed int fw_rev_major;
  signed int fw_rev_minor;
  char fw_ver_str[20l];
  signed int option_switches;
  got_fw_rev=send_command(8, &fw_rev_major, &fw_rev_minor);
  if(!(got_fw_rev == 0))
    sprintf(fw_ver_str, "%u.%02u", fw_rev_major, fw_rev_minor);

  else
    sprintf(fw_ver_str, "<card no answer>");
  option_switches=pcipcwd_get_option_switches();
  printk("<6>pcwd_pci: Found card at port 0x%04x (Firmware: %s) %s temp option\n", (signed int)pcipcwd_private.io_addr, (const void *)fw_ver_str, pcipcwd_private.supports_temp != 0 ? "with" : "without");
  printk("<6>pcwd_pci: Option switches (0x%02x): Temperature Reset Enable=%s, Power On Delay=%s\n", option_switches, (option_switches & 16) != 0 ? "ON" : "OFF", (option_switches & 8) != 0 ? "ON" : "OFF");
  if(!((32 & pcipcwd_private.boot_status) == 0))
    printk("<6>pcwd_pci: Previous reset was caused by the Watchdog card\n");

  if(!((1 & pcipcwd_private.boot_status) == 0))
    printk("<6>pcwd_pci: Card sensed a CPU Overheat\n");

  if(pcipcwd_private.boot_status == 0)
    printk("<6>pcwd_pci: No previous trip detected - Cold boot or reset\n");

}

// c::pcipcwd_start
// file pcwd_pci.c line 239
static signed int pcipcwd_start(void)
{
  signed int stat_reg;
  spin_lock(&pcipcwd_private.io_lock);
  outb_p((unsigned char)0, (unsigned int)(pcipcwd_private.io_addr + (unsigned long int)3));
  udelay(1000);
  unsigned char return_value_inb_p$1;
  return_value_inb_p$1=inb_p((unsigned int)(pcipcwd_private.io_addr + (unsigned long int)2));
  stat_reg = (signed int)return_value_inb_p$1;
  spin_unlock(&pcipcwd_private.io_lock);
  if(!((16 & stat_reg) == 0))
  {
    printk("<3>pcwd_pci: Card timer not enabled\n");
    return -1;
  }

  if(debug >= 1)
    printk("<7>pcwd_pci: Watchdog started\n");

  return 0;
}

// c::pcipcwd_stop
// file pcwd_pci.c line 261
static signed int pcipcwd_stop(void)
{
  signed int stat_reg;
  spin_lock(&pcipcwd_private.io_lock);
  outb_p((unsigned char)165, (unsigned int)(pcipcwd_private.io_addr + (unsigned long int)3));
  udelay(1000);
  outb_p((unsigned char)165, (unsigned int)(pcipcwd_private.io_addr + (unsigned long int)3));
  udelay(1000);
  unsigned char return_value_inb_p$1;
  return_value_inb_p$1=inb_p((unsigned int)(pcipcwd_private.io_addr + (unsigned long int)2));
  stat_reg = (signed int)return_value_inb_p$1;
  spin_unlock(&pcipcwd_private.io_lock);
  if((16 & stat_reg) == 0)
  {
    printk("<3>pcwd_pci: Card did not acknowledge disable attempt\n");
    return -1;
  }

  if(debug >= 1)
    printk("<7>pcwd_pci: Watchdog stopped\n");

  return 0;
}

// c::pcipcwd_temp_open
// file pcwd_pci.c line 596
static signed int pcipcwd_temp_open(struct inode$link4 *inode, struct file$link9 *file)
{
  if(pcipcwd_private.supports_temp == 0)
    return -19;

  signed int return_value_nonseekable_open$1;
  return_value_nonseekable_open$1=nonseekable_open(inode, file);
  return return_value_nonseekable_open$1;
}

// c::pcipcwd_temp_read
// file pcwd_pci.c line 582
static signed int pcipcwd_temp_read(struct file$link9 *file, char *data, unsigned int len, signed long long int *ppos)
{
  signed int temperature;
  signed int return_value_pcipcwd_get_temperature$1;
  return_value_pcipcwd_get_temperature$1=pcipcwd_get_temperature(&temperature);
  if(!(return_value_pcipcwd_get_temperature$1 == 0))
    return -14;

  unsigned long int return_value_copy_to_user$2;
  return_value_copy_to_user$2=copy_to_user((void *)data, (const void *)&temperature, (unsigned long int)1);
  if(!(return_value_copy_to_user$2 == 0ul))
    return -14;

  return 1;
}

// c::pcipcwd_temp_release
// file pcwd_pci.c line 604
static signed int pcipcwd_temp_release(struct inode$link4 *inode, struct file$link9 *file)
{
  return 0;
}

// c::pcipcwd_write
// file pcwd_pci.c line 414
static signed int pcipcwd_write(struct file$link9 *file, const char *data, unsigned int len, signed long long int *ppos)
{
  if(!(len == 0u))
  {
    if(nowayout == 0)
    {
      unsigned int i;
      expect_release = (char)0;
      i = (unsigned int)0;
      while(!(i == len))
      {
        char c;
        signed int return_value_get_user$1;
        return_value_get_user$1=get_user((signed int)c, (void *)(data + (signed long int)i));
        if(!(return_value_get_user$1 == 0))
          return -14;

        if((signed int)c == 86)
          expect_release = (char)42;

        i = i + 1u;
      }
    }

    pcipcwd_keepalive();
  }

  return (signed int)len;
}

// c::pthread_create
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 59
signed int pthread_create(struct __pthread_t_struct *__threadp, const struct __pthread_attr_t_struct *__attr, void * (*__start_routine)(void *), void *__arg)
{

__CPROVER_HIDE:
  ;
  *__threadp = nondet_pthread_t();

CPROVER_ASYNC_1:
  ;
  __start_routine(__arg);
  return 0;
}

// c::pthread_mutex_destroy
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 194
signed int pthread_mutex_destroy(struct __pthread_mutex_t_struct *__mutex)
{
  return nondet_int();
}

// c::pthread_mutex_init
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 186
signed int pthread_mutex_init(struct __pthread_mutex_t_struct *__mutex, const struct __pthread_mutexattr_t_struct *__mutex_attr)
{
  struct __pthread_mutex_t_struct i = (struct __pthread_mutex_t_struct){ .locked=0 != 0 };
  *__mutex = i;
  return nondet_int();
}

// c::pthread_mutex_lock
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 203
signed int pthread_mutex_lock(struct __pthread_mutex_t_struct *__mutex)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  __CPROVER_assume(!(__mutex->locked != FALSE));
  __mutex->locked = 1 != 0;
  __CPROVER_atomic_end();
  return 0;
}

// c::pthread_mutex_unlock
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 213
signed int pthread_mutex_unlock(struct __pthread_mutex_t_struct *__mutex)
{
/* pthread_mutex_unlock without lock */

__CPROVER_HIDE:
  ;
  /* pthread_mutex_unlock without lock */
  assert(__mutex->locked != FALSE);
  __mutex->locked = 0 != 0;
  return 0;
}

// c::put_user
// file /usr/local/ddv/models/con2/include/asm/uaccess.h line 48
signed int put_user(signed int size, void *ptr)
{

__CPROVER_HIDE:
  ;
  assert_context_process$link24();
  signed int return_value_nondet_int$1 = nondet_int();
  return return_value_nondet_int$1;
}

// c::register_blkdev
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 6
signed int register_blkdev(unsigned int major, const char *name)
{
  signed int result = nondet_int();
  return result;
}

// c::register_chrdev
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 33
signed int register_chrdev(unsigned int major, const char *name, struct file_operations$link4 *fops)
{
  struct cdev$link0 *cdev;
  signed int err;
  signed int return_value_register_chrdev_region$1;
  return_value_register_chrdev_region$1=register_chrdev_region((unsigned int)0, (unsigned int)256, name);
  major = (unsigned int)return_value_register_chrdev_region$1;
  cdev=cdev_alloc();
  cdev->owner = fops->owner;
  cdev->ops = fops;
  err=cdev_add(cdev, major << 20 | (unsigned int)0, (unsigned int)256);
  if(!(err == 0))
  {
    kfree((const void *)cdev);
    return err;
  }

  return (signed int)major;
}

// c::register_chrdev_region
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 23
signed int register_chrdev_region(unsigned int from, unsigned int count, const char *name)
{
  signed int return_value = nondet_int();
  __CPROVER_assume(return_value == 0 || return_value == -1);
  return return_value;
}

// c::release_region
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 92
void release_region(unsigned long int start, unsigned long int len)
{
  unsigned int i = (unsigned int)0;
  ddv_ioport_request_start = 0;
  ddv_ioport_request_len = 0;
}

// c::request_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c line 4
signed int request_irq(unsigned int irq, signed int (*handler)(signed int, void *, struct pt_regs *), unsigned long int irqflags, const char *devname, void *dev_id)
{
  signed int return_value_nondet_int$1 = nondet_int();
  if(!(return_value_nondet_int$1 == 0))
  {
    /* array `registered_irq' upper bound */
    assert((signed long int)irq < 16l);
    registered_irq[(signed long int)irq].handler = handler;
    registered_irq[(signed long int)irq].dev_id = dev_id;
    return 0;
  }

  else
    return -1;
}

// c::request_region
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 90
struct resource * request_region(unsigned long int start, unsigned long int len, const char *name)
{
  unsigned int i;
  struct resource *resource;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned int)32ul /*[[struct resource]]*/);
  resource = (struct resource *)return_value_malloc$1;
  ddv_ioport_request_start = (signed int)start;
  ddv_ioport_request_len = (signed int)len;
  return resource;
}

// c::schedule
// file /usr/local/ddv/models/con2/src/linux/kernel/sched.c line 8
void schedule(void)
{
  assert_context_process$link14();
}

// c::schedule_timeout
// file /usr/local/ddv/models/con2/src/linux/kernel/sched.c line 13
signed long int schedule_timeout(signed long int timeout)
{
  assert_context_process$link14();
  signed long int return_value_nondet_long$1 = nondet_loff_t();
  return return_value_nondet_long$1;
}

// c::schedule_work
// file /usr/local/ddv/models/con2/src/linux/kernel/workqueue.c line 5
signed int schedule_work(struct work_struct *work)
{
  signed int i = 0;
  while(i < 10)
  {
    /* array `shared_workqueue' lower bound */
    assert(0 + (signed long int)i * 8 >= 0);
    /* array `shared_workqueue' upper bound */
    assert((signed long int)i < 10l);
    if(shared_workqueue[(signed long int)i] == work)
      return 0;

    /* array `shared_workqueue' lower bound */
    assert(0 + (signed long int)i * 8 >= 0);
    /* array `shared_workqueue' upper bound */
    assert((signed long int)i < 10l);
    if(shared_workqueue[(signed long int)i] == ((struct work_struct *)NULL))
    {
      shared_workqueue[(signed long int)i] = work;
      return 1;
    }

    i = i + 1;
  }
  return -1;
}

// c::sema_init
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 6
void sema_init(struct semaphore *sem, signed int val)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  sem->init = 1;
  sem->locked = 0;
  __CPROVER_atomic_end();
}

// c::send_command
// file pcwd_pci.c line 135
static signed int send_command(signed int cmd, signed int *msb, signed int *lsb)
{
  signed int got_response;
  signed int count;
  if(debug >= 2)
    printk("<7>pcwd_pci: sending following data cmd=0x%02x msb=0x%02x lsb=0x%02x\n", cmd, *msb, *lsb);

  spin_lock(&pcipcwd_private.io_lock);
  outb_p((unsigned char)*lsb, (unsigned int)(pcipcwd_private.io_addr + (unsigned long int)4));
  outb_p((unsigned char)*msb, (unsigned int)(pcipcwd_private.io_addr + (unsigned long int)5));
  outb_p((unsigned char)cmd, (unsigned int)(pcipcwd_private.io_addr + (unsigned long int)6));
  unsigned char return_value_inb_p$1;
  return_value_inb_p$1=inb_p((unsigned int)(pcipcwd_private.io_addr + (unsigned long int)2));
  got_response = (signed int)return_value_inb_p$1 & 64;
  count = 0;
  while(count < 150 && got_response == 0)
  {

  __CPROVER_DUMP_L3:
    ;
    unsigned char return_value_inb_p$2;
    return_value_inb_p$2=inb_p((unsigned int)(pcipcwd_private.io_addr + (unsigned long int)2));
    got_response = (signed int)return_value_inb_p$2 & 64;
    count = count + 1;
  }
  if(debug >= 2)
  {
    if(!(got_response == 0))
      printk("<7>pcwd_pci: time to process command was: %d ms\n", count);

    else
      printk("<7>pcwd_pci: card did not respond on command!\n");
  }

  if(!(got_response == 0))
  {
    unsigned char return_value_inb_p$3;
    return_value_inb_p$3=inb_p((unsigned int)(pcipcwd_private.io_addr + (unsigned long int)4));
    *lsb = (signed int)return_value_inb_p$3;
    unsigned char return_value_inb_p$4;
    return_value_inb_p$4=inb_p((unsigned int)(pcipcwd_private.io_addr + (unsigned long int)5));
    *msb = (signed int)return_value_inb_p$4;
    inb_p((unsigned int)(pcipcwd_private.io_addr + (unsigned long int)6));
    if(debug >= 2)
      printk("<7>pcwd_pci: received following data for cmd=0x%02x: msb=0x%02x lsb=0x%02x\n", cmd, *msb, *lsb);

  }

  spin_unlock(&pcipcwd_private.io_lock);
  return got_response;
}

// c::sleep_on
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 32
void sleep_on(struct __wait_queue_head *q)
{
  ;
}

// c::spin_lock
// file /usr/local/ddv/models/con2/include/linux/spinlock.h line 10
void spin_lock(struct anon$0 *lock)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(lock->locked == 0)
    {
      lock->locked = 1;
      __CPROVER_atomic_end();
      return;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
}

// c::spin_lock_bh
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 82
void spin_lock_bh(struct anon$0 *lock)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(lock->locked == 0)
    {
      lock->locked = 1;
      __CPROVER_atomic_end();
      return;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
}

// c::spin_lock_init
// file /usr/local/ddv/models/con2/include/linux/spinlock.h line 9
void spin_lock_init(struct anon$0 *lock)
{
  lock->init = 1;
  lock->locked = 0;
}

// c::spin_lock_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 58
void spin_lock_irq(struct anon$0 *lock)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(lock->locked == 0)
    {
      lock->locked = 1;
      __CPROVER_atomic_end();
      return;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
}

// c::spin_lock_irqsave
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 34
void spin_lock_irqsave(struct anon$0 *lock, unsigned long int flags)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(lock->locked == 0)
    {
      lock->locked = 1;
      __CPROVER_atomic_end();
      return;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
}

// c::spin_unlock
// file /usr/local/ddv/models/con2/include/linux/spinlock.h line 15
void spin_unlock(struct anon$0 *lock)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  lock->locked = 0;
  __CPROVER_atomic_end();
}

// c::spin_unlock_bh
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 139
void spin_unlock_bh(struct anon$0 *lock)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  lock->locked = 0;
  __CPROVER_atomic_end();
}

// c::spin_unlock_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 128
void spin_unlock_irq(struct anon$0 *lock)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  lock->locked = 0;
  __CPROVER_atomic_end();
}

// c::spin_unlock_irqrestore
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 117
void spin_unlock_irqrestore(struct anon$0 *lock, unsigned long int flags)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  lock->locked = 0;
  __CPROVER_atomic_end();
}

// c::tasklet_init
// file /usr/local/ddv/models/con2/src/linux/kernel/softirq.c line 32
void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long int), unsigned long int data)
{
  t->count = 0;
  t->init = 0;
  t->func = func;
  t->data = data;
}

// c::tasklet_schedule
// file /usr/local/ddv/models/con2/src/linux/kernel/softirq.c line 4
void tasklet_schedule(struct tasklet_struct *t)
{
  signed int i;
  signed int next_free = -1;
  i = 0;
  while(i < 10)
  {
    /* array `tasklet_registered' lower bound */
    assert(0 + (signed long int)i * 16 >= 0);
    /* array `tasklet_registered' upper bound */
    assert((signed long int)i < 10l);
    if(tasklet_registered[(signed long int)i].tasklet == ((struct tasklet_struct *)NULL))
      next_free = i;

    /* array `tasklet_registered' lower bound */
    assert(0 + (signed long int)i * 16 >= 0);
    /* array `tasklet_registered' upper bound */
    assert((signed long int)i < 10l);
    if(tasklet_registered[(signed long int)i].tasklet == t)
    {
      if((signed int)tasklet_registered[(signed long int)i].is_running == 0)
        return;

    }

    i = i + 1;
  }
  /* array `tasklet_registered' lower bound */
  assert(0 + (signed long int)next_free * 16 >= 0);
  /* array `tasklet_registered' upper bound */
  assert((signed long int)next_free < 10l);
  tasklet_registered[(signed long int)next_free].tasklet = t;
  tasklet_registered[(signed long int)next_free].is_running = (unsigned short int)0;
}

// c::tty_set_operations
// file /usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c line 14
void tty_set_operations(struct tty_driver *driver, const struct tty_operations *op)
{
  driver->open = op->open;
  driver->close = op->close;
  driver->write = op->write;
  driver->put_char = op->put_char;
  driver->flush_chars = op->flush_chars;
  driver->write_room = op->write_room;
  driver->chars_in_buffer = op->chars_in_buffer;
  driver->ioctl = op->ioctl;
  driver->set_termios = op->set_termios;
  driver->throttle = op->throttle;
  driver->unthrottle = op->unthrottle;
  driver->stop = op->stop;
  driver->start = op->start;
  driver->hangup = op->hangup;
  driver->break_ctl = op->break_ctl;
  driver->flush_buffer = op->flush_buffer;
  driver->set_ldisc = op->set_ldisc;
  driver->wait_until_sent = op->wait_until_sent;
  driver->send_xchar = op->send_xchar;
  driver->read_proc = op->read_proc;
  driver->write_proc = op->write_proc;
  driver->tiocmget = op->tiocmget;
  driver->tiocmset = op->tiocmset;
}

// c::unregister_blkdev
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 17
signed int unregister_blkdev(unsigned int major, const char *name)
{
  return 0;
}

// c::unregister_chrdev
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 55
signed int unregister_chrdev(unsigned int major, const char *name)
{
  return 0;
}

// c::up
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 106
void up(struct semaphore *sem)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  assert_context_process$link15();
  sem->locked = 0;
  __CPROVER_atomic_end();
}

// c::vmalloc
// file /usr/local/ddv/models/con2/src/linux/mm/vmalloc.c line 6
void * vmalloc(unsigned long int size)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned int)size);
  return return_value_malloc$1;
}

// c::wake_up
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 8
void wake_up(struct __wait_queue_head *q)
{
  ;
}

// c::wake_up_all
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 16
void wake_up_all(struct __wait_queue_head *q)
{
  ;
}

// c::wake_up_interruptible
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 24
void wake_up_interruptible(struct __wait_queue_head *q)
{
  ;
}

