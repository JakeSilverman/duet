// c::tag-#anon#ST[S32'init'||S32'locked'|]
// 
struct anon$1;

// c::tag-#anon#ST[U32'written'||U32'count'|]
// 
struct anon$0;

// c::tag-__pthread_attr_t_struct
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 49
struct __pthread_attr_t_struct;

// c::tag-__pthread_mutex_t_struct
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 25
struct __pthread_mutex_t_struct;

// c::tag-__pthread_mutexattr_t_struct
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 30
struct __pthread_mutexattr_t_struct;

// c::tag-__pthread_t_struct
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 44
struct __pthread_t_struct;

// c::tag-__wait_queue_head
// file /usr/local/ddv/models/con2/include/linux/wait.h line 16
struct __wait_queue_head;

// c::tag-address_space
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space;

// c::tag-address_space$link10
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link10;

// c::tag-address_space$link11
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link11;

// c::tag-address_space$link14
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link14;

// c::tag-address_space$link3
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link3;

// c::tag-address_space$link7
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link7;

// c::tag-address_space$link8
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link8;

// c::tag-address_space$link9
// file /usr/local/ddv/models/con2/include/linux/fs.h line 90
struct address_space$link9;

// c::tag-backing_dev_info
// file /usr/local/ddv/models/con2/include/linux/backing-dev.h line 11
struct backing_dev_info;

// c::tag-bio
// file /usr/local/ddv/models/con2/include/linux/bio.h line 17
struct bio;

// c::tag-bio$link14
// file /usr/local/ddv/models/con2/include/linux/bio.h line 17
struct bio$link14;

// c::tag-bio$link9
// file /usr/local/ddv/models/con2/include/linux/bio.h line 17
struct bio$link9;

// c::tag-bio_vec
// file /usr/local/ddv/models/con2/include/linux/bio.h line 6
struct bio_vec;

// c::tag-block_device
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device;

// c::tag-block_device$link0
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link0;

// c::tag-block_device$link1
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link1;

// c::tag-block_device$link2
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link2;

// c::tag-block_device$link3
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link3;

// c::tag-block_device$link4
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link4;

// c::tag-block_device$link5
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link5;

// c::tag-block_device$link6
// file /usr/local/ddv/models/con2/include/linux/fs.h line 105
struct block_device$link6;

// c::tag-block_device_operations
// file /usr/local/ddv/models/con2/include/linux/fs.h line 168
struct block_device_operations;

// c::tag-block_device_operations$link13
// file /usr/local/ddv/models/con2/include/linux/fs.h line 168
struct block_device_operations$link13;

// c::tag-block_device_operations$link7
// file /usr/local/ddv/models/con2/include/linux/fs.h line 168
struct block_device_operations$link7;

// c::tag-cdev
// file /usr/local/ddv/models/con2/include/linux/cdev.h line 4
struct cdev;

// c::tag-cdev$link0
// file /usr/local/ddv/models/con2/include/linux/cdev.h line 4
struct cdev$link0;

// c::tag-cdev$link1
// file /usr/local/ddv/models/con2/include/linux/cdev.h line 4
struct cdev$link1;

// c::tag-cdev$link2
// file /usr/local/ddv/models/con2/include/linux/cdev.h line 4
struct cdev$link2;

// c::tag-cdev$link3
// file /usr/local/ddv/models/con2/include/linux/cdev.h line 4
struct cdev$link3;

// c::tag-ddv_cdev
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 13
struct ddv_cdev;

// c::tag-ddv_cdev$link11
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 13
struct ddv_cdev$link11;

// c::tag-ddv_cdev$link15
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 13
struct ddv_cdev$link15;

// c::tag-ddv_cdev$link7
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 13
struct ddv_cdev$link7;

// c::tag-ddv_genhd
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 15
struct ddv_genhd;

// c::tag-ddv_genhd$link19
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 15
struct ddv_genhd$link19;

// c::tag-ddv_genhd$link20
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 15
struct ddv_genhd$link20;

// c::tag-ddv_pci_driver
// file /usr/local/ddv/models/con2/include/ddverify/pci.h line 6
struct ddv_pci_driver;

// c::tag-ddv_pci_driver$link3
// file /usr/local/ddv/models/con2/include/ddverify/pci.h line 6
struct ddv_pci_driver$link3;

// c::tag-ddv_tasklet
// file /usr/local/ddv/models/con2/include/ddverify/tasklet.h line 10
struct ddv_tasklet;

// c::tag-ddv_timer
// file /usr/local/ddv/models/con2/include/ddverify/timer.h line 10
struct ddv_timer;

// c::tag-ddv_tty_driver
// file /usr/local/ddv/models/con2/include/ddverify/tty.h line 7
struct ddv_tty_driver;

// c::tag-dentry
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry;

// c::tag-dentry$link10
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link10;

// c::tag-dentry$link11
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link11;

// c::tag-dentry$link12
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link12;

// c::tag-dentry$link15
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link15;

// c::tag-dentry$link4
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link4;

// c::tag-dentry$link8
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link8;

// c::tag-dentry$link9
// file /usr/local/ddv/models/con2/include/linux/dcache.h line 4
struct dentry$link9;

// c::tag-device
// file /usr/local/ddv/models/con2/include/linux/device.h line 25
struct device;

// c::tag-device$link0
// file /usr/local/ddv/models/con2/include/linux/device.h line 25
struct device$link0;

// c::tag-device$link11
// file /usr/local/ddv/models/con2/include/linux/device.h line 25
struct device$link11;

// c::tag-device$link14
// file /usr/local/ddv/models/con2/include/linux/device.h line 25
struct device$link14;

// c::tag-device$link16
// file /usr/local/ddv/models/con2/include/linux/device.h line 25
struct device$link16;

// c::tag-file
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file;

// c::tag-file$link13
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link13;

// c::tag-file$link14
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link14;

// c::tag-file$link15
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link15;

// c::tag-file$link16
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link16;

// c::tag-file$link5
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link5;

// c::tag-file$link6
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link6;

// c::tag-file$link9
// file /usr/local/ddv/models/con2/include/linux/fs.h line 94
struct file$link9;

// c::tag-file_lock
// file /usr/local/ddv/models/con2/include/linux/fs.h line 130
struct file_lock;

// c::tag-file_operations
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations;

// c::tag-file_operations$link10
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link10;

// c::tag-file_operations$link11
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link11;

// c::tag-file_operations$link12
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link12;

// c::tag-file_operations$link13
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link13;

// c::tag-file_operations$link14
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link14;

// c::tag-file_operations$link17
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link17;

// c::tag-file_operations$link5
// file /usr/local/ddv/models/con2/include/linux/fs.h line 134
struct file_operations$link5;

// c::tag-gendisk
// file /usr/local/ddv/models/con2/include/linux/fs.h line 107
struct gendisk;

// c::tag-gendisk$link12
// file /usr/local/ddv/models/con2/include/linux/genhd.h line 17
struct gendisk$link12;

// c::tag-gendisk$link13
// file /usr/local/ddv/models/con2/include/linux/genhd.h line 17
struct gendisk$link13;

// c::tag-hd_geometry
// file /usr/local/ddv/models/con2/include/linux/fs.h line 82
struct hd_geometry;

// c::tag-inode
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode;

// c::tag-inode$link2
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link2;

// c::tag-inode$link3
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link3;

// c::tag-inode$link5
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link5;

// c::tag-inode$link6
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link6;

// c::tag-inode$link7
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link7;

// c::tag-inode$link8
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link8;

// c::tag-inode$link9
// file /usr/local/ddv/models/con2/include/linux/fs.h line 113
struct inode$link9;

// c::tag-iovec
// file /usr/local/ddv/models/con2/include/linux/fs.h line 83
struct iovec;

// c::tag-list_head
// file /usr/local/ddv/models/con2/include/linux/list.h line 9
struct list_head;

// c::tag-list_head$link0
// file /usr/local/ddv/models/con2/include/linux/list.h line 9
struct list_head$link0;

// c::tag-list_head$link18
// file /usr/local/ddv/models/con2/include/linux/list.h line 9
struct list_head$link18;

// c::tag-miscdevice
// file /usr/local/ddv/models/con2/include/linux/miscdevice.h line 34
struct miscdevice;

// c::tag-miscdevice$link16
// file /usr/local/ddv/models/con2/include/linux/miscdevice.h line 34
struct miscdevice$link16;

// c::tag-module
// file /usr/local/ddv/models/con2/include/linux/fs.h line 135
struct module;

// c::tag-mutex
// file /usr/local/ddv/models/con2/include/linux/mutex.h line 20
struct mutex;

// c::tag-notifier_block
// file /usr/local/ddv/models/con2/include/linux/notifier.h line 15
struct notifier_block;

// c::tag-page
// file /usr/local/ddv/models/con2/include/linux/gfp.h line 67
struct page;

// c::tag-pci_bus
// file /usr/local/ddv/models/con2/include/linux/pci.h line 62
struct pci_bus;

// c::tag-pci_dev
// file /usr/local/ddv/models/con2/include/linux/pci.h line 43
struct pci_dev;

// c::tag-pci_dev$link1
// file /usr/local/ddv/models/con2/include/linux/pci.h line 43
struct pci_dev$link1;

// c::tag-pci_dev$link15
// file /usr/local/ddv/models/con2/include/linux/pci.h line 43
struct pci_dev$link15;

// c::tag-pci_device_id
// file /usr/local/ddv/models/con2/include/linux/mod_devicetable.h line 10
struct pci_device_id;

// c::tag-pci_driver
// file /usr/local/ddv/models/con2/include/linux/pci.h line 67
struct pci_driver;

// c::tag-pci_driver$link2
// file /usr/local/ddv/models/con2/include/linux/pci.h line 67
struct pci_driver$link2;

// c::tag-pm_message
// file /usr/local/ddv/models/con2/include/linux/pm.h line 8
struct pm_message;

// c::tag-poll_table_struct
// file /usr/local/ddv/models/con2/include/linux/fs.h line 84
struct poll_table_struct;

// c::tag-proc_dir_entry
// file /usr/local/ddv/models/con2/include/linux/proc_fs.h line 7
struct proc_dir_entry;

// c::tag-pt_regs
// file /usr/local/ddv/models/con2/include/asm/ptrace.h line 4
struct pt_regs;

// c::tag-registered_irq
// file /usr/local/ddv/models/con2/include/ddverify/interrupt.h line 9
struct registered_irq;

// c::tag-request
// file /usr/local/ddv/models/con2/include/linux/blkdev.h line 90
struct request;

// c::tag-request$link18
// file /usr/local/ddv/models/con2/include/linux/blkdev.h line 90
struct request$link18;

// c::tag-request$link19
// file /usr/local/ddv/models/con2/include/linux/blkdev.h line 90
struct request$link19;

// c::tag-request_queue
// file /usr/local/ddv/models/con2/include/linux/blkdev.h line 54
struct request_queue;

// c::tag-request_queue$link10
// file /usr/local/ddv/models/con2/include/linux/blkdev.h line 54
struct request_queue$link10;

// c::tag-request_queue$link15
// file /usr/local/ddv/models/con2/include/linux/blkdev.h line 54
struct request_queue$link15;

// c::tag-resource
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 18
struct resource;

// c::tag-semaphore
// file /usr/local/ddv/models/con2/include/asm/semaphore.h line 4
struct semaphore;

// c::tag-tasklet_struct
// file /usr/local/ddv/models/con2/include/linux/interrupt.h line 34
struct tasklet_struct;

// c::tag-termios
// file /usr/local/ddv/models/con2/include/asm/termbits.h line 11
struct termios;

// c::tag-timer_list
// file /usr/local/ddv/models/con2/include/linux/timer.h line 4
struct timer_list;

// c::tag-tty_driver
// file /usr/local/ddv/models/con2/include/linux/tty_driver.h line 43
struct tty_driver;

// c::tag-tty_operations
// file /usr/local/ddv/models/con2/include/linux/tty_driver.h line 12
struct tty_operations;

// c::tag-tty_struct
// file /usr/local/ddv/models/con2/include/linux/tty.h line 113
struct tty_struct;

// c::tag-vm_area_struct
// file /usr/local/ddv/models/con2/include/linux/fs.h line 85
struct vm_area_struct;

// c::tag-watchdog_info
// file /usr/local/ddv/models/con2/include/linux/watchdog.h line 9
struct watchdog_info;

// c::tag-work_struct
// file /usr/local/ddv/models/con2/include/linux/workqueue.h line 12
struct work_struct;


#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif

// c::__get_free_page
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 13
unsigned long int __get_free_page(unsigned int gfp_mask);
// c::__get_free_pages
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 5
unsigned long int __get_free_pages(unsigned int gfp_mask, unsigned int order);
// c::__get_user
// file /usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c line 5
signed int __get_user(signed int size, void *ptr);
// c::__put_user
// file /usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c line 21
signed int __put_user(signed int size, void *ptr);
// c::_ddv_module_exit$object
// 
void _ddv_module_exit$object(void);
// c::_ddv_module_init$object
// 
signed int _ddv_module_init$object(void);
// c::_ddv_tmp_exit$object
// 
void _ddv_tmp_exit$object(void);
// c::_ddv_tmp_init$object
// 
signed int _ddv_tmp_init$object(void);
// c::add_disk
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 38
void add_disk(struct gendisk$link12 *disk);
// c::add_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 15
void add_timer(struct timer_list *timer);
// c::add_timer_on
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 24
void add_timer_on(struct timer_list *timer, signed int cpu);
// c::alloc_chrdev_region
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 9
signed int alloc_chrdev_region(unsigned int *dev, unsigned int baseminor, unsigned int count, const char *name);
// c::alloc_disk
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 22
struct gendisk$link12 * alloc_disk(signed int minors);
// c::alloc_page
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 46
struct page * alloc_page(unsigned int gfp_mask);
// c::alloc_pages
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 38
struct page * alloc_pages(unsigned int gfp_mask, unsigned int order);
// c::alloc_tty_driver
// file /usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c line 4
struct tty_driver * alloc_tty_driver(signed int lines);
// c::assert_context_process
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process();
// c::assert_context_process$link0
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link0();
// c::assert_context_process$link1
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link1();
// c::assert_context_process$link2
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link2();
// c::assert_context_process$link3
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link3();
// c::assert_context_process$link4
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link4();
// c::blk_alloc_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 34
struct request_queue$link10 * blk_alloc_queue(unsigned int gfp_mask);
// c::blk_cleanup_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 69
void blk_cleanup_queue(struct request_queue$link10 *q);
// c::blk_init_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 16
struct request_queue$link10 * blk_init_queue(void (*rfn)(struct request_queue$link10 *), struct anon$1 *lock);
// c::blk_init_queue::rfn$object
// 
void rfn$object(struct request_queue$link10 *);
// c::blk_queue_hardsect_size
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 64
void blk_queue_hardsect_size(struct request_queue$link10 *q, unsigned short int size);
// c::blk_queue_make_request
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 51
void blk_queue_make_request(struct request_queue$link10 *q, signed int (*mfn)(struct request_queue$link10 *, struct bio$link9 *));
// c::blk_queue_make_request::mfn$object
// 
signed int mfn$object(struct request_queue$link10 *, struct bio$link9 *);
// c::call_cdev_functions
// file /usr/local/ddv/models/con2/src/ddverify/cdev.c line 5
void call_cdev_functions();
// c::call_ddv
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 95
signed int call_ddv();
// c::call_interrupt_handler
// file /usr/local/ddv/models/con2/include/ddverify/interrupt.h line 16
void call_interrupt_handler();
// c::call_pci_functions
// file /usr/local/ddv/models/con2/include/ddverify/pci.h line 19
void call_pci_functions();
// c::call_shared_workqueue_functions
// file /usr/local/ddv/models/con2/include/ddverify/workqueue.h line 10
void call_shared_workqueue_functions();
// c::call_tasklet_functions
// file /usr/local/ddv/models/con2/include/ddverify/tasklet.h line 17
void call_tasklet_functions();
// c::call_timer_functions
// file /usr/local/ddv/models/con2/include/ddverify/timer.h line 16
void call_timer_functions();
// c::cdev_add
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 72
signed int cdev_add(struct cdev$link0 *p, unsigned int dev, unsigned int count);
// c::cdev_alloc
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 60
struct cdev$link0 * cdev_alloc(void);
// c::cdev_del
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 97
void cdev_del(struct cdev$link0 *p);
// c::cdev_init
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 67
void cdev_init(struct cdev$link0 *cdev, struct file_operations$link5 *fops);
// c::clear_bit
// file /usr/local/ddv/models/con2/include/asm/bitops.h line 10
void clear_bit(signed int, volatile unsigned long int *);
// c::copy_from_user
// file /usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c line 45
unsigned long int copy_from_user(void *to, void *from, unsigned long int n);
// c::copy_to_user
// file /usr/local/ddv/models/con2/include/asm/uaccess.h line 51
unsigned long int copy_to_user(void *to, const void *from, unsigned long int n);
// c::ddv
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 75
void ddv();
// c::ddv_2
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 31
static void * ddv_2(void *arg);
// c::del_gendisk
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 49
void del_gendisk(struct gendisk$link12 *gp);
// c::del_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 30
signed int del_timer(struct timer_list *timer);
// c::down
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 33
void down(struct semaphore *sem);
// c::down_interruptible
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 58
signed int down_interruptible(struct semaphore *sem);
// c::down_trylock
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 88
signed int down_trylock(struct semaphore *sem);
// c::end_request
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 56
void end_request(struct request$link19 *req, signed int uptodate);
// c::free_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c line 17
void free_irq(unsigned int irq, void *dev_id);
// c::get_fixed_request_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 7
struct request_queue$link10 * get_fixed_request_queue();
// c::get_user
// file /usr/local/ddv/models/con2/include/asm/uaccess.h line 43
signed int get_user(signed int size, void *ptr);
// c::get_zeroed_page
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 21
unsigned long int get_zeroed_page(unsigned int gfp_mask);
// c::i8xx_tco_getdevice
// file i8xx_tco.c line 428
static unsigned char i8xx_tco_getdevice(void);
// c::i8xx_tco_ioctl
// file i8xx_tco.c line 287
static signed int i8xx_tco_ioctl(struct inode$link7 *inode, struct file$link13 *file, unsigned int cmd, unsigned long int arg);
// c::i8xx_tco_notify_sys
// file i8xx_tco.c line 367
static signed int i8xx_tco_notify_sys(struct notifier_block *this, unsigned long int code, void *unused);
// c::i8xx_tco_open
// file i8xx_tco.c line 229
static signed int i8xx_tco_open(struct inode$link7 *inode, struct file$link13 *file);
// c::i8xx_tco_release
// file i8xx_tco.c line 243
static signed int i8xx_tco_release(struct inode$link7 *inode, struct file$link13 *file);
// c::i8xx_tco_write
// file i8xx_tco.c line 259
static signed int i8xx_tco_write(struct file$link13 *file, const char *data, unsigned int len, signed long long int *ppos);
// c::inb
// file /usr/local/ddv/models/con2/include/asm/io.h line 14
unsigned char inb(unsigned int port);
// c::inb_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 74
unsigned char inb_p(unsigned int port);
// c::init_MUTEX
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 15
void init_MUTEX(struct semaphore *sem);
// c::init_MUTEX_LOCKED
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 24
void init_MUTEX_LOCKED(struct semaphore *sem);
// c::init_kernel
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 15
void init_kernel();
// c::init_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 4
void init_timer(struct timer_list *timer);
// c::init_waitqueue_head
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 3
void init_waitqueue_head(struct __wait_queue_head *q);
// c::inl
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 60
unsigned int inl(unsigned int port);
// c::inl_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 102
unsigned int inl_p(unsigned int port);
// c::interruptible_sleep_on
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 40
void interruptible_sleep_on(struct __wait_queue_head *q);
// c::inw
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 46
unsigned short int inw(unsigned int port);
// c::inw_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 88
unsigned short int inw_p(unsigned int port);
// c::kfree
// file /usr/local/ddv/models/con2/include/linux/slab.h line 8
void kfree(const void *);
// c::kmalloc
// file /usr/local/ddv/models/con2/src/linux/mm/slab.c line 6
void * kmalloc(unsigned int size, unsigned int flags);
// c::kzalloc
// file /usr/local/ddv/models/con2/src/linux/mm/slab.c line 15
void * kzalloc(unsigned int size, unsigned int flags);
// c::malloc
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 9
void * malloc(unsigned int);
// c::misc_deregister
// file /usr/local/ddv/models/con2/include/linux/miscdevice.h line 41
signed int misc_deregister(struct miscdevice *);
// c::misc_register
// file /usr/local/ddv/models/con2/include/linux/miscdevice.h line 40
signed int misc_register(struct miscdevice$link16 *misc);
// c::mod_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 35
signed int mod_timer(struct timer_list *timer, unsigned long int expires);
// c::mutex_init
// file /usr/local/ddv/models/con2/src/linux/kernel/mutex.c line 4
void mutex_init(struct mutex *lock);
// c::mutex_lock
// file /usr/local/ddv/models/con2/src/linux/kernel/mutex.c line 16
void mutex_lock(struct mutex *lock);
// c::mutex_unlock
// file /usr/local/ddv/models/con2/src/linux/kernel/mutex.c line 41
void mutex_unlock(struct mutex *lock);
// c::no_llseek
// file /usr/local/ddv/models/con2/include/linux/fs.h line 223
signed long long int no_llseek(struct file$link13 *, signed long long int, signed int);
// c::nondet_char
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 20
char nondet_char();
// c::nondet_int
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 16
signed int nondet_int();
// c::nondet_loff_t
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 23
signed long long int nondet_loff_t();
// c::nondet_long
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 18
signed long int nondet_long();
// c::nondet_pthread_t
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 57
struct __pthread_t_struct nondet_pthread_t();
// c::nondet_size_t
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 24
unsigned int nondet_size_t();
// c::nondet_uchar
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 21
unsigned char nondet_uchar();
// c::nondet_uint
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 17
unsigned int nondet_uint();
// c::nondet_ulong
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 19
unsigned long int nondet_ulong();
// c::nondet_unsigned
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 22
unsigned int nondet_unsigned();
// c::nondet_ushort
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 15
unsigned short int nondet_ushort();
// c::nonseekable_open
// file /usr/local/ddv/models/con2/include/linux/fs.h line 233
signed int nonseekable_open(struct inode$link7 *, struct file$link13 *);
// c::outb
// file /usr/local/ddv/models/con2/include/asm/io.h line 15
void outb(unsigned char byte, unsigned int port);
// c::outb_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 82
void outb_p(unsigned char byte, unsigned int port);
// c::outl
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 68
void outl(unsigned int doubleword, unsigned int port);
// c::outl_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 110
void outl_p(unsigned int doubleword, unsigned int port);
// c::outw
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 54
void outw(unsigned short int word, unsigned int port);
// c::outw_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 96
void outw_p(unsigned short int word, unsigned int port);
// c::pci_bus_read_config_byte
// file /usr/local/ddv/models/con2/include/linux/pci.h line 104
signed int pci_bus_read_config_byte(struct pci_bus *, unsigned int, signed int, unsigned char *);
// c::pci_bus_write_config_byte
// file /usr/local/ddv/models/con2/include/linux/pci.h line 107
signed int pci_bus_write_config_byte(struct pci_bus *, unsigned int, signed int, unsigned char);
// c::pci_dev_put
// file i8xx_tco.c line 456 function i8xx_tco_getdevice
signed int pci_dev_put(void);
// c::pci_enable_device
// file /usr/local/ddv/models/con2/src/linux/pci.c line 8
signed int pci_enable_device(struct pci_dev$link1 *dev);
// c::pci_get_class
// file /usr/local/ddv/models/con2/src/linux/pci.c line 19
struct pci_dev$link1 * pci_get_class(unsigned int class, struct pci_dev$link1 *from);
// c::pci_get_device
// file i8xx_tco.c line 437 function i8xx_tco_getdevice
signed int pci_get_device(void);
// c::pci_match_id
// file i8xx_tco.c line 438 function i8xx_tco_getdevice
signed int pci_match_id(void);
// c::pci_read_config_byte
// file /usr/local/ddv/models/con2/include/linux/pci.h line 111
static signed int pci_read_config_byte(struct pci_dev$link15 *dev, signed int where, unsigned char *val);
// c::pci_register_driver
// file /usr/local/ddv/models/con2/src/linux/pci.c line 37
signed int pci_register_driver(struct pci_driver$link2 *driver);
// c::pci_release_region
// file /usr/local/ddv/models/con2/src/linux/pci.c line 56
void pci_release_region(struct pci_dev$link1 *pdev, signed int bar);
// c::pci_release_regions
// file /usr/local/ddv/models/con2/src/linux/pci.c line 87
void pci_release_regions(struct pci_dev$link1 *pdev);
// c::pci_request_region
// file /usr/local/ddv/models/con2/src/linux/pci.c line 68
signed int pci_request_region(struct pci_dev$link1 *pdev, signed int bar, const char *res_name);
// c::pci_request_regions
// file /usr/local/ddv/models/con2/src/linux/pci.c line 95
signed int pci_request_regions(struct pci_dev$link1 *pdev, const char *res_name);
// c::pci_unregister_driver
// file /usr/local/ddv/models/con2/src/linux/pci.c line 50
void pci_unregister_driver(struct pci_driver$link2 *driver);
// c::pci_write_config_byte
// file /usr/local/ddv/models/con2/include/linux/pci.h line 123
static signed int pci_write_config_byte(struct pci_dev$link15 *dev, signed int where, unsigned char val);
// c::printk
// file /usr/local/ddv/models/con2/include/linux/kernel.h line 34
signed int printk(const char *, ...);
// c::pthread_create
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 59
signed int pthread_create(struct __pthread_t_struct *__threadp, const struct __pthread_attr_t_struct *__attr, void * (*__start_routine)(void *), void *__arg);
// c::pthread_create::__start_routine$link1$object
// 
void * __start_routine$link1$object(void *);
// c::pthread_create::__start_routine$link10$object
// 
void * __start_routine$link10$object(void *);
// c::pthread_create::__start_routine$link11$object
// 
void * __start_routine$link11$object(void *);
// c::pthread_create::__start_routine$link12$object
// 
void * __start_routine$link12$object(void *);
// c::pthread_create::__start_routine$link13$object
// 
void * __start_routine$link13$object(void *);
// c::pthread_create::__start_routine$link14$object
// 
void * __start_routine$link14$object(void *);
// c::pthread_create::__start_routine$link15$object
// 
void * __start_routine$link15$object(void *);
// c::pthread_create::__start_routine$link16$object
// 
void * __start_routine$link16$object(void *);
// c::pthread_create::__start_routine$link17$object
// 
void * __start_routine$link17$object(void *);
// c::pthread_create::__start_routine$link18$object
// 
void * __start_routine$link18$object(void *);
// c::pthread_create::__start_routine$link19$object
// 
void * __start_routine$link19$object(void *);
// c::pthread_create::__start_routine$link2$object
// 
void * __start_routine$link2$object(void *);
// c::pthread_create::__start_routine$link20$object
// 
void * __start_routine$link20$object(void *);
// c::pthread_create::__start_routine$link22$object
// 
void * __start_routine$link22$object(void *);
// c::pthread_create::__start_routine$link23$object
// 
void * __start_routine$link23$object(void *);
// c::pthread_create::__start_routine$link24$object
// 
void * __start_routine$link24$object(void *);
// c::pthread_create::__start_routine$link25$object
// 
void * __start_routine$link25$object(void *);
// c::pthread_create::__start_routine$link3$object
// 
void * __start_routine$link3$object(void *);
// c::pthread_create::__start_routine$link4$object
// 
void * __start_routine$link4$object(void *);
// c::pthread_create::__start_routine$link5$object
// 
void * __start_routine$link5$object(void *);
// c::pthread_create::__start_routine$link6$object
// 
void * __start_routine$link6$object(void *);
// c::pthread_create::__start_routine$link7$object
// 
void * __start_routine$link7$object(void *);
// c::pthread_create::__start_routine$link8$object
// 
void * __start_routine$link8$object(void *);
// c::pthread_create::__start_routine$link9$object
// 
void * __start_routine$link9$object(void *);
// c::pthread_create::__start_routine$object
// 
void * __start_routine$object(void *);
// c::pthread_mutex_destroy
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 194
signed int pthread_mutex_destroy(struct __pthread_mutex_t_struct *__mutex);
// c::pthread_mutex_init
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 186
signed int pthread_mutex_init(struct __pthread_mutex_t_struct *__mutex, const struct __pthread_mutexattr_t_struct *__mutex_attr);
// c::pthread_mutex_lock
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 203
signed int pthread_mutex_lock(struct __pthread_mutex_t_struct *__mutex);
// c::pthread_mutex_unlock
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 213
signed int pthread_mutex_unlock(struct __pthread_mutex_t_struct *__mutex);
// c::put_user
// file /usr/local/ddv/models/con2/include/asm/uaccess.h line 48
signed int put_user(signed int size, void *ptr);
// c::register_blkdev
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 6
signed int register_blkdev(unsigned int major, const char *name);
// c::register_chrdev
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 33
signed int register_chrdev(unsigned int major, const char *name, struct file_operations$link5 *fops);
// c::register_chrdev_region
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 23
signed int register_chrdev_region(unsigned int from, unsigned int count, const char *name);
// c::register_reboot_notifier
// file /usr/local/ddv/models/con2/include/linux/reboot.h line 40
signed int register_reboot_notifier(struct notifier_block *);
// c::release_mem_region
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 98
void release_mem_region(unsigned long int, unsigned long int);
// c::release_region
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 92
void release_region(unsigned long int start, unsigned long int len);
// c::request_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c line 4
signed int request_irq(unsigned int irq, signed int (*handler)(signed int, void *, struct pt_regs *), unsigned long int irqflags, const char *devname, void *dev_id);
// c::request_irq::handler$object
// 
signed int handler$object(signed int, void *, struct pt_regs *);
// c::request_mem_region
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 96
struct resource * request_mem_region(unsigned long int, unsigned long int, const char *);
// c::request_region
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 90
struct resource * request_region(unsigned long int start, unsigned long int len, const char *name);
// c::schedule
// file /usr/local/ddv/models/con2/src/linux/kernel/sched.c line 8
void schedule(void);
// c::schedule_timeout
// file /usr/local/ddv/models/con2/src/linux/kernel/sched.c line 13
signed long int schedule_timeout(signed long int timeout);
// c::schedule_work
// file /usr/local/ddv/models/con2/src/linux/kernel/workqueue.c line 5
signed int schedule_work(struct work_struct *work);
// c::seconds_to_ticks
// file i8xx_tco.c line 118
static unsigned char seconds_to_ticks(signed int seconds);
// c::sema_init
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 6
void sema_init(struct semaphore *sem, signed int val);
// c::sleep_on
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 32
void sleep_on(struct __wait_queue_head *q);
// c::spin_lock
// file /usr/local/ddv/models/con2/include/linux/spinlock.h line 10
void spin_lock(struct anon$1 *lock);
// c::spin_lock_bh
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 82
void spin_lock_bh(struct anon$1 *lock);
// c::spin_lock_init
// file /usr/local/ddv/models/con2/include/linux/spinlock.h line 9
void spin_lock_init(struct anon$1 *lock);
// c::spin_lock_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 58
void spin_lock_irq(struct anon$1 *lock);
// c::spin_lock_irqsave
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 34
void spin_lock_irqsave(struct anon$1 *lock, unsigned long int flags);
// c::spin_unlock
// file /usr/local/ddv/models/con2/include/linux/spinlock.h line 15
void spin_unlock(struct anon$1 *lock);
// c::spin_unlock_bh
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 139
void spin_unlock_bh(struct anon$1 *lock);
// c::spin_unlock_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 128
void spin_unlock_irq(struct anon$1 *lock);
// c::spin_unlock_irqrestore
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 117
void spin_unlock_irqrestore(struct anon$1 *lock, unsigned long int flags);
// c::tasklet_init
// file /usr/local/ddv/models/con2/src/linux/kernel/softirq.c line 32
void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long int), unsigned long int data);
// c::tasklet_init::func$object
// 
void func$object(unsigned long int);
// c::tasklet_schedule
// file /usr/local/ddv/models/con2/src/linux/kernel/softirq.c line 4
void tasklet_schedule(struct tasklet_struct *t);
// c::tco_timer_get_timeleft
// file i8xx_tco.c line 208
static signed int tco_timer_get_timeleft(signed int *time_left);
// c::tco_timer_keepalive
// file i8xx_tco.c line 172
static signed int tco_timer_keepalive(void);
// c::tco_timer_set_heartbeat
// file i8xx_tco.c line 181
static signed int tco_timer_set_heartbeat(signed int t);
// c::tco_timer_start
// file i8xx_tco.c line 125
static signed int tco_timer_start(void);
// c::tco_timer_stop
// file i8xx_tco.c line 149
static signed int tco_timer_stop(void);
// c::test_and_set_bit
// file /usr/local/ddv/models/con2/include/asm/bitops.h line 6
signed int test_and_set_bit(signed int, unsigned long int *);
// c::tty_set_operations
// file /usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c line 14
void tty_set_operations(struct tty_driver *driver, const struct tty_operations *op);
// c::unregister_blkdev
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 17
signed int unregister_blkdev(unsigned int major, const char *name);
// c::unregister_chrdev
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 55
signed int unregister_chrdev(unsigned int major, const char *name);
// c::unregister_reboot_notifier
// file /usr/local/ddv/models/con2/include/linux/reboot.h line 41
signed int unregister_reboot_notifier(struct notifier_block *);
// c::up
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 106
void up(struct semaphore *sem);
// c::vmalloc
// file /usr/local/ddv/models/con2/src/linux/mm/vmalloc.c line 6
void * vmalloc(unsigned long int size);
// c::wake_up
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 8
void wake_up(struct __wait_queue_head *q);
// c::wake_up_all
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 16
void wake_up_all(struct __wait_queue_head *q);
// c::wake_up_interruptible
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 24
void wake_up_interruptible(struct __wait_queue_head *q);
// c::watchdog_cleanup
// file i8xx_tco.c line 551
static void watchdog_cleanup(void);
// c::watchdog_init
// file i8xx_tco.c line 492
static signed int watchdog_init(void);

struct anon$1
{
  // init
  signed int init;
  // locked
  signed int locked;
};

struct anon$0
{
  // written
  unsigned int written;
  // count
  unsigned int count;
};

struct __pthread_attr_t_struct
{
  // dummy
  signed int dummy;
};

struct __pthread_mutex_t_struct
{
  // locked
  _Bool locked;
};

struct __pthread_mutexattr_t_struct
{
  // dummy
  signed int dummy;
};

struct __pthread_t_struct
{
  // id
  signed int id;
};

struct __wait_queue_head
{
  // number_process_waiting
  signed int number_process_waiting;
  // wakeup
  signed int wakeup;
  // init
  signed int init;
};

struct address_space
{
  // host
  struct inode *host;
};

struct address_space$link10
{
  // host
  struct inode$link8 *host;
};

struct address_space$link11
{
  // host
  struct inode$link9 *host;
};

struct address_space$link14
{
  // host
  struct inode$link6 *host;
};

struct address_space$link3
{
  // host
  struct inode$link2 *host;
};

struct address_space$link7
{
  // host
  struct inode$link5 *host;
};

struct address_space$link8
{
  // host
  struct inode$link3 *host;
};

struct address_space$link9
{
  // host
  struct inode$link7 *host;
};

struct backing_dev_info
{
  // ra_pages
  unsigned long int ra_pages;
  // state
  unsigned long int state;
  // capabilities
  unsigned int capabilities;
};

struct bio
{
  // bi_sector
  unsigned long int bi_sector;
  // bi_next
  struct bio *bi_next;
  // bi_bdev
  struct block_device$link2 *bi_bdev;
  // bi_flags
  unsigned long int bi_flags;
  // bi_rw
  unsigned long int bi_rw;
  // bi_vcnt
  unsigned short int bi_vcnt;
  // bi_idx
  unsigned short int bi_idx;
  // bi_phys_segments
  unsigned short int bi_phys_segments;
  // bi_size
  unsigned int bi_size;
  // bi_io_vec
  struct bio_vec *bi_io_vec;
  // bi_end_io
  signed int (*bi_end_io)(struct bio *, unsigned int, signed int);
  // bi_private
  void *bi_private;
};

struct bio$link14
{
  // bi_sector
  unsigned long int bi_sector;
  // bi_next
  struct bio$link14 *bi_next;
  // bi_bdev
  struct block_device$link3 *bi_bdev;
  // bi_flags
  unsigned long int bi_flags;
  // bi_rw
  unsigned long int bi_rw;
  // bi_vcnt
  unsigned short int bi_vcnt;
  // bi_idx
  unsigned short int bi_idx;
  // bi_phys_segments
  unsigned short int bi_phys_segments;
  // bi_size
  unsigned int bi_size;
  // bi_io_vec
  struct bio_vec *bi_io_vec;
  // bi_end_io
  signed int (*bi_end_io)(struct bio$link14 *, unsigned int, signed int);
  // bi_private
  void *bi_private;
};

struct bio$link9
{
  // bi_sector
  unsigned long int bi_sector;
  // bi_next
  struct bio$link9 *bi_next;
  // bi_bdev
  struct block_device$link0 *bi_bdev;
  // bi_flags
  unsigned long int bi_flags;
  // bi_rw
  unsigned long int bi_rw;
  // bi_vcnt
  unsigned short int bi_vcnt;
  // bi_idx
  unsigned short int bi_idx;
  // bi_phys_segments
  unsigned short int bi_phys_segments;
  // bi_size
  unsigned int bi_size;
  // bi_io_vec
  struct bio_vec *bi_io_vec;
  // bi_end_io
  signed int (*bi_end_io)(struct bio$link9 *, unsigned int, signed int);
  // bi_private
  void *bi_private;
};

struct bio_vec
{
  // bv_page
  struct page *bv_page;
  // bv_len
  unsigned int bv_len;
  // bv_offset
  unsigned int bv_offset;
};

struct block_device
{
  // bd_inode
  struct inode *bd_inode;
  // bd_disk
  struct gendisk *bd_disk;
  // bd_contains
  struct block_device *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link0
{
  // bd_inode
  struct inode$link6 *bd_inode;
  // bd_disk
  struct gendisk$link13 *bd_disk;
  // bd_contains
  struct block_device$link0 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link1
{
  // bd_inode
  struct inode$link2 *bd_inode;
  // bd_disk
  struct gendisk *bd_disk;
  // bd_contains
  struct block_device$link1 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link2
{
  // bd_inode
  struct inode$link3 *bd_inode;
  // bd_disk
  struct gendisk *bd_disk;
  // bd_contains
  struct block_device$link2 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link3
{
  // bd_inode
  struct inode$link5 *bd_inode;
  // bd_disk
  struct gendisk$link12 *bd_disk;
  // bd_contains
  struct block_device$link3 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link4
{
  // bd_inode
  struct inode$link7 *bd_inode;
  // bd_disk
  struct gendisk *bd_disk;
  // bd_contains
  struct block_device$link4 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link5
{
  // bd_inode
  struct inode$link8 *bd_inode;
  // bd_disk
  struct gendisk *bd_disk;
  // bd_contains
  struct block_device$link5 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device$link6
{
  // bd_inode
  struct inode$link9 *bd_inode;
  // bd_disk
  struct gendisk *bd_disk;
  // bd_contains
  struct block_device$link6 *bd_contains;
  // bd_block_size
  unsigned int bd_block_size;
};

struct block_device_operations
{
  // open
  signed int (*open)(struct inode$link3 *, struct file$link5 *);
  // release
  signed int (*release)(struct inode$link3 *, struct file$link5 *);
  // ioctl
  signed int (*ioctl)(struct inode$link3 *, struct file$link5 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link5 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link5 *, unsigned int, unsigned long int);
  // direct_access
  signed int (*direct_access)(struct block_device$link2 *, unsigned long int, unsigned long int *);
  // media_changed
  signed int (*media_changed)(struct gendisk *);
  // revalidate_disk
  signed int (*revalidate_disk)(struct gendisk *);
  // getgeo
  signed int (*getgeo)(struct block_device$link2 *, struct hd_geometry *);
  // owner
  struct module *owner;
};

struct block_device_operations$link13
{
  // open
  signed int (*open)(struct inode$link5 *, struct file$link9 *);
  // release
  signed int (*release)(struct inode$link5 *, struct file$link9 *);
  // ioctl
  signed int (*ioctl)(struct inode$link5 *, struct file$link9 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link9 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link9 *, unsigned int, unsigned long int);
  // direct_access
  signed int (*direct_access)(struct block_device$link3 *, unsigned long int, unsigned long int *);
  // media_changed
  signed int (*media_changed)(struct gendisk$link12 *);
  // revalidate_disk
  signed int (*revalidate_disk)(struct gendisk$link12 *);
  // getgeo
  signed int (*getgeo)(struct block_device$link3 *, struct hd_geometry *);
  // owner
  struct module *owner;
};

struct block_device_operations$link7
{
  // open
  signed int (*open)(struct inode$link6 *, struct file$link16 *);
  // release
  signed int (*release)(struct inode$link6 *, struct file$link16 *);
  // ioctl
  signed int (*ioctl)(struct inode$link6 *, struct file$link16 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link16 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link16 *, unsigned int, unsigned long int);
  // direct_access
  signed int (*direct_access)(struct block_device$link0 *, unsigned long int, unsigned long int *);
  // media_changed
  signed int (*media_changed)(struct gendisk$link13 *);
  // revalidate_disk
  signed int (*revalidate_disk)(struct gendisk$link13 *);
  // getgeo
  signed int (*getgeo)(struct block_device$link0 *, struct hd_geometry *);
  // owner
  struct module *owner;
};

struct cdev
{
  // owner
  struct module *owner;
  // ops
  struct file_operations *ops;
  // dev
  unsigned int dev;
  // count
  unsigned int count;
};

struct cdev$link0
{
  // owner
  struct module *owner;
  // ops
  struct file_operations$link5 *ops;
  // dev
  unsigned int dev;
  // count
  unsigned int count;
};

struct cdev$link1
{
  // owner
  struct module *owner;
  // ops
  struct file_operations$link10 *ops;
  // dev
  unsigned int dev;
  // count
  unsigned int count;
};

struct cdev$link2
{
  // owner
  struct module *owner;
  // ops
  struct file_operations$link13 *ops;
  // dev
  unsigned int dev;
  // count
  unsigned int count;
};

struct cdev$link3
{
  // owner
  struct module *owner;
  // ops
  struct file_operations$link14 *ops;
  // dev
  unsigned int dev;
  // count
  unsigned int count;
};

struct file
{
  // f_dentry
  struct dentry *f_dentry;
  // f_op
  struct file_operations *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space *f_mapping;
};

struct inode
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev *i_cdev;
};

struct ddv_cdev
{
  // cdevp
  struct cdev *cdevp;
  // filp
  struct file filp;
  // inode
  struct inode inode;
  // open
  signed int open;
};

struct file$link5
{
  // f_dentry
  struct dentry$link9 *f_dentry;
  // f_op
  struct file_operations$link10 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link8 *f_mapping;
};

struct inode$link3
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link2 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev$link1 *i_cdev;
};

struct ddv_cdev$link11
{
  // cdevp
  struct cdev$link1 *cdevp;
  // filp
  struct file$link5 filp;
  // inode
  struct inode$link3 inode;
  // open
  signed int open;
};

struct file$link14
{
  // f_dentry
  struct dentry$link11 *f_dentry;
  // f_op
  struct file_operations$link13 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link10 *f_mapping;
};

struct inode$link8
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link5 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev$link2 *i_cdev;
};

struct ddv_cdev$link15
{
  // cdevp
  struct cdev$link2 *cdevp;
  // filp
  struct file$link14 filp;
  // inode
  struct inode$link8 inode;
  // open
  signed int open;
};

struct file$link6
{
  // f_dentry
  struct dentry$link4 *f_dentry;
  // f_op
  struct file_operations$link5 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link3 *f_mapping;
};

struct inode$link2
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link1 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev$link0 *i_cdev;
};

struct ddv_cdev$link7
{
  // cdevp
  struct cdev$link0 *cdevp;
  // filp
  struct file$link6 filp;
  // inode
  struct inode$link2 inode;
  // open
  signed int open;
};

struct list_head
{
  // next
  struct list_head *next;
  // prev
  struct list_head *prev;
};

struct request
{
  // queuelist
  struct list_head queuelist;
  // donelist
  struct list_head donelist;
  // q
  struct request_queue *q;
  // flags
  unsigned long int flags;
  // cmd_flags
  unsigned int cmd_flags;
  // cmd_type
  int cmd_type;
  // bio
  struct bio *bio;
  // completion_data
  void *completion_data;
  // rq_disk
  struct gendisk *rq_disk;
  // sector
  unsigned long int sector;
  // nr_sectors
  unsigned long int nr_sectors;
  // current_nr_sectors
  unsigned int current_nr_sectors;
  // buffer
  char *buffer;
  // errors
  signed int errors;
  // nr_phys_segments
  unsigned short int nr_phys_segments;
  // cmd
  unsigned char cmd[16l];
};

struct ddv_genhd
{
  // gd
  struct gendisk *gd;
  // inode
  struct inode$link3 inode;
  // file
  struct file$link5 file;
  // current_request
  struct request current_request;
  // requests_open
  signed int requests_open;
};

struct inode$link5
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link3 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev *i_cdev;
};

struct file$link9
{
  // f_dentry
  struct dentry$link8 *f_dentry;
  // f_op
  struct file_operations$link11 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link7 *f_mapping;
};

struct list_head$link0
{
  // next
  struct list_head$link0 *next;
  // prev
  struct list_head$link0 *prev;
};

struct request$link18
{
  // queuelist
  struct list_head$link0 queuelist;
  // donelist
  struct list_head$link0 donelist;
  // q
  struct request_queue$link15 *q;
  // flags
  unsigned long int flags;
  // cmd_flags
  unsigned int cmd_flags;
  // cmd_type
  int cmd_type;
  // bio
  struct bio$link14 *bio;
  // completion_data
  void *completion_data;
  // rq_disk
  struct gendisk$link12 *rq_disk;
  // sector
  unsigned long int sector;
  // nr_sectors
  unsigned long int nr_sectors;
  // current_nr_sectors
  unsigned int current_nr_sectors;
  // buffer
  char *buffer;
  // errors
  signed int errors;
  // nr_phys_segments
  unsigned short int nr_phys_segments;
  // cmd
  unsigned char cmd[16l];
};

struct ddv_genhd$link19
{
  // gd
  struct gendisk$link12 *gd;
  // inode
  struct inode$link5 inode;
  // file
  struct file$link9 file;
  // current_request
  struct request$link18 current_request;
  // requests_open
  signed int requests_open;
};

struct inode$link6
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link0 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev *i_cdev;
};

struct file$link16
{
  // f_dentry
  struct dentry$link15 *f_dentry;
  // f_op
  struct file_operations$link17 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link14 *f_mapping;
};

struct list_head$link18
{
  // next
  struct list_head$link18 *next;
  // prev
  struct list_head$link18 *prev;
};

struct request$link19
{
  // queuelist
  struct list_head$link18 queuelist;
  // donelist
  struct list_head$link18 donelist;
  // q
  struct request_queue$link10 *q;
  // flags
  unsigned long int flags;
  // cmd_flags
  unsigned int cmd_flags;
  // cmd_type
  int cmd_type;
  // bio
  struct bio$link9 *bio;
  // completion_data
  void *completion_data;
  // rq_disk
  struct gendisk$link13 *rq_disk;
  // sector
  unsigned long int sector;
  // nr_sectors
  unsigned long int nr_sectors;
  // current_nr_sectors
  unsigned int current_nr_sectors;
  // buffer
  char *buffer;
  // errors
  signed int errors;
  // nr_phys_segments
  unsigned short int nr_phys_segments;
  // cmd
  unsigned char cmd[16l];
};

struct ddv_genhd$link20
{
  // gd
  struct gendisk$link13 *gd;
  // inode
  struct inode$link6 inode;
  // file
  struct file$link16 file;
  // current_request
  struct request$link19 current_request;
  // requests_open
  signed int requests_open;
};

struct device
{
  // driver_data
  void *driver_data;
  // release
  void (*release)(struct device *dev);
};

struct resource
{
  // name
  const char *name;
  // start
  unsigned long int start;
  // end
  unsigned long int end;
  // flags
  unsigned long int flags;
};

struct pci_dev
{
  // bus
  struct pci_bus *bus;
  // devfn
  unsigned int devfn;
  // vendor
  unsigned short int vendor;
  // device
  unsigned short int device;
  // dma_mask
  unsigned long long int dma_mask;
  // dev
  struct device dev;
  // irq
  unsigned int irq;
  // resource
  struct resource resource[12l];
};

struct ddv_pci_driver
{
  // pci_driver
  struct pci_driver *pci_driver;
  // pci_dev
  struct pci_dev pci_dev;
  // no_pci_device_id
  unsigned int no_pci_device_id;
  // dev_initialized
  signed int dev_initialized;
};

struct device$link0
{
  // driver_data
  void *driver_data;
  // release
  void (*release)(struct device$link0 *dev);
};

struct pci_dev$link1
{
  // bus
  struct pci_bus *bus;
  // devfn
  unsigned int devfn;
  // vendor
  unsigned short int vendor;
  // device
  unsigned short int device;
  // dma_mask
  unsigned long long int dma_mask;
  // dev
  struct device$link0 dev;
  // irq
  unsigned int irq;
  // resource
  struct resource resource[12l];
};

struct ddv_pci_driver$link3
{
  // pci_driver
  struct pci_driver$link2 *pci_driver;
  // pci_dev
  struct pci_dev$link1 pci_dev;
  // no_pci_device_id
  unsigned int no_pci_device_id;
  // dev_initialized
  signed int dev_initialized;
};

struct ddv_tasklet
{
  // tasklet
  struct tasklet_struct *tasklet;
  // is_running
  unsigned short int is_running;
};

struct ddv_timer
{
  // timer
  struct timer_list *timer;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[19l];
};

struct tty_driver
{
  // magic
  signed int magic;
  // cdev
  struct cdev$link3 cdev;
  // owner
  struct module *owner;
  // driver_name
  const char *driver_name;
  // name
  const char *name;
  // name_base
  signed int name_base;
  // major
  signed int major;
  // minor_start
  signed int minor_start;
  // minor_num
  signed int minor_num;
  // num
  signed int num;
  // type
  signed short int type;
  // subtype
  signed short int subtype;
  // init_termios
  struct termios init_termios;
  // flags
  signed int flags;
  // refcount
  signed int refcount;
  // proc_entry
  struct proc_dir_entry *proc_entry;
  // open
  signed int (*open)(struct tty_struct *tty, struct file$link15 *filp);
  // close
  void (*close)(struct tty_struct *tty, struct file$link15 *filp);
  // write
  signed int (*write)(struct tty_struct *tty, const unsigned char *buf, signed int count);
  // put_char
  void (*put_char)(struct tty_struct *tty, unsigned char ch);
  // flush_chars
  void (*flush_chars)(struct tty_struct *tty);
  // write_room
  signed int (*write_room)(struct tty_struct *tty);
  // chars_in_buffer
  signed int (*chars_in_buffer)(struct tty_struct *tty);
  // ioctl
  signed int (*ioctl)(struct tty_struct *tty, struct file$link15 *file, unsigned int cmd, unsigned long int arg);
  // set_termios
  void (*set_termios)(struct tty_struct *tty, struct termios *old);
  // throttle
  void (*throttle)(struct tty_struct *tty);
  // unthrottle
  void (*unthrottle)(struct tty_struct *tty);
  // stop
  void (*stop)(struct tty_struct *tty);
  // start
  void (*start)(struct tty_struct *tty);
  // hangup
  void (*hangup)(struct tty_struct *tty);
  // break_ctl
  void (*break_ctl)(struct tty_struct *tty, signed int state);
  // flush_buffer
  void (*flush_buffer)(struct tty_struct *tty);
  // set_ldisc
  void (*set_ldisc)(struct tty_struct *tty);
  // wait_until_sent
  void (*wait_until_sent)(struct tty_struct *tty, signed int timeout);
  // send_xchar
  void (*send_xchar)(struct tty_struct *tty, char ch);
  // read_proc
  signed int (*read_proc)(char *page, char **start, signed long int off, signed int count, signed int *eof, void *data);
  // write_proc
  signed int (*write_proc)(struct file$link15 *file, const char *buffer, unsigned long int count, void *data);
  // tiocmget
  signed int (*tiocmget)(struct tty_struct *tty, struct file$link15 *file);
  // tiocmset
  signed int (*tiocmset)(struct tty_struct *tty, struct file$link15 *file, unsigned int set, unsigned int clear);
};

struct ddv_tty_driver
{
  // driver
  struct tty_driver driver;
  // allocated
  unsigned short int allocated;
  // registered
  unsigned short int registered;
};

struct dentry
{
  // d_inode
  struct inode *d_inode;
};

struct dentry$link10
{
  // d_inode
  struct inode$link7 *d_inode;
};

struct dentry$link11
{
  // d_inode
  struct inode$link8 *d_inode;
};

struct dentry$link12
{
  // d_inode
  struct inode$link9 *d_inode;
};

struct dentry$link15
{
  // d_inode
  struct inode$link6 *d_inode;
};

struct dentry$link4
{
  // d_inode
  struct inode$link2 *d_inode;
};

struct dentry$link8
{
  // d_inode
  struct inode$link5 *d_inode;
};

struct dentry$link9
{
  // d_inode
  struct inode$link3 *d_inode;
};

struct device$link11
{
  // driver_data
  void *driver_data;
  // release
  void (*release)(struct device$link11 *dev);
};

struct device$link14
{
  // driver_data
  void *driver_data;
  // release
  void (*release)(struct device$link14 *dev);
};

struct device$link16
{
  // driver_data
  void *driver_data;
  // release
  void (*release)(struct device$link16 *dev);
};

struct file$link13
{
  // f_dentry
  struct dentry$link10 *f_dentry;
  // f_op
  struct file_operations$link12 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link9 *f_mapping;
};

struct file$link15
{
  // f_dentry
  struct dentry$link12 *f_dentry;
  // f_op
  struct file_operations$link14 *f_op;
  // f_count
  signed int f_count;
  // f_flags
  unsigned int f_flags;
  // f_mode
  unsigned short int f_mode;
  // f_pos
  signed long long int f_pos;
  // private_data
  void *private_data;
  // f_mapping
  struct address_space$link11 *f_mapping;
};

struct file_lock
{
  // something
  signed int something;
};

struct file_operations
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file *, signed long long int, signed int);
  // read
  signed int (*read)(struct file *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode *, struct file *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode *, struct file *);
  // flush
  signed int (*flush)(struct file *);
  // release
  signed int (*release)(struct inode *, struct file *);
  // fsync
  signed int (*fsync)(struct file *, struct dentry *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file *, signed int);
  // lock
  signed int (*lock)(struct file *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file *, signed long long int *, unsigned int, signed int (*)(struct anon$0 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode *);
};

struct file_operations$link10
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link5 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link5 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link5 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link5 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link5 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link3 *, struct file$link5 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link5 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link5 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link5 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link3 *, struct file$link5 *);
  // flush
  signed int (*flush)(struct file$link5 *);
  // release
  signed int (*release)(struct inode$link3 *, struct file$link5 *);
  // fsync
  signed int (*fsync)(struct file$link5 *, struct dentry$link9 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link5 *, signed int);
  // lock
  signed int (*lock)(struct file$link5 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link5 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link5 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link5 *, signed long long int *, unsigned int, signed int (*)(struct anon$0 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link5 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link5 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link5 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link5 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link3 *);
};

struct file_operations$link11
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link9 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link9 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link9 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link9 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link9 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link5 *, struct file$link9 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link9 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link9 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link9 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link5 *, struct file$link9 *);
  // flush
  signed int (*flush)(struct file$link9 *);
  // release
  signed int (*release)(struct inode$link5 *, struct file$link9 *);
  // fsync
  signed int (*fsync)(struct file$link9 *, struct dentry$link8 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link9 *, signed int);
  // lock
  signed int (*lock)(struct file$link9 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link9 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link9 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link9 *, signed long long int *, unsigned int, signed int (*)(struct anon$0 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link9 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link9 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link9 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link9 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link5 *);
};

struct file_operations$link12
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link13 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link13 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link13 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link13 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link13 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link7 *, struct file$link13 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link13 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link13 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link13 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link7 *, struct file$link13 *);
  // flush
  signed int (*flush)(struct file$link13 *);
  // release
  signed int (*release)(struct inode$link7 *, struct file$link13 *);
  // fsync
  signed int (*fsync)(struct file$link13 *, struct dentry$link10 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link13 *, signed int);
  // lock
  signed int (*lock)(struct file$link13 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link13 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link13 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link13 *, signed long long int *, unsigned int, signed int (*)(struct anon$0 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link13 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link13 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link13 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link13 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link7 *);
};

struct file_operations$link13
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link14 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link14 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link14 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link14 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link14 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link8 *, struct file$link14 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link14 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link14 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link14 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link8 *, struct file$link14 *);
  // flush
  signed int (*flush)(struct file$link14 *);
  // release
  signed int (*release)(struct inode$link8 *, struct file$link14 *);
  // fsync
  signed int (*fsync)(struct file$link14 *, struct dentry$link11 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link14 *, signed int);
  // lock
  signed int (*lock)(struct file$link14 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link14 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link14 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link14 *, signed long long int *, unsigned int, signed int (*)(struct anon$0 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link14 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link14 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link14 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link14 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link8 *);
};

struct file_operations$link14
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link15 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link15 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link15 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link15 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link15 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link9 *, struct file$link15 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link15 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link15 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link15 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link9 *, struct file$link15 *);
  // flush
  signed int (*flush)(struct file$link15 *);
  // release
  signed int (*release)(struct inode$link9 *, struct file$link15 *);
  // fsync
  signed int (*fsync)(struct file$link15 *, struct dentry$link12 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link15 *, signed int);
  // lock
  signed int (*lock)(struct file$link15 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link15 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link15 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link15 *, signed long long int *, unsigned int, signed int (*)(struct anon$0 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link15 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link15 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link15 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link15 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link9 *);
};

struct file_operations$link17
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link16 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link16 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link16 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link16 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link16 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link6 *, struct file$link16 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link16 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link16 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link16 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link6 *, struct file$link16 *);
  // flush
  signed int (*flush)(struct file$link16 *);
  // release
  signed int (*release)(struct inode$link6 *, struct file$link16 *);
  // fsync
  signed int (*fsync)(struct file$link16 *, struct dentry$link15 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link16 *, signed int);
  // lock
  signed int (*lock)(struct file$link16 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link16 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link16 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link16 *, signed long long int *, unsigned int, signed int (*)(struct anon$0 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link16 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link16 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link16 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link16 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link6 *);
};

struct file_operations$link5
{
  // owner
  struct module *owner;
  // llseek
  signed long long int (*llseek)(struct file$link6 *, signed long long int, signed int);
  // read
  signed int (*read)(struct file$link6 *, char *, unsigned int, signed long long int *);
  // write
  signed int (*write)(struct file$link6 *, const char *, unsigned int, signed long long int *);
  // readdir
  signed int (*readdir)(struct file$link6 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int));
  // poll
  unsigned int (*poll)(struct file$link6 *, struct poll_table_struct *);
  // ioctl
  signed int (*ioctl)(struct inode$link2 *, struct file$link6 *, unsigned int, unsigned long int);
  // unlocked_ioctl
  signed long int (*unlocked_ioctl)(struct file$link6 *, unsigned int, unsigned long int);
  // compat_ioctl
  signed long int (*compat_ioctl)(struct file$link6 *, unsigned int, unsigned long int);
  // mmap
  signed int (*mmap)(struct file$link6 *, struct vm_area_struct *);
  // open
  signed int (*open)(struct inode$link2 *, struct file$link6 *);
  // flush
  signed int (*flush)(struct file$link6 *);
  // release
  signed int (*release)(struct inode$link2 *, struct file$link6 *);
  // fsync
  signed int (*fsync)(struct file$link6 *, struct dentry$link4 *, signed int datasync);
  // fasync
  signed int (*fasync)(signed int, struct file$link6 *, signed int);
  // lock
  signed int (*lock)(struct file$link6 *, signed int, struct file_lock *);
  // readv
  signed int (*readv)(struct file$link6 *, const struct iovec *, unsigned long int, signed long long int *);
  // writev
  signed int (*writev)(struct file$link6 *, const struct iovec *, unsigned long int, signed long long int *);
  // sendfile
  signed int (*sendfile)(struct file$link6 *, signed long long int *, unsigned int, signed int (*)(struct anon$0 *, struct page *, unsigned long int, unsigned long int), void *);
  // sendpage
  signed int (*sendpage)(struct file$link6 *, struct page *, signed int, unsigned int, signed long long int *, signed int);
  // get_unmapped_area
  unsigned long int (*get_unmapped_area)(struct file$link6 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
  // check_flags
  signed int (*check_flags)(signed int);
  // dir_notify
  signed int (*dir_notify)(struct file$link6 *filp, unsigned long int arg);
  // flock
  signed int (*flock)(struct file$link6 *, signed int, struct file_lock *);
  // open_exec
  signed int (*open_exec)(struct inode$link2 *);
};

struct gendisk
{
  // major
  signed int major;
  // first_minor
  signed int first_minor;
  // minors
  signed int minors;
  // disk_name
  char disk_name[32l];
  // fops
  struct block_device_operations *fops;
  // queue
  struct request_queue *queue;
  // private_data
  void *private_data;
  // flags
  signed int flags;
  // driverfs_dev
  struct device *driverfs_dev;
  // devfs_name
  char devfs_name[64l];
};

struct gendisk$link12
{
  // major
  signed int major;
  // first_minor
  signed int first_minor;
  // minors
  signed int minors;
  // disk_name
  char disk_name[32l];
  // fops
  struct block_device_operations$link13 *fops;
  // queue
  struct request_queue$link15 *queue;
  // private_data
  void *private_data;
  // flags
  signed int flags;
  // driverfs_dev
  struct device$link16 *driverfs_dev;
  // devfs_name
  char devfs_name[64l];
};

struct gendisk$link13
{
  // major
  signed int major;
  // first_minor
  signed int first_minor;
  // minors
  signed int minors;
  // disk_name
  char disk_name[32l];
  // fops
  struct block_device_operations$link7 *fops;
  // queue
  struct request_queue$link10 *queue;
  // private_data
  void *private_data;
  // flags
  signed int flags;
  // driverfs_dev
  struct device$link11 *driverfs_dev;
  // devfs_name
  char devfs_name[64l];
};

struct inode$link7
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link4 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev *i_cdev;
};

struct inode$link9
{
  // i_mode
  unsigned short int i_mode;
  // i_bdev
  struct block_device$link6 *i_bdev;
  // i_rdev
  unsigned int i_rdev;
  // i_size
  signed long long int i_size;
  // i_cdev
  struct cdev$link3 *i_cdev;
};

struct miscdevice
{
  // minor
  signed int minor;
  // name
  const char *name;
  // fops
  struct file_operations$link12 *fops;
};

struct miscdevice$link16
{
  // minor
  signed int minor;
  // name
  const char *name;
  // fops
  struct file_operations$link13 *fops;
};

struct module
{
  // something
  signed int something;
};

struct mutex
{
  // locked
  signed int locked;
  // init
  signed int init;
};

struct notifier_block
{
  // notifier_call
  signed int (*notifier_call)(struct notifier_block *self, unsigned long int, void *);
  // next
  struct notifier_block *next;
  // priority
  signed int priority;
};

struct page
{
  // something
  signed int something;
};

struct pci_bus
{
  // number
  unsigned char number;
};

struct pci_dev$link15
{
  // bus
  struct pci_bus *bus;
  // devfn
  unsigned int devfn;
  // vendor
  unsigned short int vendor;
  // device
  unsigned short int device;
  // dma_mask
  unsigned long long int dma_mask;
  // dev
  struct device$link14 dev;
  // irq
  unsigned int irq;
  // resource
  struct resource resource[12l];
};

struct pci_device_id
{
  // vendor
  unsigned int vendor;
  // device
  unsigned int device;
  // subvendor
  unsigned int subvendor;
  // subdevice
  unsigned int subdevice;
  // class
  unsigned int class;
  // class_mask
  unsigned int class_mask;
  // driver_data
  unsigned long int driver_data;
};

struct pci_driver
{
  // name
  char *name;
  // id_table
  const struct pci_device_id *id_table;
  // probe
  signed int (*probe)(struct pci_dev *dev, const struct pci_device_id *id);
  // remove
  void (*remove)(struct pci_dev *dev);
  // suspend
  signed int (*suspend)(struct pci_dev *dev, struct pm_message state);
  // resume
  signed int (*resume)(struct pci_dev *dev);
  // enable_wake
  signed int (*enable_wake)(struct pci_dev *dev, signed int state, signed int enable);
  // shutdown
  void (*shutdown)(struct pci_dev *dev);
};

struct pci_driver$link2
{
  // name
  char *name;
  // id_table
  const struct pci_device_id *id_table;
  // probe
  signed int (*probe)(struct pci_dev$link1 *dev, const struct pci_device_id *id);
  // remove
  void (*remove)(struct pci_dev$link1 *dev);
  // suspend
  signed int (*suspend)(struct pci_dev$link1 *dev, struct pm_message state);
  // resume
  signed int (*resume)(struct pci_dev$link1 *dev);
  // enable_wake
  signed int (*enable_wake)(struct pci_dev$link1 *dev, signed int state, signed int enable);
  // shutdown
  void (*shutdown)(struct pci_dev$link1 *dev);
};

struct pm_message
{
  // event
  signed int event;
};

struct proc_dir_entry
{
  // something
  signed int something;
};

struct pt_regs
{
  // something
  signed int something;
};

struct registered_irq
{
  // handler
  signed int (*handler)(signed int, void *, struct pt_regs *);
  // dev_id
  void *dev_id;
};

struct request_queue
{
  // request_fn
  void (*request_fn)(struct request_queue *);
  // make_request_fn
  signed int (*make_request_fn)(struct request_queue *, struct bio *);
  // unplug_fn
  void (*unplug_fn)(struct request_queue *);
  // backing_dev_info
  struct backing_dev_info backing_dev_info;
  // queuedata
  void *queuedata;
  // queue_flags
  unsigned long int queue_flags;
  // queue_lock
  struct anon$1 *queue_lock;
  // hardsect_size
  unsigned short int hardsect_size;
  // __ddv_genhd_no
  signed int __ddv_genhd_no;
  // __ddv_queue_alive
  signed int __ddv_queue_alive;
};

struct request_queue$link10
{
  // request_fn
  void (*request_fn)(struct request_queue$link10 *);
  // make_request_fn
  signed int (*make_request_fn)(struct request_queue$link10 *, struct bio$link9 *);
  // unplug_fn
  void (*unplug_fn)(struct request_queue$link10 *);
  // backing_dev_info
  struct backing_dev_info backing_dev_info;
  // queuedata
  void *queuedata;
  // queue_flags
  unsigned long int queue_flags;
  // queue_lock
  struct anon$1 *queue_lock;
  // hardsect_size
  unsigned short int hardsect_size;
  // __ddv_genhd_no
  signed int __ddv_genhd_no;
  // __ddv_queue_alive
  signed int __ddv_queue_alive;
};

struct request_queue$link15
{
  // request_fn
  void (*request_fn)(struct request_queue$link15 *);
  // make_request_fn
  signed int (*make_request_fn)(struct request_queue$link15 *, struct bio$link14 *);
  // unplug_fn
  void (*unplug_fn)(struct request_queue$link15 *);
  // backing_dev_info
  struct backing_dev_info backing_dev_info;
  // queuedata
  void *queuedata;
  // queue_flags
  unsigned long int queue_flags;
  // queue_lock
  struct anon$1 *queue_lock;
  // hardsect_size
  unsigned short int hardsect_size;
  // __ddv_genhd_no
  signed int __ddv_genhd_no;
  // __ddv_queue_alive
  signed int __ddv_queue_alive;
};

struct semaphore
{
  // init
  signed int init;
  // locked
  signed int locked;
};

struct tasklet_struct
{
  // count
  signed int count;
  // func
  void (*func)(unsigned long int);
  // data
  unsigned long int data;
  // init
  signed int init;
};

struct timer_list
{
  // expires
  unsigned long int expires;
  // function
  void (*function)(unsigned long int);
  // data
  unsigned long int data;
  // __ddv_active
  signed short int __ddv_active;
  // __ddv_init
  signed short int __ddv_init;
};

struct tty_operations
{
  // open
  signed int (*open)(struct tty_struct *tty, struct file$link15 *filp);
  // close
  void (*close)(struct tty_struct *tty, struct file$link15 *filp);
  // write
  signed int (*write)(struct tty_struct *tty, const unsigned char *buf, signed int count);
  // put_char
  void (*put_char)(struct tty_struct *tty, unsigned char ch);
  // flush_chars
  void (*flush_chars)(struct tty_struct *tty);
  // write_room
  signed int (*write_room)(struct tty_struct *tty);
  // chars_in_buffer
  signed int (*chars_in_buffer)(struct tty_struct *tty);
  // ioctl
  signed int (*ioctl)(struct tty_struct *tty, struct file$link15 *file, unsigned int cmd, unsigned long int arg);
  // set_termios
  void (*set_termios)(struct tty_struct *tty, struct termios *old);
  // throttle
  void (*throttle)(struct tty_struct *tty);
  // unthrottle
  void (*unthrottle)(struct tty_struct *tty);
  // stop
  void (*stop)(struct tty_struct *tty);
  // start
  void (*start)(struct tty_struct *tty);
  // hangup
  void (*hangup)(struct tty_struct *tty);
  // break_ctl
  void (*break_ctl)(struct tty_struct *tty, signed int state);
  // flush_buffer
  void (*flush_buffer)(struct tty_struct *tty);
  // set_ldisc
  void (*set_ldisc)(struct tty_struct *tty);
  // wait_until_sent
  void (*wait_until_sent)(struct tty_struct *tty, signed int timeout);
  // send_xchar
  void (*send_xchar)(struct tty_struct *tty, char ch);
  // read_proc
  signed int (*read_proc)(char *page, char **start, signed long int off, signed int count, signed int *eof, void *data);
  // write_proc
  signed int (*write_proc)(struct file$link15 *file, const char *buffer, unsigned long int count, void *data);
  // tiocmget
  signed int (*tiocmget)(struct tty_struct *tty, struct file$link15 *file);
  // tiocmset
  signed int (*tiocmset)(struct tty_struct *tty, struct file$link15 *file, unsigned int set, unsigned int clear);
};

struct tty_struct
{
  // magic
  signed int magic;
  // driver
  struct tty_driver *driver;
  // index
  signed int index;
  // termios
  struct termios *termios;
  // termios_locked
  struct termios *termios_locked;
  // name
  char name[64l];
  // flags
  unsigned long int flags;
  // count
  signed int count;
  // stopped
  unsigned char stopped;
  // hw_stopped
  unsigned char hw_stopped;
  // flow_stopped
  unsigned char flow_stopped;
  // packet
  unsigned char packet;
  // receive_room
  unsigned int receive_room;
  // write_wait
  struct __wait_queue_head write_wait;
  // read_wait
  struct __wait_queue_head read_wait;
  // disc_data
  void *disc_data;
  // driver_data
  void *driver_data;
  // closing
  unsigned char closing;
};

struct watchdog_info
{
  // options
  unsigned int options;
  // firmware_version
  unsigned int firmware_version;
  // identity
  unsigned char identity[32l];
};

struct work_struct
{
  // pending
  unsigned long int pending;
  // func
  void (*func)(void *);
  // data
  void *data;
  // init
  signed int init;
};


// c::ACPIBASE
// file i8xx_tco.c line 98
static unsigned int ACPIBASE;
// c::__invalid_size_argument_for_IOC
// file /usr/local/ddv/models/con2/include/asm-generic/ioctl.h line 51
unsigned int __invalid_size_argument_for_IOC;
// c::_ddv_module_author
// file i8xx_tco.c line 568
char _ddv_module_author[13l];
// c::_ddv_module_author
// file i8xx_tco.c line 568
char _ddv_module_author[13l] = { 78, 105, 108, 115, 32, 70, 97, 101, 114, 98, 101, 114, 0 };
// c::_ddv_module_description
// file i8xx_tco.c line 569
char _ddv_module_description[35l];
// c::_ddv_module_description
// file i8xx_tco.c line 569
char _ddv_module_description[35l] = { 84, 67, 79, 32, 116, 105, 109, 101, 114, 32, 100, 114, 105, 118, 101, 114, 32, 102, 111, 114, 32, 105, 56, 120, 120, 32, 99, 104, 105, 112, 115, 101, 116, 115, 0 };
// c::_ddv_module_exit
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 43
void (*_ddv_module_exit)(void);
// c::_ddv_module_init
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 42
signed int (*_ddv_module_init)(void);
// c::_ddv_module_license
// file i8xx_tco.c line 570
char _ddv_module_license[4l];
// c::_ddv_module_license
// file i8xx_tco.c line 570
char _ddv_module_license[4l] = { 71, 80, 76, 0 };
// c::_ddv_module_param_heartbeat
// file i8xx_tco.c line 108
char _ddv_module_param_heartbeat[76l];
// c::_ddv_module_param_heartbeat
// file i8xx_tco.c line 108
char _ddv_module_param_heartbeat[76l] = { 87, 97, 116, 99, 104, 100, 111, 103, 32, 104, 101, 97, 114, 116, 98, 101, 97, 116, 32, 105, 110, 32, 115, 101, 99, 111, 110, 100, 115, 46, 32, 40, 50, 60, 104, 101, 97, 114, 116, 98, 101, 97, 116, 60, 51, 57, 44, 32, 100, 101, 102, 97, 117, 108, 116, 61, 87, 65, 84, 67, 72, 68, 79, 71, 95, 72, 69, 65, 82, 84, 66, 69, 65, 84, 41, 0 };
// c::_ddv_module_param_nowayout
// file i8xx_tco.c line 112
char _ddv_module_param_nowayout[75l];
// c::_ddv_module_param_nowayout
// file i8xx_tco.c line 112
char _ddv_module_param_nowayout[75l] = { 87, 97, 116, 99, 104, 100, 111, 103, 32, 99, 97, 110, 110, 111, 116, 32, 98, 101, 32, 115, 116, 111, 112, 112, 101, 100, 32, 111, 110, 99, 101, 32, 115, 116, 97, 114, 116, 101, 100, 32, 40, 100, 101, 102, 97, 117, 108, 116, 61, 67, 79, 78, 70, 73, 71, 95, 87, 65, 84, 67, 72, 68, 79, 71, 95, 78, 79, 87, 65, 89, 79, 85, 84, 41, 0 };
// c::_ddv_tmp_exit
// file i8xx_tco.c line 566
void (*_ddv_tmp_exit)(void);
// c::_ddv_tmp_exit
// file i8xx_tco.c line 566
void (*_ddv_tmp_exit)(void) = watchdog_cleanup;
// c::_ddv_tmp_init
// file i8xx_tco.c line 565
signed int (*_ddv_tmp_init)(void);
// c::_ddv_tmp_init
// file i8xx_tco.c line 565
signed int (*_ddv_tmp_init)(void) = watchdog_init;
// c::cdev_registered
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 22
struct ddv_cdev cdev_registered[10l];
// c::current_execution_context
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 11
signed int current_execution_context;
// c::ddv_ioport_request_len
// file /usr/local/ddv/models/con2/include/ddverify/ioport.h line 11
signed int ddv_ioport_request_len;
// c::ddv_ioport_request_start
// file /usr/local/ddv/models/con2/include/ddverify/ioport.h line 10
signed int ddv_ioport_request_start;
// c::fixed_cdev
// file /usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h line 12
struct cdev fixed_cdev[10l];
// c::fixed_cdev_used
// file /usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h line 13
signed int fixed_cdev_used;
// c::fixed_cdev_used
// file /usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h line 13
signed int fixed_cdev_used = 0;
// c::fixed_gendisk
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 24
struct gendisk fixed_gendisk[10l];
// c::fixed_request_queue
// file /usr/local/ddv/models/con2/include/ddverify/blkdev.h line 6
struct request_queue$link10 fixed_request_queue[10l];
// c::genhd_registered
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 25
struct ddv_genhd genhd_registered[10l];
// c::global_tty_driver
// file /usr/local/ddv/models/con2/include/ddverify/tty.h line 13
struct ddv_tty_driver global_tty_driver;
// c::heartbeat
// file i8xx_tco.c line 106
static signed int heartbeat;
// c::heartbeat
// file i8xx_tco.c line 106
static signed int heartbeat = 30;
// c::i8xx_tco_fops
// file i8xx_tco.c line 381
static struct file_operations$link12 i8xx_tco_fops;
// c::i8xx_tco_fops
// file i8xx_tco.c line 381
static struct file_operations$link12 i8xx_tco_fops = { .owner=((struct module *)NULL), .llseek=no_llseek, .read=((signed int (*)(struct file$link13 *, char *, unsigned int, signed long long int *))NULL),
    .write=i8xx_tco_write,
    .readdir=((signed int (*)(struct file$link13 *, void *, signed int (*)(void *, const char *, signed int, signed long long int, unsigned long int, unsigned int)))NULL), .poll=((unsigned int (*)(struct file$link13 *, struct poll_table_struct *))NULL),
    .ioctl=i8xx_tco_ioctl,
    .unlocked_ioctl=((signed long int (*)(struct file$link13 *, unsigned int, unsigned long int))NULL), .compat_ioctl=((signed long int (*)(struct file$link13 *, unsigned int, unsigned long int))NULL),
    .mmap=((signed int (*)(struct file$link13 *, struct vm_area_struct *))NULL),
    .open=i8xx_tco_open,
    .flush=((signed int (*)(struct file$link13 *))NULL), .release=i8xx_tco_release,
    .fsync=((signed int (*)(struct file$link13 *, struct dentry$link10 *, signed int datasync))NULL), .fasync=((signed int (*)(signed int, struct file$link13 *, signed int))NULL),
    .lock=((signed int (*)(struct file$link13 *, signed int, struct file_lock *))NULL),
    .readv=((signed int (*)(struct file$link13 *, const struct iovec *, unsigned long int, signed long long int *))NULL),
    .writev=((signed int (*)(struct file$link13 *, const struct iovec *, unsigned long int, signed long long int *))NULL),
    .sendfile=((signed int (*)(struct file$link13 *, signed long long int *, unsigned int, signed int (*)(struct anon$0 *, struct page *, unsigned long int, unsigned long int), void *))NULL),
    .sendpage=((signed int (*)(struct file$link13 *, struct page *, signed int, unsigned int, signed long long int *, signed int))NULL),
    .get_unmapped_area=((unsigned long int (*)(struct file$link13 *, unsigned long int, unsigned long int, unsigned long int, unsigned long int))NULL),
    .check_flags=((signed int (*)(signed int))NULL),
    .dir_notify=((signed int (*)(struct file$link13 *filp, unsigned long int arg))NULL),
    .flock=((signed int (*)(struct file$link13 *, signed int, struct file_lock *))NULL),
    .open_exec=((signed int (*)(struct inode$link7 *))NULL) };
// c::i8xx_tco_miscdev
// file i8xx_tco.c line 390
static struct miscdevice i8xx_tco_miscdev;
// c::i8xx_tco_miscdev
// file i8xx_tco.c line 390
static struct miscdevice i8xx_tco_miscdev = { .minor=130, .name="watchdog", .fops=&i8xx_tco_fops };
// c::i8xx_tco_notifier
// file i8xx_tco.c line 396
static struct notifier_block i8xx_tco_notifier;
// c::i8xx_tco_notifier
// file i8xx_tco.c line 396
static struct notifier_block i8xx_tco_notifier = { .notifier_call=i8xx_tco_notify_sys, .next=((struct notifier_block *)NULL), .priority=0 };
// c::i8xx_tco_pci
// file i8xx_tco.c line 102
static struct pci_dev$link15 *i8xx_tco_pci;
// c::i8xx_tco_pci_tbl
// file i8xx_tco.c line 408
static struct pci_device_id i8xx_tco_pci_tbl[12l];
// c::i8xx_tco_pci_tbl
// file i8xx_tco.c line 408
static struct pci_device_id i8xx_tco_pci_tbl[12l] = { { .vendor=(unsigned int)32902, .device=(unsigned int)9232, .subvendor=(unsigned int)~0,
    .subdevice=(unsigned int)~0, .class=0u,
    .class_mask=0u, .driver_data=0ul }, 
    { .vendor=(unsigned int)32902, .device=(unsigned int)9248, .subvendor=(unsigned int)~0,
    .subdevice=(unsigned int)~0, .class=0u,
    .class_mask=0u, .driver_data=0ul }, 
    { .vendor=(unsigned int)32902, .device=(unsigned int)9280, .subvendor=(unsigned int)~0,
    .subdevice=(unsigned int)~0, .class=0u,
    .class_mask=0u, .driver_data=0ul }, 
    { .vendor=(unsigned int)32902, .device=(unsigned int)9292, .subvendor=(unsigned int)~0,
    .subdevice=(unsigned int)~0, .class=0u,
    .class_mask=0u, .driver_data=0ul }, 
    { .vendor=(unsigned int)32902, .device=(unsigned int)9344, .subvendor=(unsigned int)~0,
    .subdevice=(unsigned int)~0, .class=0u,
    .class_mask=0u, .driver_data=0ul }, 
    { .vendor=(unsigned int)32902, .device=(unsigned int)9356, .subvendor=(unsigned int)~0,
    .subdevice=(unsigned int)~0, .class=0u,
    .class_mask=0u, .driver_data=0ul }, 
    { .vendor=(unsigned int)32902, .device=(unsigned int)9408, .subvendor=(unsigned int)~0,
    .subdevice=(unsigned int)~0, .class=0u,
    .class_mask=0u, .driver_data=0ul }, 
    { .vendor=(unsigned int)32902, .device=(unsigned int)9420, .subvendor=(unsigned int)~0,
    .subdevice=(unsigned int)~0, .class=0u,
    .class_mask=0u, .driver_data=0ul }, 
    { .vendor=(unsigned int)32902, .device=(unsigned int)9296, .subvendor=(unsigned int)~0,
    .subdevice=(unsigned int)~0, .class=0u,
    .class_mask=0u, .driver_data=0ul }, 
    { .vendor=(unsigned int)32902, .device=(unsigned int)9424, .subvendor=(unsigned int)~0,
    .subdevice=(unsigned int)~0, .class=0u,
    .class_mask=0u, .driver_data=0ul }, 
    { .vendor=(unsigned int)32902, .device=(unsigned int)9633, .subvendor=(unsigned int)~0,
    .subdevice=(unsigned int)~0, .class=0u,
    .class_mask=0u, .driver_data=0ul }, 
    { .vendor=0u, .device=0u, .subvendor=0u, .subdevice=0u,
    .class=0u, .class_mask=0u, .driver_data=0ul } };
// c::jiffies
// file /usr/local/ddv/models/con2/include/linux/jiffies.h line 7
unsigned long int jiffies;
// c::kernel_lock
// file /usr/local/ddv/models/con2/include/linux/smp_lock.h line 7
struct anon$1 kernel_lock;
// c::nowayout
// file i8xx_tco.c line 110
static signed int nowayout;
// c::nowayout
// file i8xx_tco.c line 110
static signed int nowayout = 0;
// c::number_cdev_registered
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 11
signed short int number_cdev_registered;
// c::number_cdev_registered
// file /usr/local/ddv/models/con2/include/ddverify/cdev.h line 11
signed short int number_cdev_registered = (signed short int)0;
// c::number_fixed_genhd_used
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 13
signed short int number_fixed_genhd_used;
// c::number_fixed_genhd_used
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 13
signed short int number_fixed_genhd_used = (signed short int)0;
// c::number_genhd_registered
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 12
signed short int number_genhd_registered;
// c::number_genhd_registered
// file /usr/local/ddv/models/con2/include/ddverify/genhd.h line 12
signed short int number_genhd_registered = (signed short int)0;
// c::number_request_queue_used
// file /usr/local/ddv/models/con2/include/ddverify/blkdev.h line 8
signed int number_request_queue_used;
// c::number_request_queue_used
// file /usr/local/ddv/models/con2/include/ddverify/blkdev.h line 8
signed int number_request_queue_used = 0;
// c::number_tasklet_registered
// file /usr/local/ddv/models/con2/include/ddverify/tasklet.h line 8
signed short int number_tasklet_registered;
// c::number_tasklet_registered
// file /usr/local/ddv/models/con2/include/ddverify/tasklet.h line 8
signed short int number_tasklet_registered = (signed short int)0;
// c::number_timer_registered
// file /usr/local/ddv/models/con2/include/ddverify/timer.h line 8
signed short int number_timer_registered;
// c::number_timer_registered
// file /usr/local/ddv/models/con2/include/ddverify/timer.h line 8
signed short int number_timer_registered = (signed short int)0;
// c::proc_root_driver
// file /usr/local/ddv/models/con2/include/linux/proc_fs.h line 11
struct proc_dir_entry *proc_root_driver;
// c::registered_irq
// file /usr/local/ddv/models/con2/include/ddverify/interrupt.h line 14
struct registered_irq registered_irq[16l];
// c::registered_pci_driver
// file /usr/local/ddv/models/con2/include/ddverify/pci.h line 14
struct ddv_pci_driver registered_pci_driver;
// c::shared_workqueue
// file /usr/local/ddv/models/con2/include/ddverify/workqueue.h line 8
struct work_struct *shared_workqueue[10l];
// c::tasklet_registered
// file /usr/local/ddv/models/con2/include/ddverify/tasklet.h line 15
struct ddv_tasklet tasklet_registered[10l];
// c::tco_expect_close
// file i8xx_tco.c line 101
static char tco_expect_close;
// c::tco_lock
// file i8xx_tco.c line 99
static struct anon$1 tco_lock;
// c::timer_alive
// file i8xx_tco.c line 100
static unsigned long int timer_alive;
// c::timer_registered
// file /usr/local/ddv/models/con2/include/ddverify/timer.h line 14
struct ddv_timer timer_registered[5l];

// c::__get_free_page
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 13
unsigned long int __get_free_page(unsigned int gfp_mask)
{

__CPROVER_HIDE:
  ;
  if(!((16u & gfp_mask) == 0u))
    assert_context_process$link0();

  return nondet_ulong();
}

// c::__get_free_pages
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 5
unsigned long int __get_free_pages(unsigned int gfp_mask, unsigned int order)
{

__CPROVER_HIDE:
  ;
  if(!((16u & gfp_mask) == 0u))
    assert_context_process$link0();

  return nondet_ulong();
}

// c::__get_user
// file /usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c line 5
signed int __get_user(signed int size, void *ptr)
{

__CPROVER_HIDE:
  ;
  assert_context_process$link4();
  signed int return_value_nondet_int$1 = nondet_int();
  return return_value_nondet_int$1;
}

// c::__put_user
// file /usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c line 21
signed int __put_user(signed int size, void *ptr)
{

__CPROVER_HIDE:
  ;
  assert_context_process$link4();
  signed int return_value_nondet_int$1 = nondet_int();
  return return_value_nondet_int$1;
}

// c::add_disk
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 38
void add_disk(struct gendisk$link12 *disk)
{
  if((signed int)number_genhd_registered < 10)
  {
    /* array `genhd_registered' lower bound */
    assert(0 + (signed long int)number_genhd_registered * 248 >= 0);
    /* array `genhd_registered' upper bound */
    assert((signed long int)number_genhd_registered < 10l);
    genhd_registered[(signed long int)number_genhd_registered].gd = disk;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned int)32ul /*[[struct block_device]]*/);
    /* array `genhd_registered' lower bound */
    assert(0 + (signed long int)number_genhd_registered * 248 >= 0);
    /* array `genhd_registered' upper bound */
    assert((signed long int)number_genhd_registered < 10l);
    genhd_registered[(signed long int)number_genhd_registered].inode.i_bdev = (struct block_device$link3 *)return_value_malloc$1;
    genhd_registered[(signed long int)number_genhd_registered].inode.i_bdev->bd_disk = disk;
    number_genhd_registered = number_genhd_registered + 1;
  }

}

// c::add_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 15
void add_timer(struct timer_list *timer)
{
  timer->__ddv_active = (signed short int)1;
}

// c::add_timer_on
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 24
void add_timer_on(struct timer_list *timer, signed int cpu)
{
  add_timer(timer);
}

// c::alloc_chrdev_region
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 9
signed int alloc_chrdev_region(unsigned int *dev, unsigned int baseminor, unsigned int count, const char *name)
{
  signed int major;
  signed int return_value = nondet_int();
  __CPROVER_assume(return_value == 0 || return_value == -1);
  if(return_value == 0)
  {
    unsigned int return_value_nondet_uint$1 = nondet_uint();
    major = (signed int)return_value_nondet_uint$1;
    *dev = (unsigned int)(major << 20) | baseminor;
  }

  return return_value;
}

// c::alloc_disk
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 22
struct gendisk$link12 * alloc_disk(signed int minors)
{
  struct gendisk$link12 *gd;
  if((signed int)number_fixed_genhd_used < 10)
  {
    gd = &fixed_gendisk[(signed long int)number_fixed_genhd_used];
    gd->minors = minors;
    number_fixed_genhd_used = number_fixed_genhd_used + 1;
    return gd;
  }

  else
    return (struct gendisk$link12 *)NULL;
}

// c::alloc_page
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 46
struct page * alloc_page(unsigned int gfp_mask)
{

__CPROVER_HIDE:
  ;
  if(!((16u & gfp_mask) == 0u))
    assert_context_process$link0();

  return nondet_0();
}

// c::alloc_pages
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 38
struct page * alloc_pages(unsigned int gfp_mask, unsigned int order)
{

__CPROVER_HIDE:
  ;
  if(!((16u & gfp_mask) == 0u))
    assert_context_process$link0();

  return nondet_0();
}

// c::alloc_tty_driver
// file /usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c line 4
struct tty_driver * alloc_tty_driver(signed int lines)
{
  if(global_tty_driver.allocated == 0)
  {
    global_tty_driver.driver.magic = 21506;
    global_tty_driver.driver.num = lines;
  }

  else
    return (struct tty_driver *)NULL;
  return nondet_1();
}

// c::assert_context_process
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process()
{
  return nondet_int();
}

// c::assert_context_process$link0
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link0()
{
  return nondet_int();
}

// c::assert_context_process$link1
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link1()
{
  return nondet_int();
}

// c::assert_context_process$link2
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link2()
{
  return nondet_int();
}

// c::assert_context_process$link3
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link3()
{
  return nondet_int();
}

// c::assert_context_process$link4
// file /usr/local/ddv/models/con2/include/ddverify/ddverify.h line 32
static signed int assert_context_process$link4()
{
  return nondet_int();
}

// c::blk_alloc_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 34
struct request_queue$link10 * blk_alloc_queue(unsigned int gfp_mask)
{
  struct request_queue$link10 *queue;
  signed int return_value_nondet_int$1 = nondet_int();
  if(!(return_value_nondet_int$1 == 0))
  {
    queue=get_fixed_request_queue();
    queue->request_fn = (void (*)(struct request_queue$link10 *))NULL;
    queue->make_request_fn = (signed int (*)(struct request_queue$link10 *, struct bio$link9 *))NULL;
    queue->__ddv_queue_alive = 1;
    return queue;
  }

  else
    return (struct request_queue$link10 *)NULL;
}

// c::blk_cleanup_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 69
void blk_cleanup_queue(struct request_queue$link10 *q)
{
  q->__ddv_queue_alive = 0;
}

// c::blk_init_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 16
struct request_queue$link10 * blk_init_queue(void (*rfn)(struct request_queue$link10 *), struct anon$1 *lock)
{
  struct request_queue$link10 *queue;
  signed int return_value_nondet_int$1 = nondet_int();
  if(!(return_value_nondet_int$1 == 0))
  {
    queue=get_fixed_request_queue();
    queue->queue_lock = lock;
    queue->request_fn = rfn;
    queue->make_request_fn = (signed int (*)(struct request_queue$link10 *, struct bio$link9 *))NULL;
    queue->__ddv_queue_alive = 1;
    return queue;
  }

  else
    return (struct request_queue$link10 *)NULL;
}

// c::blk_queue_hardsect_size
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 64
void blk_queue_hardsect_size(struct request_queue$link10 *q, unsigned short int size)
{
  q->hardsect_size = size;
}

// c::blk_queue_make_request
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 51
void blk_queue_make_request(struct request_queue$link10 *q, signed int (*mfn)(struct request_queue$link10 *, struct bio$link9 *))
{
  q->make_request_fn = mfn;
}

// c::call_cdev_functions
// file /usr/local/ddv/models/con2/src/ddverify/cdev.c line 5
void call_cdev_functions()
{
  signed int cdev_no;
  signed int function_no;
  signed int result;
  signed long long int loff_t_value;
  signed int int_value;
  unsigned int uint_value;
  unsigned long int ulong_value;
  char char_value;
  unsigned int size_t_value;
  if((signed int)number_cdev_registered == 0)
    return;

  unsigned short int return_value_nondet_ushort$1 = nondet_ushort();
  cdev_no = (signed int)return_value_nondet_ushort$1;
  __CPROVER_assume(0 <= cdev_no && cdev_no < (signed int)number_cdev_registered);
  unsigned short int return_value_nondet_ushort$2 = nondet_ushort();
  switch((signed int)return_value_nondet_ushort$2)
  {

    case 0:
      {
        /* array `cdev_registered' lower bound */
        assert(0 + (signed long int)cdev_no * 112 >= 0);
        /* array `cdev_registered' upper bound */
        assert((signed long int)cdev_no < 10l);
        if(!(cdev_registered[(signed long int)cdev_no].cdevp->ops->llseek == ((signed long long int (*)(struct file *, signed long long int, signed int))NULL)))
        {
          loff_t_value = nondet_loff_t();
          int_value = nondet_int();
          cdev_registered[(signed long int)cdev_no].cdevp->ops->llseek(&cdev_registered[(signed long int)cdev_no].filp, loff_t_value, int_value);
        }

        goto __CPROVER_DUMP_L35;
      }
    case 1:
      {
        /* array `cdev_registered' lower bound */
        assert(0 + (signed long int)cdev_no * 112 >= 0);
        /* array `cdev_registered' upper bound */
        assert((signed long int)cdev_no < 10l);
        if(!(cdev_registered[(signed long int)cdev_no].cdevp->ops->read == ((signed int (*)(struct file *, char *, unsigned int, signed long long int *))NULL)))
        {
          char_value = nondet_char();
          size_t_value = nondet_uint();
          cdev_registered[(signed long int)cdev_no].cdevp->ops->read(&cdev_registered[(signed long int)cdev_no].filp, &char_value, size_t_value, &loff_t_value);
        }

        goto __CPROVER_DUMP_L35;
      }
    case 2:
      goto __CPROVER_DUMP_L35;
    case 3:
      {
        /* array `cdev_registered' lower bound */
        assert(0 + (signed long int)cdev_no * 112 >= 0);
        /* array `cdev_registered' upper bound */
        assert((signed long int)cdev_no < 10l);
        if(!(cdev_registered[(signed long int)cdev_no].cdevp->ops->write == ((signed int (*)(struct file *, const char *, unsigned int, signed long long int *))NULL)))
        {
          char_value = nondet_char();
          size_t_value = nondet_uint();
          cdev_registered[(signed long int)cdev_no].cdevp->ops->write(&cdev_registered[(signed long int)cdev_no].filp, &char_value, size_t_value, &loff_t_value);
        }

        goto __CPROVER_DUMP_L35;
      }
    case 4:
      goto __CPROVER_DUMP_L35;
    case 5:
      goto __CPROVER_DUMP_L35;
    case 6:
      goto __CPROVER_DUMP_L35;
    case 7:
      {
        /* array `cdev_registered' lower bound */
        assert(0 + (signed long int)cdev_no * 112 >= 0);
        /* array `cdev_registered' upper bound */
        assert((signed long int)cdev_no < 10l);
        if(!(cdev_registered[(signed long int)cdev_no].cdevp->ops->ioctl == ((signed int (*)(struct inode *, struct file *, unsigned int, unsigned long int))NULL)))
        {
          uint_value = nondet_uint();
          ulong_value = nondet_ulong();
          cdev_registered[(signed long int)cdev_no].cdevp->ops->ioctl(&cdev_registered[(signed long int)cdev_no].inode, &cdev_registered[(signed long int)cdev_no].filp, uint_value, ulong_value);
        }

        goto __CPROVER_DUMP_L35;
      }
    case 8:
      goto __CPROVER_DUMP_L35;
    case 9:
      goto __CPROVER_DUMP_L35;
    case 10:
      goto __CPROVER_DUMP_L35;
    case 11:
      {
        /* array `cdev_registered' lower bound */
        assert(0 + (signed long int)cdev_no * 112 >= 0);
        /* array `cdev_registered' upper bound */
        assert((signed long int)cdev_no < 10l);
        if(!(cdev_registered[(signed long int)cdev_no].cdevp->ops->open == ((signed int (*)(struct inode *, struct file *))NULL)))
        {
          if(cdev_registered[(signed long int)cdev_no].open == 0)
          {
            result=cdev_registered[(signed long int)cdev_no].cdevp->ops->open(&cdev_registered[(signed long int)cdev_no].inode, &cdev_registered[(signed long int)cdev_no].filp);
            if(result == 0)
            {
              /* array `cdev_registered' lower bound */
              assert(0 + (signed long int)cdev_no * 112 >= 0);
              /* array `cdev_registered' upper bound */
              assert((signed long int)cdev_no < 10l);
              cdev_registered[(signed long int)cdev_no].open = 1;
            }

          }

        }

        goto __CPROVER_DUMP_L35;
      }
    case 12:
      goto __CPROVER_DUMP_L35;
    case 13:
      {
        /* array `cdev_registered' lower bound */
        assert(0 + (signed long int)cdev_no * 112 >= 0);
        /* array `cdev_registered' upper bound */
        assert((signed long int)cdev_no < 10l);
        if(!(cdev_registered[(signed long int)cdev_no].cdevp->ops->release == ((signed int (*)(struct inode *, struct file *))NULL)))
        {
          if(!(cdev_registered[(signed long int)cdev_no].open == 0))
          {
            result=cdev_registered[(signed long int)cdev_no].cdevp->ops->release(&cdev_registered[(signed long int)cdev_no].inode, &cdev_registered[(signed long int)cdev_no].filp);
            if(result == 0)
            {
              /* array `cdev_registered' lower bound */
              assert(0 + (signed long int)cdev_no * 112 >= 0);
              /* array `cdev_registered' upper bound */
              assert((signed long int)cdev_no < 10l);
              cdev_registered[(signed long int)cdev_no].open = 0;
            }

          }

        }

        goto __CPROVER_DUMP_L35;
      }
    case 14:
      goto __CPROVER_DUMP_L35;
    case 15:
      goto __CPROVER_DUMP_L35;
    case 16:
      goto __CPROVER_DUMP_L35;
    case 17:
      goto __CPROVER_DUMP_L35;
    case 18:
      goto __CPROVER_DUMP_L35;
    case 19:
      goto __CPROVER_DUMP_L35;
    case 20:
      goto __CPROVER_DUMP_L35;
    case 21:
      goto __CPROVER_DUMP_L35;
    case 22:
      goto __CPROVER_DUMP_L35;
    case 23:
      goto __CPROVER_DUMP_L35;
    case 24:
      goto __CPROVER_DUMP_L35;
    case 25:
      goto __CPROVER_DUMP_L35;
    case 26:
      ;
    default:

      __CPROVER_DUMP_L35:
        ;
  }
}

// c::call_ddv
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 95
signed int call_ddv()
{
  signed int err;
  current_execution_context = 1;
  init_kernel();
  err=_ddv_module_init();
  if(!(err == 0))
    return -1;

  ddv();
  current_execution_context = 1;
  _ddv_module_exit();
  return 0;
}

// c::call_interrupt_handler
// file /usr/local/ddv/models/con2/include/ddverify/interrupt.h line 16
void call_interrupt_handler()
{
  unsigned short int i;
  struct pt_regs regs;
  signed int return_value_nondet_int$1 = nondet_int();
  i = (unsigned short int)return_value_nondet_int$1;
  __CPROVER_assume((signed int)i < 16);
  /* array `registered_irq' upper bound */
  assert((signed long int)i < 16l);
  if(!(registered_irq[(signed long int)i].handler == ((signed int (*)(signed int, void *, struct pt_regs *))NULL)))
    registered_irq[(signed long int)i].handler((signed int)i, registered_irq[(signed long int)i].dev_id, &regs);

}

// c::call_shared_workqueue_functions
// file /usr/local/ddv/models/con2/include/ddverify/workqueue.h line 10
void call_shared_workqueue_functions()
{
  unsigned short int i = nondet_ushort();
  __CPROVER_assume((signed int)i < 10);
  /* array `shared_workqueue' upper bound */
  assert((signed long int)i < 10l);
  if(!(shared_workqueue[(signed long int)i] == ((struct work_struct *)NULL)))
  {
    shared_workqueue[(signed long int)i]->func(shared_workqueue[(signed long int)i]->data);
    /* array `shared_workqueue' upper bound */
    assert((signed long int)i < 10l);
    shared_workqueue[(signed long int)i] = (struct work_struct *)NULL;
  }

}

// c::call_tasklet_functions
// file /usr/local/ddv/models/con2/include/ddverify/tasklet.h line 17
void call_tasklet_functions()
{
  unsigned int i;
  __CPROVER_assume(i < (unsigned int)10);
  /* array `tasklet_registered' upper bound */
  assert((signed long int)i < 10l);
  if(!(tasklet_registered[(signed long int)i].tasklet == ((struct tasklet_struct *)NULL)))
  {
    if(tasklet_registered[(signed long int)i].tasklet->count == 0)
    {
      tasklet_registered[(signed long int)i].is_running = (unsigned short int)1;
      tasklet_registered[(signed long int)i].tasklet->func(tasklet_registered[(signed long int)i].tasklet->data);
      /* array `tasklet_registered' upper bound */
      assert((signed long int)i < 10l);
      tasklet_registered[(signed long int)i].is_running = (unsigned short int)0;
      tasklet_registered[(signed long int)i].tasklet = (struct tasklet_struct *)NULL;
    }

  }

}

// c::cdev_add
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 72
signed int cdev_add(struct cdev$link0 *p, unsigned int dev, unsigned int count)
{
  p->dev = dev;
  p->count = count;
  signed int return_value = nondet_int();
  __CPROVER_assume(return_value == 0 || return_value == -1);
  if(return_value == 0)
  {
    if((signed int)number_cdev_registered < 10)
    {
      /* array `cdev_registered' lower bound */
      assert(0 + (signed long int)number_cdev_registered * 112 >= 0);
      /* array `cdev_registered' upper bound */
      assert((signed long int)number_cdev_registered < 10l);
      cdev_registered[(signed long int)number_cdev_registered].cdevp = p;
      cdev_registered[(signed long int)number_cdev_registered].inode.i_rdev = dev;
      cdev_registered[(signed long int)number_cdev_registered].inode.i_cdev = p;
      cdev_registered[(signed long int)number_cdev_registered].open = 0;
      number_cdev_registered = number_cdev_registered + 1;
    }

    else
      return -1;
  }

  return return_value;
}

// c::cdev_alloc
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 60
struct cdev$link0 * cdev_alloc(void)
{
  signed int tmp_post$1;
  if(fixed_cdev_used < 10)
  {
    tmp_post$1 = fixed_cdev_used;
    fixed_cdev_used = fixed_cdev_used + 1;
    return &fixed_cdev[(signed long int)tmp_post$1];
  }

  return nondet_2();
}

// c::cdev_del
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 97
void cdev_del(struct cdev$link0 *p)
{
  signed int i = 0;
  while(!(i >= (signed int)number_cdev_registered))
  {
    /* array `cdev_registered' lower bound */
    assert(0 + (signed long int)i * 112 >= 0);
    /* array `cdev_registered' upper bound */
    assert((signed long int)i < 10l);
    if(cdev_registered[(signed long int)i].cdevp == p)
    {
      cdev_registered[(signed long int)i].cdevp = ((struct cdev$link0 *)NULL);
      return;
    }

    i = i + 1;
  }
}

// c::cdev_init
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 67
void cdev_init(struct cdev$link0 *cdev, struct file_operations$link5 *fops)
{
  cdev->ops = fops;
}

// c::copy_from_user
// file /usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c line 45
unsigned long int copy_from_user(void *to, void *from, unsigned long int n)
{

__CPROVER_HIDE:
  ;
  assert_context_process$link4();
  unsigned long int return_value_nondet_ulong$1 = nondet_ulong();
  return return_value_nondet_ulong$1;
}

// c::copy_to_user
// file /usr/local/ddv/models/con2/include/asm/uaccess.h line 51
unsigned long int copy_to_user(void *to, const void *from, unsigned long int n)
{

__CPROVER_HIDE:
  ;
  assert_context_process$link4();
  unsigned long int return_value_nondet_ulong$1 = nondet_ulong();
  return return_value_nondet_ulong$1;
}

// c::ddv
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 75
void ddv()
{
  unsigned short int random;
  struct __pthread_t_struct thread;
  pthread_create(&thread, (const struct __pthread_attr_t_struct *)NULL, ddv_2, NULL);
  signed int return_value_nondet_int$1;
  do
  {
    current_execution_context = 1;
    call_cdev_functions();
    return_value_nondet_int$1 = nondet_int();
  }
  while(return_value_nondet_int$1 != 0);
}

// c::ddv_2
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 31
static void * ddv_2(void *arg)
{
  unsigned short int random;
  do
  {
    random = nondet_ushort();
    switch((signed int)random)
    {

      case 1:
        {
          current_execution_context = 2;
          call_timer_functions();
          current_execution_context = 1;
          goto __CPROVER_DUMP_L7;
        }
      case 2:
        {
          current_execution_context = 2;
          call_interrupt_handler();
          current_execution_context = 1;
          goto __CPROVER_DUMP_L7;
        }
      case 3:
        {
          current_execution_context = 1;
          call_shared_workqueue_functions();
          current_execution_context = 1;
          goto __CPROVER_DUMP_L7;
        }
      case 4:
        {
          current_execution_context = 2;
          call_tasklet_functions();
          current_execution_context = 1;
          goto __CPROVER_DUMP_L7;
        }
      case 5:
        {
          current_execution_context = 1;
          call_pci_functions();
          current_execution_context = 1;
        }
      default:
        ;
    }

  __CPROVER_DUMP_L7:
    ;
  }
  while(random != 0);
  return nondet_3();
}

// c::del_gendisk
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 49
void del_gendisk(struct gendisk$link12 *gp)
{
  signed int i = 0;
  while(!(i >= (signed int)number_genhd_registered))
  {
    /* array `genhd_registered' lower bound */
    assert(0 + (signed long int)i * 248 >= 0);
    /* array `genhd_registered' upper bound */
    assert((signed long int)i < 10l);
    if(genhd_registered[(signed long int)i].gd == gp)
      genhd_registered[(signed long int)i].gd = (struct gendisk$link12 *)NULL;

    i = i + 1;
  }
}

// c::del_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 30
signed int del_timer(struct timer_list *timer)
{
  timer->__ddv_active = (signed short int)0;
  return nondet_int();
}

// c::down
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 33
void down(struct semaphore *sem)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(sem->locked == 0)
    {
      sem->locked = 1;
      __CPROVER_atomic_end();
      return;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
}

// c::down_interruptible
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 58
signed int down_interruptible(struct semaphore *sem)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(sem->locked == 0)
    {
      sem->locked = 1;
      __CPROVER_atomic_end();
      return 0;
    }

    signed int return_value_nondet_int$1 = nondet_int();
    if(!(return_value_nondet_int$1 == 0))
    {
      __CPROVER_atomic_end();
      return -1;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
  return nondet_int();
}

// c::down_trylock
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 88
signed int down_trylock(struct semaphore *sem)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  if(sem->locked == 0)
  {
    sem->locked = 1;
    __CPROVER_atomic_end();
    return -1;
  }

  __CPROVER_atomic_end();
  return 0;
}

// c::end_request
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 56
void end_request(struct request$link19 *req, signed int uptodate)
{
  signed int genhd_no = req->rq_disk->queue->__ddv_genhd_no;
  /* array `genhd_registered' lower bound */
  assert(0 + (signed long int)genhd_no * 248 >= 0);
  /* array `genhd_registered' upper bound */
  assert((signed long int)genhd_no < 10l);
  genhd_registered[(signed long int)genhd_no].requests_open = 0;
}

// c::free_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c line 17
void free_irq(unsigned int irq, void *dev_id)
{
  /* array `registered_irq' upper bound */
  assert((signed long int)irq < 16l);
  registered_irq[(signed long int)irq].handler = (signed int (*)(signed int, void *, struct pt_regs *))NULL;
  registered_irq[(signed long int)irq].dev_id = NULL;
}

// c::get_fixed_request_queue
// file /usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c line 7
struct request_queue$link10 * get_fixed_request_queue()
{
  signed int tmp_post$1;
  if(number_request_queue_used < 10)
  {
    tmp_post$1 = number_request_queue_used;
    number_request_queue_used = number_request_queue_used + 1;
    return &fixed_request_queue[(signed long int)tmp_post$1];
  }

  else
    return (struct request_queue$link10 *)NULL;
}

// c::get_user
// file /usr/local/ddv/models/con2/include/asm/uaccess.h line 43
signed int get_user(signed int size, void *ptr)
{

__CPROVER_HIDE:
  ;
  assert_context_process$link4();
  signed int return_value_nondet_int$1 = nondet_int();
  return return_value_nondet_int$1;
}

// c::get_zeroed_page
// file /usr/local/ddv/models/con2/src/linux/mm/page_alloc.c line 21
unsigned long int get_zeroed_page(unsigned int gfp_mask)
{

__CPROVER_HIDE:
  ;
  if(!((16u & gfp_mask) == 0u))
    assert_context_process$link0();

  return nondet_ulong();
}

// c::i8xx_tco_getdevice
// file i8xx_tco.c line 428
static unsigned char i8xx_tco_getdevice(void)
{
  struct pci_dev$link15 *dev = (struct pci_dev$link15 *)NULL;
  unsigned char val1;
  unsigned char val2;
  unsigned short int badr;
  signed int return_value_pci_get_device$1;
  signed int return_value_pci_match_id$2;
  do
  {
    return_value_pci_get_device$1=pci_get_device(~0, ~0, dev);
    dev = (struct pci_dev$link15 *)return_value_pci_get_device$1;
    if(dev == ((struct pci_dev$link15 *)NULL))
      goto __CPROVER_DUMP_L3;

    return_value_pci_match_id$2=pci_match_id((const void *)i8xx_tco_pci_tbl, dev);
    if(return_value_pci_match_id$2 == 0)
      goto __CPROVER_DUMP_L2;

    i8xx_tco_pci = dev;
    goto __CPROVER_DUMP_L3;

  __CPROVER_DUMP_L2:
    ;
  }
  while(TRUE);

__CPROVER_DUMP_L3:
  ;
  if(!(i8xx_tco_pci == ((struct pci_dev$link15 *)NULL)))
  {
    pci_read_config_byte(i8xx_tco_pci, 64, &val1);
    pci_read_config_byte(i8xx_tco_pci, 65, &val2);
    badr = (unsigned short int)(((signed int)val2 << 1 | (signed int)val1 >> 7) << 7);
    ACPIBASE = (unsigned int)badr;
    if(!((signed int)badr == 1))
    {
      if((signed int)badr == 0)
        goto __CPROVER_DUMP_L4;

    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      printk("<3>i8xx TCO timer: failed to get TCOBASE address\n");
      pci_dev_put(i8xx_tco_pci);
      return (unsigned char)0;
    }
    pci_read_config_byte(i8xx_tco_pci, 212, &val1);
    if(!((2 & (signed int)val1) == 0))
    {
      val1 = val1 & (unsigned char)253;
      pci_write_config_byte(i8xx_tco_pci, 212, val1);
      pci_read_config_byte(i8xx_tco_pci, 212, &val1);
      if(!((2 & (signed int)val1) == 0))
      {
        printk("<3>i8xx TCO timer: failed to reset NO_REBOOT flag, reboot disabled by hardware\n");
        pci_dev_put(i8xx_tco_pci);
        return (unsigned char)0;
      }

    }

    val1 = val1 | (unsigned char)2;
    pci_write_config_byte(i8xx_tco_pci, 212, val1);
    struct resource *return_value_request_region$3;
    return_value_request_region$3=request_region((unsigned long int)(ACPIBASE + (unsigned int)48 + (unsigned int)1), (unsigned long int)1, "i8xx TCO");
    if(return_value_request_region$3 == ((struct resource *)NULL))
    {
      printk("<3>i8xx TCO timer: I/O address 0x%04x already in use\n", ACPIBASE + (unsigned int)48 + (unsigned int)1);
      pci_dev_put(i8xx_tco_pci);
      return (unsigned char)0;
    }

    val1=inb(ACPIBASE + (unsigned int)48 + (unsigned int)1);
    val1 = val1 & (unsigned char)223;
    outb(val1, ACPIBASE + (unsigned int)48 + (unsigned int)1);
    release_region((unsigned long int)(ACPIBASE + (unsigned int)48 + (unsigned int)1), (unsigned long int)1);
    return (unsigned char)1;
  }

  return (unsigned char)0;
}

// c::i8xx_tco_ioctl
// file i8xx_tco.c line 287
static signed int i8xx_tco_ioctl(struct inode$link7 *inode, struct file$link13 *file, unsigned int cmd, unsigned long int arg)
{
  static struct watchdog_info ident = (struct watchdog_info){ .options=(unsigned int)(128 | 32768 | 256), .firmware_version=(unsigned int)0,
    .identity={ 105, 56, 120, 120, 32, 84, 67, 79, 32, 116, 105, 109, 101, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
  signed int new_options;
  signed int retval = -22;
  signed int new_heartbeat;
  signed int time_left;
  void *argp = (void *)arg;
  signed int *p = (signed int *)argp;
  unsigned long int return_value_copy_to_user$1;
  signed int return_value_put_user$2;
  signed int return_value_put_user$6;
  if(!(cmd == 2150127360u))
  {
    if(cmd == 2147768065u || cmd == 2147768066u)
      goto __CPROVER_DUMP_L2;

    if(cmd == 2147768069u)
      goto __CPROVER_DUMP_L3;

    if(cmd == 2147768068u)
      goto __CPROVER_DUMP_L4;

    if(cmd == 3221509894u)
      goto __CPROVER_DUMP_L8;

    if(cmd == 2147768071u)
      goto __CPROVER_DUMP_L11;

    if(cmd == 2147768074u)
      goto __CPROVER_DUMP_L12;

  }

  else
  {
    return_value_copy_to_user$1=copy_to_user(argp, (const void *)&ident, 40ul /*[[struct watchdog_info]]*/);
    return return_value_copy_to_user$1 != 0ul ? -14 : 0;

  __CPROVER_DUMP_L2:
    ;
    return_value_put_user$2=put_user(0, (void *)p);
    return return_value_put_user$2;

  __CPROVER_DUMP_L3:
    ;
    tco_timer_keepalive();
    return 0;

  __CPROVER_DUMP_L4:
    ;
    signed int return_value_get_user$3;
    return_value_get_user$3=get_user(new_options, (void *)p);
    if(!(return_value_get_user$3 == 0))
      return -14;

    if(!((1 & new_options) == 0))
    {
      tco_timer_stop();
      retval = 0;
    }

    if(!((2 & new_options) == 0))
    {
      tco_timer_keepalive();
      tco_timer_start();
      retval = 0;
    }

    return retval;

  __CPROVER_DUMP_L8:
    ;
    signed int return_value_get_user$4;
    return_value_get_user$4=get_user(new_heartbeat, (void *)p);
    if(!(return_value_get_user$4 == 0))
      return -14;

    signed int return_value_tco_timer_set_heartbeat$5;
    return_value_tco_timer_set_heartbeat$5=tco_timer_set_heartbeat(new_heartbeat);
    if(!(return_value_tco_timer_set_heartbeat$5 == 0))
      return -22;

    tco_timer_keepalive();

  __CPROVER_DUMP_L11:
    ;
    return_value_put_user$6=put_user(heartbeat, (void *)p);
    return return_value_put_user$6;

  __CPROVER_DUMP_L12:
    ;
    signed int return_value_tco_timer_get_timeleft$7;
    return_value_tco_timer_get_timeleft$7=tco_timer_get_timeleft(&time_left);
    if(!(return_value_tco_timer_get_timeleft$7 == 0))
      return -22;

    signed int return_value_put_user$8;
    return_value_put_user$8=put_user(time_left, (void *)p);
    return return_value_put_user$8;
  }
  return -25;
}

// c::i8xx_tco_notify_sys
// file i8xx_tco.c line 367
static signed int i8xx_tco_notify_sys(struct notifier_block *this, unsigned long int code, void *unused)
{
  if(!(code == 1ul))
  {
    if(code == 2ul)
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    tco_timer_stop();
  }
  return 0;
}

// c::i8xx_tco_open
// file i8xx_tco.c line 229
static signed int i8xx_tco_open(struct inode$link7 *inode, struct file$link13 *file)
{
  signed int return_value_test_and_set_bit$1;
  return_value_test_and_set_bit$1=test_and_set_bit(0, &timer_alive);
  if(!(return_value_test_and_set_bit$1 == 0))
    return -16;

  tco_timer_keepalive();
  tco_timer_start();
  signed int return_value_nonseekable_open$2;
  return_value_nonseekable_open$2=nonseekable_open(inode, file);
  return return_value_nonseekable_open$2;
}

// c::i8xx_tco_release
// file i8xx_tco.c line 243
static signed int i8xx_tco_release(struct inode$link7 *inode, struct file$link13 *file)
{
  if((signed int)tco_expect_close == 42)
    tco_timer_stop();

  else
  {
    printk("<2>i8xx TCO timer: Unexpected close, not stopping watchdog!\n");
    tco_timer_keepalive();
  }
  clear_bit(0, &timer_alive);
  tco_expect_close = (char)0;
  return 0;
}

// c::i8xx_tco_write
// file i8xx_tco.c line 259
static signed int i8xx_tco_write(struct file$link13 *file, const char *data, unsigned int len, signed long long int *ppos)
{
  if(!(len == 0u))
  {
    if(nowayout == 0)
    {
      unsigned int i;
      tco_expect_close = (char)0;
      i = (unsigned int)0;
      while(!(i == len))
      {
        char c;
        signed int return_value_get_user$1;
        return_value_get_user$1=get_user((signed int)c, (void *)(data + (signed long int)i));
        if(!(return_value_get_user$1 == 0))
          return -14;

        if((signed int)c == 86)
          tco_expect_close = (char)42;

        i = i + 1u;
      }
    }

    tco_timer_keepalive();
  }

  return (signed int)len;
}

// c::inb
// file /usr/local/ddv/models/con2/include/asm/io.h line 14
unsigned char inb(unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
  unsigned char return_value_nondet_uchar$1 = nondet_uchar();
  return return_value_nondet_uchar$1;
}

// c::inb_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 74
unsigned char inb_p(unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
  unsigned char return_value_nondet_uchar$1 = nondet_uchar();
  return return_value_nondet_uchar$1;
}

// c::init_MUTEX
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 15
void init_MUTEX(struct semaphore *sem)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  sem->init = 1;
  sem->locked = 0;
  __CPROVER_atomic_end();
}

// c::init_MUTEX_LOCKED
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 24
void init_MUTEX_LOCKED(struct semaphore *sem)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  sem->init = 1;
  sem->locked = 1;
  __CPROVER_atomic_end();
}

// c::init_kernel
// file /usr/local/ddv/models/con2/src/ddverify/ddverify.c line 15
void init_kernel()
{
  signed int i;
  spin_lock_init(&kernel_lock);
  i = 0;
  while(i < 10)
  {
    /* array `shared_workqueue' lower bound */
    assert(0 + (signed long int)i * 8 >= 0);
    /* array `shared_workqueue' upper bound */
    assert((signed long int)i < 10l);
    shared_workqueue[(signed long int)i] = (struct work_struct *)NULL;
    i = i + 1;
  }
  i = 0;
  while(i < 10)
  {
    /* array `tasklet_registered' lower bound */
    assert(0 + (signed long int)i * 16 >= 0);
    /* array `tasklet_registered' upper bound */
    assert((signed long int)i < 10l);
    tasklet_registered[(signed long int)i].tasklet = (struct tasklet_struct *)NULL;
    tasklet_registered[(signed long int)i].is_running = (unsigned short int)0;
    i = i + 1;
  }
}

// c::init_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 4
void init_timer(struct timer_list *timer)
{
  if((signed int)number_timer_registered < 5)
  {
    timer->__ddv_active = (signed short int)0;
    timer->__ddv_init = (signed short int)1;
    /* array `timer_registered' lower bound */
    assert(0 + (signed long int)number_timer_registered * 8 >= 0);
    /* array `timer_registered' upper bound */
    assert((signed long int)number_timer_registered < 5l);
    timer_registered[(signed long int)number_timer_registered].timer = timer;
    number_timer_registered = number_timer_registered + 1;
  }

}

// c::init_waitqueue_head
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 3
void init_waitqueue_head(struct __wait_queue_head *q)
{
  q->init = 1;
}

// c::inl
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 60
unsigned int inl(unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
  unsigned int return_value_nondet_unsigned$1 = nondet_uint();
  return return_value_nondet_unsigned$1;
}

// c::inl_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 102
unsigned int inl_p(unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
  unsigned int return_value_nondet_unsigned$1 = nondet_uint();
  return return_value_nondet_unsigned$1;
}

// c::interruptible_sleep_on
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 40
void interruptible_sleep_on(struct __wait_queue_head *q)
{
  ;
}

// c::inw
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 46
unsigned short int inw(unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
  unsigned short int return_value_nondet_ushort$1 = nondet_ushort();
  return return_value_nondet_ushort$1;
}

// c::inw_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 88
unsigned short int inw_p(unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
  unsigned short int return_value_nondet_ushort$1 = nondet_ushort();
  return return_value_nondet_ushort$1;
}

// c::kmalloc
// file /usr/local/ddv/models/con2/src/linux/mm/slab.c line 6
void * kmalloc(unsigned int size, unsigned int flags)
{
  if(!((16u & flags) == 0u))
    assert_context_process$link3();

  void *return_value_malloc$1;
  return_value_malloc$1=malloc(size);
  return return_value_malloc$1;
}

// c::kzalloc
// file /usr/local/ddv/models/con2/src/linux/mm/slab.c line 15
void * kzalloc(unsigned int size, unsigned int flags)
{
  if(!((16u & flags) == 0u))
    assert_context_process$link3();

  void *return_value_malloc$1;
  return_value_malloc$1=malloc(size);
  return return_value_malloc$1;
}

// c::main
// file __main.c line 4
signed int main()
{
  _ddv_module_init = watchdog_init;
  _ddv_module_exit = watchdog_cleanup;
  call_ddv();
  return 0;
}

// c::misc_register
// file /usr/local/ddv/models/con2/include/linux/miscdevice.h line 40
signed int misc_register(struct miscdevice$link16 *misc)
{
  signed int i;
  unsigned int dev;
  if(fixed_cdev_used < 10)
  {
    i = fixed_cdev_used;
    fixed_cdev_used = fixed_cdev_used + 1;
    /* array `fixed_cdev' lower bound */
    assert(0 + (signed long int)i * 24 >= 0);
    /* array `fixed_cdev' upper bound */
    assert((signed long int)i < 10l);
    fixed_cdev[(signed long int)i].owner = ((struct module *)NULL);
    fixed_cdev[(signed long int)i].ops = misc->fops;
    dev = (unsigned int)(10 << 20 | misc->minor);
    signed int return_value_cdev_add$1;
    return_value_cdev_add$1=cdev_add(&fixed_cdev[(signed long int)i], dev, (unsigned int)0);
    return return_value_cdev_add$1;
  }

  else
    return -1;
}

// c::mod_timer
// file /usr/local/ddv/models/con2/src/linux/kernel/timer.c line 35
signed int mod_timer(struct timer_list *timer, unsigned long int expires)
{
  timer->expires = expires;
  timer->__ddv_active = (signed short int)1;
  return nondet_int();
}

// c::mutex_init
// file /usr/local/ddv/models/con2/src/linux/kernel/mutex.c line 4
void mutex_init(struct mutex *lock)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  lock->locked = 0;
  lock->init = 1;
  __CPROVER_atomic_end();
}

// c::mutex_lock
// file /usr/local/ddv/models/con2/src/linux/kernel/mutex.c line 16
void mutex_lock(struct mutex *lock)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(lock->locked == 0)
    {
      lock->locked = 1;
      __CPROVER_atomic_end();
      return;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
}

// c::mutex_unlock
// file /usr/local/ddv/models/con2/src/linux/kernel/mutex.c line 41
void mutex_unlock(struct mutex *lock)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  assert_context_process();
  lock->locked = 0;
  __CPROVER_atomic_end();
}

// c::outb
// file /usr/local/ddv/models/con2/include/asm/io.h line 15
void outb(unsigned char byte, unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
}

// c::outb_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 82
void outb_p(unsigned char byte, unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
}

// c::outl
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 68
void outl(unsigned int doubleword, unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
}

// c::outl_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 110
void outl_p(unsigned int doubleword, unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
}

// c::outw
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 54
void outw(unsigned short int word, unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
}

// c::outw_p
// file /usr/local/ddv/models/con2/src/linux/kernel/resource.c line 96
void outw_p(unsigned short int word, unsigned int port)
{
  do

    __CPROVER_HIDE:
      ;
  while(FALSE);
}

// c::pci_enable_device
// file /usr/local/ddv/models/con2/src/linux/pci.c line 8
signed int pci_enable_device(struct pci_dev$link1 *dev)
{
  signed int i = 0;
  while(i < 12)
  {
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)i * 32) - POINTER_OFFSET(dev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(dev) && !(POINTER_OBJECT(dev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)i * 32 + POINTER_OFFSET(dev) < (DYNAMIC_OBJECT(dev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(dev)));
    dev->resource[(signed long int)i].flags = (unsigned long int)256;
    unsigned int return_value_nondet_uint$1 = nondet_uint();
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)i * 32) - POINTER_OFFSET(dev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(dev) && !(POINTER_OBJECT(dev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)i * 32 + POINTER_OFFSET(dev) < (DYNAMIC_OBJECT(dev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(dev)));
    dev->resource[(signed long int)i].start = (unsigned long int)return_value_nondet_uint$1;
    unsigned short int return_value_nondet_ushort$2 = nondet_ushort();
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)i * 32) - POINTER_OFFSET(dev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(dev) && !(POINTER_OBJECT(dev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)i * 32 + POINTER_OFFSET(dev) < (DYNAMIC_OBJECT(dev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(dev)));
    dev->resource[(signed long int)i].end = dev->resource[(signed long int)i].start + (unsigned long int)return_value_nondet_ushort$2;
    i = i + 1;
  }
  return nondet_int();
}

// c::pci_get_class
// file /usr/local/ddv/models/con2/src/linux/pci.c line 19
struct pci_dev$link1 * pci_get_class(unsigned int class, struct pci_dev$link1 *from)
{
  if(from == ((struct pci_dev$link1 *)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned int)432ul /*[[struct pci_dev]]*/);
    from = (struct pci_dev$link1 *)return_value_malloc$1;
  }

  signed int return_value_nondet_int$2 = nondet_int();
  if(!(return_value_nondet_int$2 == 0))
  {
    from->vendor = nondet_ushort();
    from->device = nondet_ushort();
    from->irq = nondet_uint();
    __CPROVER_assume(from->irq < (unsigned int)16);
    return from;
  }

  else
    return (struct pci_dev$link1 *)NULL;
}

// c::pci_read_config_byte
// file /usr/local/ddv/models/con2/include/linux/pci.h line 111
static signed int pci_read_config_byte(struct pci_dev$link15 *dev, signed int where, unsigned char *val)
{
  signed int return_value_pci_bus_read_config_byte$1;
  return_value_pci_bus_read_config_byte$1=pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
  return return_value_pci_bus_read_config_byte$1;
}

// c::pci_register_driver
// file /usr/local/ddv/models/con2/src/linux/pci.c line 37
signed int pci_register_driver(struct pci_driver$link2 *driver)
{
  signed int return_value_nondet_int$1 = nondet_int();
  if(!(return_value_nondet_int$1 == 0))
  {
    registered_pci_driver.pci_driver = driver;
    registered_pci_driver.no_pci_device_id = (unsigned int)(8ul /*[[const struct pci_device_id *]]*/ / 32ul /*[[struct pci_device_id]]*/);
    registered_pci_driver.dev_initialized = 0;
    return 0;
  }

  else
    return -1;
}

// c::pci_release_region
// file /usr/local/ddv/models/con2/src/linux/pci.c line 56
void pci_release_region(struct pci_dev$link1 *pdev, signed int bar)
{
  _Bool tmp_if_expr$1;
  /* array.resource lower bound */
  assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
  /* array.resource upper bound */
  assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
  if(pdev->resource[(signed long int)bar].start == 0ul)
    tmp_if_expr$1 = pdev->resource[(signed long int)bar].end == pdev->resource[(signed long int)bar].start ? TRUE : FALSE;

  else
    tmp_if_expr$1 = FALSE;
  unsigned long int tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (unsigned long int)0;

  else
  {
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    tmp_if_expr$2 = (pdev->resource[(signed long int)bar].end - pdev->resource[(signed long int)bar].start) + (unsigned long int)1;
  }
  if(tmp_if_expr$2 == 0ul)
    return;

  /* array.resource lower bound */
  assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
  /* array.resource upper bound */
  assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
  _Bool tmp_if_expr$3;
  unsigned long int tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  unsigned long int tmp_if_expr$6;
  if(!((256ul & pdev->resource[(signed long int)bar].flags) == 0ul))
  {
    if(pdev->resource[(signed long int)bar].start == 0ul)
      tmp_if_expr$3 = pdev->resource[(signed long int)bar].end == pdev->resource[(signed long int)bar].start ? TRUE : FALSE;

    else
      tmp_if_expr$3 = FALSE;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (unsigned long int)0;

    else
    {
      /* array.resource lower bound */
      assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
      /* array.resource upper bound */
      assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
      tmp_if_expr$4 = (pdev->resource[(signed long int)bar].end - pdev->resource[(signed long int)bar].start) + (unsigned long int)1;
    }
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    release_region(pdev->resource[(signed long int)bar].start, tmp_if_expr$4);
  }

  else
  {
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    if(!((512ul & pdev->resource[(signed long int)bar].flags) == 0ul))
    {
      if(pdev->resource[(signed long int)bar].start == 0ul)
        tmp_if_expr$5 = pdev->resource[(signed long int)bar].end == pdev->resource[(signed long int)bar].start ? TRUE : FALSE;

      else
        tmp_if_expr$5 = FALSE;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (unsigned long int)0;

      else
      {
        /* array.resource lower bound */
        assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
        /* array.resource upper bound */
        assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
        tmp_if_expr$6 = (pdev->resource[(signed long int)bar].end - pdev->resource[(signed long int)bar].start) + (unsigned long int)1;
      }
      /* array.resource lower bound */
      assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
      /* array.resource upper bound */
      assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
      release_mem_region(pdev->resource[(signed long int)bar].start, tmp_if_expr$6);
    }

  }
}

// c::pci_release_regions
// file /usr/local/ddv/models/con2/src/linux/pci.c line 87
void pci_release_regions(struct pci_dev$link1 *pdev)
{
  signed int i = 0;
  while(i < 6)
  {
    pci_release_region(pdev, i);
    i = i + 1;
  }
}

// c::pci_request_region
// file /usr/local/ddv/models/con2/src/linux/pci.c line 68
signed int pci_request_region(struct pci_dev$link1 *pdev, signed int bar, const char *res_name)
{
  _Bool tmp_if_expr$1;
  /* array.resource lower bound */
  assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
  /* array.resource upper bound */
  assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
  if(pdev->resource[(signed long int)bar].start == 0ul)
    tmp_if_expr$1 = pdev->resource[(signed long int)bar].end == pdev->resource[(signed long int)bar].start ? TRUE : FALSE;

  else
    tmp_if_expr$1 = FALSE;
  unsigned long int tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (unsigned long int)0;

  else
  {
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    tmp_if_expr$2 = (pdev->resource[(signed long int)bar].end - pdev->resource[(signed long int)bar].start) + (unsigned long int)1;
  }
  if(tmp_if_expr$2 == 0ul)
    return 0;

  /* array.resource lower bound */
  assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
  /* array.resource upper bound */
  assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
  _Bool tmp_if_expr$3;
  unsigned long int tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  unsigned long int tmp_if_expr$7;
  if(!((256ul & pdev->resource[(signed long int)bar].flags) == 0ul))
  {
    if(pdev->resource[(signed long int)bar].start == 0ul)
      tmp_if_expr$3 = pdev->resource[(signed long int)bar].end == pdev->resource[(signed long int)bar].start ? TRUE : FALSE;

    else
      tmp_if_expr$3 = FALSE;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (unsigned long int)0;

    else
    {
      /* array.resource lower bound */
      assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
      /* array.resource upper bound */
      assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
      tmp_if_expr$4 = (pdev->resource[(signed long int)bar].end - pdev->resource[(signed long int)bar].start) + (unsigned long int)1;
    }
    struct resource *return_value_request_region$5;
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    return_value_request_region$5=request_region(pdev->resource[(signed long int)bar].start, tmp_if_expr$4, res_name);
    if(return_value_request_region$5 == ((struct resource *)NULL))
      return -16;

  }

  else
  {
    /* array.resource lower bound */
    assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
    /* array.resource upper bound */
    assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
    if(!((512ul & pdev->resource[(signed long int)bar].flags) == 0ul))
    {
      if(pdev->resource[(signed long int)bar].start == 0ul)
        tmp_if_expr$6 = pdev->resource[(signed long int)bar].end == pdev->resource[(signed long int)bar].start ? TRUE : FALSE;

      else
        tmp_if_expr$6 = FALSE;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (unsigned long int)0;

      else
      {
        /* array.resource lower bound */
        assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
        /* array.resource upper bound */
        assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
        tmp_if_expr$7 = (pdev->resource[(signed long int)bar].end - pdev->resource[(signed long int)bar].start) + (unsigned long int)1;
      }
      struct resource *return_value_request_mem_region$8;
      /* array.resource lower bound */
      assert((0 + 48 + (signed long int)bar * 32) - POINTER_OFFSET(pdev) >= 0);
      /* array.resource upper bound */
      assert(DYNAMIC_OBJECT(pdev) && !(POINTER_OBJECT(pdev) == POINTER_OBJECT(__CPROVER_malloc_object)) || 0 + 48 + (signed long int)bar * 32 + POINTER_OFFSET(pdev) < (DYNAMIC_OBJECT(pdev) ? (long int)__CPROVER_malloc_size : OBJECT_SIZE(pdev)));
      return_value_request_mem_region$8=request_mem_region(pdev->resource[(signed long int)bar].start, tmp_if_expr$7, res_name);
      if(return_value_request_mem_region$8 == ((struct resource *)NULL))
        return -16;

    }

  }
  return 0;
}

// c::pci_request_regions
// file /usr/local/ddv/models/con2/src/linux/pci.c line 95
signed int pci_request_regions(struct pci_dev$link1 *pdev, const char *res_name)
{
  signed int i = 0;
  signed int return_value_pci_request_region$1;
  while(i < 6)
  {
    return_value_pci_request_region$1=pci_request_region(pdev, i, res_name);
    if(return_value_pci_request_region$1 != 0)
      goto err_out;

    i = i + 1;
  }
  return 0;
  do
  {

  err_out:
    ;
    i = i - 1;
    if(!(i >= 0))
      goto __CPROVER_DUMP_L4;

    pci_release_region(pdev, i);
  }
  while(TRUE);

__CPROVER_DUMP_L4:
  ;
  return -16;
}

// c::pci_unregister_driver
// file /usr/local/ddv/models/con2/src/linux/pci.c line 50
void pci_unregister_driver(struct pci_driver$link2 *driver)
{
  registered_pci_driver.pci_driver = (struct pci_driver$link2 *)NULL;
  registered_pci_driver.no_pci_device_id = (unsigned int)0;
}

// c::pci_write_config_byte
// file /usr/local/ddv/models/con2/include/linux/pci.h line 123
static signed int pci_write_config_byte(struct pci_dev$link15 *dev, signed int where, unsigned char val)
{
  signed int return_value_pci_bus_write_config_byte$1;
  return_value_pci_bus_write_config_byte$1=pci_bus_write_config_byte(dev->bus, dev->devfn, where, val);
  return return_value_pci_bus_write_config_byte$1;
}

// c::pthread_create
// file /usr/local/ddv/models/con2/include/ddverify/satabs.h line 59
signed int pthread_create(struct __pthread_t_struct *__threadp, const struct __pthread_attr_t_struct *__attr, void * (*__start_routine)(void *), void *__arg)
{

__CPROVER_HIDE:
  ;
  *__threadp = nondet_pthread_t();

CPROVER_ASYNC_1:
  ;
  __start_routine(__arg);
  return 0;
}

// c::pthread_mutex_destroy
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 194
signed int pthread_mutex_destroy(struct __pthread_mutex_t_struct *__mutex)
{
  return nondet_int();
}

// c::pthread_mutex_init
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 186
signed int pthread_mutex_init(struct __pthread_mutex_t_struct *__mutex, const struct __pthread_mutexattr_t_struct *__mutex_attr)
{
  struct __pthread_mutex_t_struct i = (struct __pthread_mutex_t_struct){ .locked=0 != 0 };
  *__mutex = i;
  return nondet_int();
}

// c::pthread_mutex_lock
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 203
signed int pthread_mutex_lock(struct __pthread_mutex_t_struct *__mutex)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  __CPROVER_assume(!(__mutex->locked != FALSE));
  __mutex->locked = 1 != 0;
  __CPROVER_atomic_end();
  return 0;
}

// c::pthread_mutex_unlock
// file /usr/local/ddv/models/con2/include/ddverify/pthread.h line 213
signed int pthread_mutex_unlock(struct __pthread_mutex_t_struct *__mutex)
{
/* pthread_mutex_unlock without lock */

__CPROVER_HIDE:
  ;
  /* pthread_mutex_unlock without lock */
  assert(__mutex->locked != FALSE);
  __mutex->locked = 0 != 0;
  return 0;
}

// c::put_user
// file /usr/local/ddv/models/con2/include/asm/uaccess.h line 48
signed int put_user(signed int size, void *ptr)
{

__CPROVER_HIDE:
  ;
  assert_context_process$link4();
  signed int return_value_nondet_int$1 = nondet_int();
  return return_value_nondet_int$1;
}

// c::register_blkdev
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 6
signed int register_blkdev(unsigned int major, const char *name)
{
  signed int result = nondet_int();
  return result;
}

// c::register_chrdev
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 33
signed int register_chrdev(unsigned int major, const char *name, struct file_operations$link5 *fops)
{
  struct cdev$link0 *cdev;
  signed int err;
  signed int return_value_register_chrdev_region$1;
  return_value_register_chrdev_region$1=register_chrdev_region((unsigned int)0, (unsigned int)256, name);
  major = (unsigned int)return_value_register_chrdev_region$1;
  cdev=cdev_alloc();
  cdev->owner = fops->owner;
  cdev->ops = fops;
  err=cdev_add(cdev, major << 20 | (unsigned int)0, (unsigned int)256);
  if(!(err == 0))
  {
    kfree((const void *)cdev);
    return err;
  }

  return (signed int)major;
}

// c::register_chrdev_region
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 23
signed int register_chrdev_region(unsigned int from, unsigned int count, const char *name)
{
  signed int return_value = nondet_int();
  __CPROVER_assume(return_value == 0 || return_value == -1);
  return return_value;
}

// c::release_region
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 92
void release_region(unsigned long int start, unsigned long int len)
{
  unsigned int i = (unsigned int)0;
  ddv_ioport_request_start = 0;
  ddv_ioport_request_len = 0;
}

// c::request_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c line 4
signed int request_irq(unsigned int irq, signed int (*handler)(signed int, void *, struct pt_regs *), unsigned long int irqflags, const char *devname, void *dev_id)
{
  signed int return_value_nondet_int$1 = nondet_int();
  if(!(return_value_nondet_int$1 == 0))
  {
    /* array `registered_irq' upper bound */
    assert((signed long int)irq < 16l);
    registered_irq[(signed long int)irq].handler = handler;
    registered_irq[(signed long int)irq].dev_id = dev_id;
    return 0;
  }

  else
    return -1;
}

// c::request_region
// file /usr/local/ddv/models/con2/include/linux/ioport.h line 90
struct resource * request_region(unsigned long int start, unsigned long int len, const char *name)
{
  unsigned int i;
  struct resource *resource;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned int)32ul /*[[struct resource]]*/);
  resource = (struct resource *)return_value_malloc$1;
  ddv_ioport_request_start = (signed int)start;
  ddv_ioport_request_len = (signed int)len;
  return resource;
}

// c::schedule
// file /usr/local/ddv/models/con2/src/linux/kernel/sched.c line 8
void schedule(void)
{
  assert_context_process$link1();
}

// c::schedule_timeout
// file /usr/local/ddv/models/con2/src/linux/kernel/sched.c line 13
signed long int schedule_timeout(signed long int timeout)
{
  assert_context_process$link1();
  signed long int return_value_nondet_long$1 = nondet_loff_t();
  return return_value_nondet_long$1;
}

// c::schedule_work
// file /usr/local/ddv/models/con2/src/linux/kernel/workqueue.c line 5
signed int schedule_work(struct work_struct *work)
{
  signed int i = 0;
  while(i < 10)
  {
    /* array `shared_workqueue' lower bound */
    assert(0 + (signed long int)i * 8 >= 0);
    /* array `shared_workqueue' upper bound */
    assert((signed long int)i < 10l);
    if(shared_workqueue[(signed long int)i] == work)
      return 0;

    /* array `shared_workqueue' lower bound */
    assert(0 + (signed long int)i * 8 >= 0);
    /* array `shared_workqueue' upper bound */
    assert((signed long int)i < 10l);
    if(shared_workqueue[(signed long int)i] == ((struct work_struct *)NULL))
    {
      shared_workqueue[(signed long int)i] = work;
      return 1;
    }

    i = i + 1;
  }
  return -1;
}

// c::seconds_to_ticks
// file i8xx_tco.c line 118
static unsigned char seconds_to_ticks(signed int seconds)
{
  return (unsigned char)((seconds * 10) / 6);
}

// c::sema_init
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 6
void sema_init(struct semaphore *sem, signed int val)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  sem->init = 1;
  sem->locked = 0;
  __CPROVER_atomic_end();
}

// c::sleep_on
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 32
void sleep_on(struct __wait_queue_head *q)
{
  ;
}

// c::spin_lock
// file /usr/local/ddv/models/con2/include/linux/spinlock.h line 10
void spin_lock(struct anon$1 *lock)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(lock->locked == 0)
    {
      lock->locked = 1;
      __CPROVER_atomic_end();
      return;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
}

// c::spin_lock_bh
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 82
void spin_lock_bh(struct anon$1 *lock)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(lock->locked == 0)
    {
      lock->locked = 1;
      __CPROVER_atomic_end();
      return;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
}

// c::spin_lock_init
// file /usr/local/ddv/models/con2/include/linux/spinlock.h line 9
void spin_lock_init(struct anon$1 *lock)
{
  lock->init = 1;
  lock->locked = 0;
}

// c::spin_lock_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 58
void spin_lock_irq(struct anon$1 *lock)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(lock->locked == 0)
    {
      lock->locked = 1;
      __CPROVER_atomic_end();
      return;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
}

// c::spin_lock_irqsave
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 34
void spin_lock_irqsave(struct anon$1 *lock, unsigned long int flags)
{
  do
  {

  __CPROVER_HIDE:
    ;
    __CPROVER_atomic_begin();
    if(lock->locked == 0)
    {
      lock->locked = 1;
      __CPROVER_atomic_end();
      return;
    }

    __CPROVER_atomic_end();
  }
  while(TRUE);
}

// c::spin_unlock
// file /usr/local/ddv/models/con2/include/linux/spinlock.h line 15
void spin_unlock(struct anon$1 *lock)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  lock->locked = 0;
  __CPROVER_atomic_end();
}

// c::spin_unlock_bh
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 139
void spin_unlock_bh(struct anon$1 *lock)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  lock->locked = 0;
  __CPROVER_atomic_end();
}

// c::spin_unlock_irq
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 128
void spin_unlock_irq(struct anon$1 *lock)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  lock->locked = 0;
  __CPROVER_atomic_end();
}

// c::spin_unlock_irqrestore
// file /usr/local/ddv/models/con2/src/linux/kernel/spinlock.c line 117
void spin_unlock_irqrestore(struct anon$1 *lock, unsigned long int flags)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  lock->locked = 0;
  __CPROVER_atomic_end();
}

// c::tasklet_init
// file /usr/local/ddv/models/con2/src/linux/kernel/softirq.c line 32
void tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long int), unsigned long int data)
{
  t->count = 0;
  t->init = 0;
  t->func = func;
  t->data = data;
}

// c::tasklet_schedule
// file /usr/local/ddv/models/con2/src/linux/kernel/softirq.c line 4
void tasklet_schedule(struct tasklet_struct *t)
{
  signed int i;
  signed int next_free = -1;
  i = 0;
  while(i < 10)
  {
    /* array `tasklet_registered' lower bound */
    assert(0 + (signed long int)i * 16 >= 0);
    /* array `tasklet_registered' upper bound */
    assert((signed long int)i < 10l);
    if(tasklet_registered[(signed long int)i].tasklet == ((struct tasklet_struct *)NULL))
      next_free = i;

    /* array `tasklet_registered' lower bound */
    assert(0 + (signed long int)i * 16 >= 0);
    /* array `tasklet_registered' upper bound */
    assert((signed long int)i < 10l);
    if(tasklet_registered[(signed long int)i].tasklet == t)
    {
      if((signed int)tasklet_registered[(signed long int)i].is_running == 0)
        return;

    }

    i = i + 1;
  }
  /* array `tasklet_registered' lower bound */
  assert(0 + (signed long int)next_free * 16 >= 0);
  /* array `tasklet_registered' upper bound */
  assert((signed long int)next_free < 10l);
  tasklet_registered[(signed long int)next_free].tasklet = t;
  tasklet_registered[(signed long int)next_free].is_running = (unsigned short int)0;
}

// c::tco_timer_get_timeleft
// file i8xx_tco.c line 208
static signed int tco_timer_get_timeleft(signed int *time_left)
{
  unsigned char val;
  spin_lock(&tco_lock);
  val=inb(ACPIBASE + (unsigned int)96 + (unsigned int)0);
  val = val & (unsigned char)63;
  spin_unlock(&tco_lock);
  *time_left = (signed int)(((signed int)val * 6) / 10);
  return 0;
}

// c::tco_timer_keepalive
// file i8xx_tco.c line 172
static signed int tco_timer_keepalive(void)
{
  spin_lock(&tco_lock);
  outb((unsigned char)1, ACPIBASE + (unsigned int)96 + (unsigned int)0);
  spin_unlock(&tco_lock);
  return 0;
}

// c::tco_timer_set_heartbeat
// file i8xx_tco.c line 181
static signed int tco_timer_set_heartbeat(signed int t)
{
  unsigned char val;
  unsigned char tmrval;
  tmrval=seconds_to_ticks(t);
  if(!((signed int)tmrval > 63))
  {
    if((signed int)tmrval < 4)
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return -22;
  }
  spin_lock(&tco_lock);
  val=inb(ACPIBASE + (unsigned int)96 + (unsigned int)1);
  val = val & (unsigned char)192;
  val = val | tmrval;
  outb(val, ACPIBASE + (unsigned int)96 + (unsigned int)1);
  val=inb(ACPIBASE + (unsigned int)96 + (unsigned int)1);
  spin_unlock(&tco_lock);
  if(!((63 & (signed int)val) == (signed int)tmrval))
    return -22;

  heartbeat = t;
  return 0;
}

// c::tco_timer_start
// file i8xx_tco.c line 125
static signed int tco_timer_start(void)
{
  unsigned char val;
  spin_lock(&tco_lock);
  pci_read_config_byte(i8xx_tco_pci, 212, &val);
  val = val & (unsigned char)253;
  pci_write_config_byte(i8xx_tco_pci, 212, val);
  val=inb(ACPIBASE + (unsigned int)96 + (unsigned int)8 + (unsigned int)1);
  val = val & (unsigned char)247;
  outb(val, ACPIBASE + (unsigned int)96 + (unsigned int)8 + (unsigned int)1);
  val=inb(ACPIBASE + (unsigned int)96 + (unsigned int)8 + (unsigned int)1);
  spin_unlock(&tco_lock);
  if(!((8 & (signed int)val) == 0))
    return -1;

  return 0;
}

// c::tco_timer_stop
// file i8xx_tco.c line 149
static signed int tco_timer_stop(void)
{
  unsigned char val;
  unsigned char val1;
  spin_lock(&tco_lock);
  val=inb(ACPIBASE + (unsigned int)96 + (unsigned int)8 + (unsigned int)1);
  val = val | (unsigned char)8;
  outb(val, ACPIBASE + (unsigned int)96 + (unsigned int)8 + (unsigned int)1);
  val=inb(ACPIBASE + (unsigned int)96 + (unsigned int)8 + (unsigned int)1);
  pci_read_config_byte(i8xx_tco_pci, 212, &val1);
  val1 = val1 | (unsigned char)2;
  pci_write_config_byte(i8xx_tco_pci, 212, val1);
  spin_unlock(&tco_lock);
  if((8 & (signed int)val) == 0)
    return -1;

  return 0;
}

// c::tty_set_operations
// file /usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c line 14
void tty_set_operations(struct tty_driver *driver, const struct tty_operations *op)
{
  driver->open = op->open;
  driver->close = op->close;
  driver->write = op->write;
  driver->put_char = op->put_char;
  driver->flush_chars = op->flush_chars;
  driver->write_room = op->write_room;
  driver->chars_in_buffer = op->chars_in_buffer;
  driver->ioctl = op->ioctl;
  driver->set_termios = op->set_termios;
  driver->throttle = op->throttle;
  driver->unthrottle = op->unthrottle;
  driver->stop = op->stop;
  driver->start = op->start;
  driver->hangup = op->hangup;
  driver->break_ctl = op->break_ctl;
  driver->flush_buffer = op->flush_buffer;
  driver->set_ldisc = op->set_ldisc;
  driver->wait_until_sent = op->wait_until_sent;
  driver->send_xchar = op->send_xchar;
  driver->read_proc = op->read_proc;
  driver->write_proc = op->write_proc;
  driver->tiocmget = op->tiocmget;
  driver->tiocmset = op->tiocmset;
}

// c::unregister_blkdev
// file /usr/local/ddv/models/con2/src/linux/block/genhd.c line 17
signed int unregister_blkdev(unsigned int major, const char *name)
{
  return 0;
}

// c::unregister_chrdev
// file /usr/local/ddv/models/con2/src/linux/fs/char_dev.c line 55
signed int unregister_chrdev(unsigned int major, const char *name)
{
  return 0;
}

// c::up
// file /usr/local/ddv/models/con2/src/linux/kernel/semaphore.c line 106
void up(struct semaphore *sem)
{

__CPROVER_HIDE:
  ;
  __CPROVER_atomic_begin();
  assert_context_process$link2();
  sem->locked = 0;
  __CPROVER_atomic_end();
}

// c::vmalloc
// file /usr/local/ddv/models/con2/src/linux/mm/vmalloc.c line 6
void * vmalloc(unsigned long int size)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned int)size);
  return return_value_malloc$1;
}

// c::wake_up
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 8
void wake_up(struct __wait_queue_head *q)
{
  ;
}

// c::wake_up_all
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 16
void wake_up_all(struct __wait_queue_head *q)
{
  ;
}

// c::wake_up_interruptible
// file /usr/local/ddv/models/con2/src/linux/kernel/wait.c line 24
void wake_up_interruptible(struct __wait_queue_head *q)
{
  ;
}

// c::watchdog_cleanup
// file i8xx_tco.c line 551
static void watchdog_cleanup(void)
{
  if(nowayout == 0)
    tco_timer_stop();

  misc_deregister(&i8xx_tco_miscdev);
  unregister_reboot_notifier(&i8xx_tco_notifier);
  release_region((unsigned long int)(ACPIBASE + (unsigned int)96), (unsigned long int)16);
  pci_dev_put(i8xx_tco_pci);
}

// c::watchdog_init
// file i8xx_tco.c line 492
static signed int watchdog_init(void)
{
  signed int ret;
  spin_lock_init(&tco_lock);
  unsigned char return_value_i8xx_tco_getdevice$1;
  return_value_i8xx_tco_getdevice$1=i8xx_tco_getdevice();
  if(i8xx_tco_pci == ((struct pci_dev$link15 *)NULL) || return_value_i8xx_tco_getdevice$1 == 0)
    return -19;

  struct resource *return_value_request_region$2;
  return_value_request_region$2=request_region((unsigned long int)(ACPIBASE + (unsigned int)96), (unsigned long int)16, "i8xx TCO");
  signed int return_value_tco_timer_set_heartbeat$3;
  if(return_value_request_region$2 == ((struct resource *)NULL))
  {
    printk("<3>i8xx TCO timer: I/O address 0x%04x already in use\n", ACPIBASE + (unsigned int)96);
    ret = -5;
  }

  else
  {
    outb((unsigned char)0, ACPIBASE + (unsigned int)96 + (unsigned int)4);
    outb((unsigned char)3, ACPIBASE + (unsigned int)96 + (unsigned int)6);
    return_value_tco_timer_set_heartbeat$3=tco_timer_set_heartbeat(heartbeat);
    if(!(return_value_tco_timer_set_heartbeat$3 == 0))
    {
      heartbeat = 30;
      tco_timer_set_heartbeat(heartbeat);
      printk("<6>i8xx TCO timer: heartbeat value must be 2<heartbeat<39, using %d\n", heartbeat);
    }

    ret=register_reboot_notifier(&i8xx_tco_notifier);
    if(!(ret == 0))
      printk("<3>i8xx TCO timer: cannot register reboot notifier (err=%d)\n", ret);

    else
    {
      ret=misc_register(&i8xx_tco_miscdev);
      if(!(ret == 0))
        printk("<3>i8xx TCO timer: cannot register miscdev on minor=%d (err=%d)\n", 130, ret);

      else
      {
        tco_timer_stop();
        printk("<6>i8xx TCO timer: initialized (0x%04x). heartbeat=%d sec (nowayout=%d)\n", ACPIBASE + (unsigned int)96, heartbeat, nowayout);
        return 0;
      }

    unreg_notifier:
      ;
      unregister_reboot_notifier(&i8xx_tco_notifier);
    }

  unreg_region:
    ;
    release_region((unsigned long int)(ACPIBASE + (unsigned int)96), (unsigned long int)16);
  }

out:
  ;
  pci_dev_put(i8xx_tco_pci);
  return ret;
}

